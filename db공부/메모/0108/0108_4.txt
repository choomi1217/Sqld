참석자 1 
해야 되고 파라미터 객체에다가 업핸드 해서 스트레스 파이드 해서 어핸드를 해줘야 되고 거기다가 입력 값을 다인딩을 해줘야 되고 실행을 해줘야 되죠 그죠 그러니까 귀찮으니까 개발자분들이 이 에스트 자체가 그냥 리터럴로 해가지고 뒤에서 그냥 반영하지 않고 그냥 문자로 처리를 해버린다는 얘기예요. 
그래서 아까 같은 현상이 생기는데
참석자 1 
제가 쉬는 시간에 추가한 게 뭐냐면 요즘은 프레임목을 많이 쓴다고 그랬죠 그래서 아이바티스 마이바티스에서의 반주 테폭을 제가 이렇게 예시를 들어놨습니다. 
요즘에는 이걸 많이 써요. 보시다시피 엑셀을 냉기즈로 직접 하시는 게 아니고 뭐냐 엑셀을 스타일로 엑셀 스타일 레스키를 정리하고

참석자 1 
실행을 해서 그 세을 리스트를 읽어다가 시행을 하는 식으로 하죠. 
그래서 이렇게 앞 뒤에다가 샵을 붙여서 이렇게 실행을 하게 되면 알베티스나 알베티스에서는 이것을 가면서 인식을 해서 간 처리를 해줍니다. 
프레임하고 대신 해주는 거죠. 다 처리를 그러니까 개발자분들이 이제 예전보다 훨씬 쉬워지니까 쉽게 이렇게 코딩을 하니까

참석자 1 
리틀 레스케르한 새 바일스가 줄어들었다는 얘기예요. 
아마 여러분들 대부분 이런 환경으로 개발하시죠 요즘에 스프링도 그렇고 vc를 제가 방금 추이 하나 추가해놨습니다. 
그렇지만 프레임을 쓰지 않는 솔루션 개발 팀에서 여전히 이런 스타일로

참석자 1 
개발하다 보니까 프리 쓰지 않고 하다 보니까 리크레스트를 양산하는 그런 문제들이 있다라고 얘기를 드렸던 겁다니 그런 리트 에스크를 찾아내는 에스케 제가 알려드렸고 그럼 그 좋은 마인드면서 쓰면 되지 않느냐 항상 가지 어서 쓰면 되지 않나 생각할 수 있는데

참석자 1 
그렇지 않습니다. 바인디먼스의 장점이 있는 반면에 또 바인디먼스가 가진 부작용이 있어요. 
어떤 부작용이 있는지 그 부작용을 해소하기 위해서 어떤 법을 써야 되는지를 아셔야 되겠죠.

참석자 1 
아까 보여드린 것처럼 sql의 과정은 처리 과정은 이렇습니다. 
사용자가 sql 실행을 하면 파싱을 하고 pc에 존재하는지 확인을 하고 없으면 하드 카싱 있으면 바로 실행하는 소프트 가스 처리된다고 했습니다. 
그러면 발인딩 변수를 썼을 때 그럼 어떻게 처리될 것이냐 바인딩이 언제 될 것이냐 바인딩은 실행 직전에 됩니다 가드 변수 값을 사용자가 입력한 값을 변수에다가 개입하는 시점이 바로

참석자 1 
실행하기 바로 직전 시점이라는 거예요. 
직전 시점 이게 왜 중요하냐면 결국 바인딩되는 시점에는 이미 실행 계획이 이미 만들어진 상태다 프로시저가 이미 완성된 상태다라는 얘기죠 완성된 상태에서 그거를 간만에 대입해서 실행하는 거예요. 
간만 대입해서 그러다 보니까 어떤 문제가 생기냐면

참석자 1 
칼럼 분포를 활용 못해요. 제가 아까 통계 정보에 대한 얘기를 잠깐 드렸다시피 옵티마이저는 통계 정보를 기반으로 작동을 한다고 그랬고 그 통계 정보에는 여러 가지 있겠습니다만 그중에 하나가 중요한 것 중에 하나가 칼럼 분포거든요. 
성별로 얘기하면 남자는 몇 프로 여자는 몇 프로 이런 정보를 갖고 있다. 
그랬죠 키토랑 없이 mdb로 그냥 m 분의 1로 하는 경우도 있지만

참석자 1 
분포가 균열되지 않을 때는 칼럼 시도램을 이용을 해요. 
똑같이 50대 50이면 그냥 2분의 1로 하면 되지만 남자는 10% 여자는 90%인 경우도 있지 않습니까 그런 경우에는 칼럼 럼을 이용한다는 얘기죠 그런데 그 정보를 수집을 해놨는데도 불구하고 그걸 활용하지 못하는 문제가 생긴다는 얘기죠 왜냐하면 이미 이미

참석자 1 
최적화를 다 끝냈고 로우소스 즉 프로소까지 다 만들어진 상태에서 만든 상태에서 다이빙을 한 거잖아요. 
회신을 하는 거지 않습니까 이해가 잘 안 되실 텐데 예를 들어보겠습니다. 
아파트 매물을 검색을 해요. 매물을 검색하는데 보시다시피 당연하게도 서울시에 아파트가 제일 많이 있겠죠. 
그다음에 경기도가 많을 것이고 강원도나 제주도는 상대적으로 훨씬 적어요. 
아파트 매물이
참석자 1 
아파트가 적으니까 매물이 적겠죠. 당연히 지금 제주도에 가면 제주도에서 아파트 지금 많이 짓고 있겠습니다만 어쨌든 서울에 비하면 값이 적기 때문에 당연히 매물도 적을 수밖에 없습니다. 
그런데 조회를 하는데 어떻게 하냐면 도시 이콜 서울 여 옵티마가 sk의 사용자 개발자가 skl 이렇게 작성했으면 옵티마이저가 이런 비법을 알고 있거든요. 
서울시는 많고 강원도 제주는 적다는 걸 알기 때문에

참석자 1 
도시 콜 서울로 조회를 하게 되면 얘는 풀스캔을 할까요. 
이디스 할까요. 풀스캔으로 처리한다는 얘기예요. 
50%니까 경기도는 조회할 때도 상당히 많은 김포이기 때문에 풀스킨을 한다는 얘기죠 강원도는 제주도 조회를 하게 되면 핸드포가 얼마 안 됐기 때문에 이때는 이게 있었으면 좋겠다라고 이렇게 판단하는 거예요. 
옵티마이저가 이해되시죠 그런데 개발자가 바인드 변수 썼어요.

참석자 1 
바인더스를 그럼 어떻게 처리하면 될까요. 
인덱스를 할까요. 풀수가 할까요. 인데스트 할까요. 
왜왜 왜 인데스트 할까 생각하세요. 근데 만약에 서울시가 입력이 되면 인디스를 타는 쪽으로 시행령을 만들었어요. 
근데 서울시가 임명이 되면 그럼 악성행시킬이 되는 거죠.

참석자 1 
풀스캔 할까요. 근데 제주도로 입력하면 어떻게 하면 좋을까요. 
이스케 따로 짜야 된다 그렇죠 그게 이제 앞으로 해야 될 우리가 해야 될 해법이 바로 그거예요. 
이런 문제가 있기 때문에 결국 이 문제를 해결하려고 하면 sp를 따로 짜는 수밖에 없는 거예요.

참석자 1 
이것이 바로 바이드로드의 부작용이에요. 
풀 스캔을 해도 문제 이기스 스캔을 해도 문제인 거죠. 
이런 생각을 해볼 수 있을 것 같아요. 
서울시가 많으니까 아무래도 매물이 많으니까 조회도 많지 않겠어 그러면 대를 위해서 서울을 시행하는 마음으로 서울시 기준으로 풀 스캔을 해서 선택할 수 있겠죠. 
그러면 실제로 서울시가 조회가 많을 거니까 제주 도민이나 경기도민이 조금 선을 보더라도 서울시나 경기도를 위해서

참석자 1 
프로스템을 하도록 만들면 좀 더 입점이 생길 수 있을 걸로 알겠습니다. 
근데 꼭 그렇지가 않은 게 저 끝에 계신 분들 안 보여 죄송한데 이제 11번가에 매물이 있는데 매물이 있는데

참석자 1 
거의 99.9%는 배송 완료겠죠. 그죠 99.9%는 배송 완료겠죠. 
그죠 일부가 배송 전일 겁니다. 그죠 조회를 할 때 배송이 아직 완료되지 않은 건을 조회하려고 해요. 
발주분을 썼어요. 근데 만약에 bm 분포가 만쪽 기준으로 하면 되지라고 생각을 했을 때 그럼 배분이 계속 알릴 텐데 토지해서 처리가 되겠네요. 
그렇죠 그래서 저는
참석자 1 
경우만 고려한다고 하면 많은 쪽 기준으로 하면 그나마 조금 더 나은 데 될 수 있다고는 할 수 있습니다만 그렇지 않을 수도 있다는 얘기예요. 
그래서 이럴 수도 없고 저럴 수도 없는 그런 상황이 존재한다 그래서 이럴 때 웃기 하면 어떻게 하느냐 평균 분포를 가정합니다. 
모든 시도가 실제 데이터 분포는 이런데 실제 데이터 분포는 이런데 모든 시도가 다 똑같은 분포를 갖는다고 가정을 하는 거예요.

참석자 1 
결국 뭐예요. 아까 제가 얘기한 mdb 얘기하는 거죠. 
mdb로 나온다는 얘기예요. 전체 레코드 건수를 다수 종류로 나온다는 얘기예요. 
평균 포 가져 간다는 얘기 그니까 컬러 토그램이 이렇게 수집이 돼 있음에도 불구하고 그것을 활용하지 못하고 결국은 n분의 1로 나눈 걸 기준으로 판단을 하게 됩니다. 
이걸 기준으로 판단했을 때 다됐을 때 프로 스캔도 결정될 수도 있고 인덱스 스캔으로 결정될 수도 있는 거예요. 
평균 폭을 가졌을 때
참석자 1 
이걸 기준으로 생각해 보니까 옵티마이가 프로스캔이 좋다라고 생각할 수도 있고 인덱스 캔이 좋다고 결정할 수도 있다. 
이런 얘기죠 어느 쪽으로 결정됐든지 간에 반대 효과가 생길 수밖에 없는 거죠. 
그죠 그러면 이 문제를 어떻게 해결해야 되느냐 아까 말씀하신 그대로예요. 
sp를 두 개로 짜는 거예요. 에시케를 아예 두 개를 짜는 방법도 있겠죠. 
아이바티트 마이바티스트 같은 데서 에시케를 아예 이렇게 두 개를 등록을 해놓고

참석자 1 
레시피를 두 개를 등록해놓고 서울시나 경기도가 입력되면 1번 레시피를 갖다 쓰고 그 외 시도면은 이번 레시피를 갖다 쓰면 되는 거예요. 
그렇게 할 수도 있겠지만 위면 올을 이용해서 에스키를 분기를 해줄 수가 있습니다. 
보시는 것처럼 ct라는 변수를 이렇게 입력을 해요. 
조건들에 변수를 이렇게 사용을 해서 이 변수 값에 서울시나 경기도가 들어오면 출수해내라

참석자 1 
서울시나 경기도가 아니면 나인이죠. 나딘이면 인데스를 달라 이렇게 실행 계획을 고정시켜줄 수 있다는 얘기죠 그러면 서울시나 경기도 인 때는 위쪽이 실행이 될 것이고 서울시나 경기도가 아닌 시도가 들어왔을 때는 아래쪽에 시용이 되면서 인덱스를 하게 될 것 같습니다.

참석자 1 
좀 더 실전적인 사례를 들어 보여드리면 아래 코리가 됩니다. 
아래 코래 여러분들 거래 일자로 거래 데이터를 조회를 해요. 
근데 바디만을 썼어요. 근데 거래 일자가 bp 조건인데 프롬 dp부터 mddp까지 조회를 하는데 여기에는 하루 치 데이터를 조할 수도 있고 3일치를 조회할 수도 있고 일주일 치를 조회할 수도 있고 한 달 1년 치를 조회할 수도 있어요. 
그러면
참석자 1 
하루 치나 이틀 치는 당연히 인데 쓸 수 있는 게 유리하겠지만 한 달 치 1년 치를 좋아하게 되면 풀스윙이 유리할 거 아닙니까 그죠 오티바이지는 모르잖아요. 
그죠 어떤 값이 입력된지 모르니까 그냥 평균 분포를 가정을 세를 만든다고요 그러니 어떤 날짜가 입력되든 최적으로 되게 하려고 그러면 어떻게 하면 될까요. 
넓은 구간이 들어올 때는 풀스캔 짧은 구간이 들어왔을 때 인스트하게 하면 되겠죠.

참석자 1 
그걸 하기 위해서 어떤 처리를 한 거냐면 2dt에서 프롬 비트를 빼요 뺀 값이 4보다 작다 그래서 3일치 이내에 조회할 때는 인덱스를 파라 사보다 크다 그렇죠 3일치 이상 배울 때 필스캔 다 이렇게 조치를 하는 거예요. 
이게 실전적으로 많이 쓰는 튀김 방법 중에 하나입니다. 
이해되셨죠.
참석자 1 
물론 저 처리를 미니언 올로 하지 않고 어플릭션 레벨에서 그냥 값을 빼가지고 투 디티에서 프롬 비트를 빼가지고 어플릭션 레벨에서 서로 다른 에스캔을 셀렉션 할 수 있을 겁니다. 
그렇게 할 수도 있고 아니면 이면을 이용해서 sp를 저렇게 짤 수도 있겠다는 얘기죠 많이 쓰이는 트윙 패턴 중에 하나예요. 
데이터 분포 또는 조회 범위에 따라서 실행 계획을 분리하는 방법이죠.

참석자 1 
그래서 기본적으로 여러분들이 otp 우선 이걸 또 얘기해야 되겠구나 우선 이제 여러분들이 이번 시간에 이번 교육 과정에서 배우는 튜닝은 주로 주로 otp 성 오프레이션 튜닝이에요. 
otp otp가 뭔지 아시는 분 oltp와 원래의 구분을 할 줄 아시는 분

참석자 1 
나머지는 모르시는 건가요 배우분들 아시죠 근데 모르시는 분들이 계시니까 말씀드릴게요 이 oltv라는 게 뭐냐면 온라인 트랜잭션 프로세싱의 약자입니다. 
온라인 트랜잭션 프로세싱 온라인 말 그대로 온라인 트랜지션을 처리하는 프로그램을 의미하는 거예요.

참석자 1 
반대는 반대는 올렛 dw라고 해요. 올렛 올렛 또 dw dw 온라인 어뮬레틱 프로세싱 분석기 시스템이죠. 
분석계 시스템 분석계 온라인 트렌드 션이고 얘는 분석 시스템이에요. 
dw를 dw l을 포함해서 dw나 올랩에서는 주로 분석 작업을 많이 합니다.

참석자 1 
특정 고객 특정 계좌 단위로 처리하는 게 얘예요. 
특정 고객 특정 상품 특정 고객별로 주로 조회를 많이 하고 트레시를 처리 많이 합니다. 
원래에서는 특정 고객 특정 상품 특정 고객이 아니고 전체를 대상으로 분석 작업을 하는 겁니다. 
그룹 바이 이렇게 해가지고 데이터를 분석하는 거죠. 
집계를 내리는 거예요. 집계 작업을 주로 합니다. 
대용량 처리를 주로 하죠. 그러니까
참석자 1 
이쪽에서는 특정 데이터를 주로 처리하기 때문에 인덱스를 잘 활용하고 조인으로 말하면 nl 조인을 주로 활용하고 그런 쪽에 포커스가 맞춘 반면 이쪽은 인덱스를 어떻게 잘 활용하느냐가 아니에요. 
프스캔을 어떻게 더 빨리 할 것이냐 벽면 처리 파티션 그런 쪽이 두 주요 트윙 요소라는 얘기죠

참석자 1 
그리고 이쪽은 동시 접속이 많은 황이기 때문에 파싱에 대한 부분도 되게 중요합니다. 
커리 하나 자체가 0.01초를 다투는 그런 커리들이 많기 때문에 파 타임 0.001초의 파심 타임이 굉장히 중요한 비중을 차지할 수밖에 없어요.

참석자 1 
커리들 자체가 1초 미만의 커리들이 많기 때문에 1초 미만의 커리들에 있어서 0.01 타워의 팔심타는 굉장히 중요할 수밖에 없거든요. 
반면 이쪽 커리들은 다 대용량 커리들이에요. 
보통 커리들이 빨라야 3초 5초 보통 막 10초 1분 몇십 분 걸리는 커리들이 많다는 얘기죠 10분 걸리는 쿼리에 있어서 0.00초에 파 타임은 대세에 영향을 안 주죠 그죠 무시해도 될 만한 그러면 이쪽에서는 파 지금까지 설명드린

참석자 1 
에스q 파싱 하드 파싱에 대한 요소들은 전혀 고려 여사가 못 된다는 얘기예요. 
무슨 얘긴지 아시겠죠. 그죠 그래서 우리가 지금 다루는 우리가 기본 과정은 우리가 파티와 경영 체제에서 안 다룹니다. 
주로는 이쪽에 포커싱이 맞춰져 있다라는 얘기예요. 
그 얘기를 왜 하냐면 제가 지금까지 하드 파싱에 대한 말씀을 드렸는데 바이디건스

참석자 1 
그러니까 왜 중요하냐 라이브리 키시의 부하를 줄이기 위해서 그런 거예요. 
라이브 키시의 부하 매지컬을 파싱하는 과정에서 생기는 부하를 줄이기 위해서 그것이 필요한 건데 라이브 캐시의 부활을 줄 가능성이 낮다면 낮다라고 하면 오히려 리트라 향수 값을 쓰는 것이 더 나은 상태일 수 있다는 얘기죠 문제의 핵심은 라비 핏이 80 부하예요. 
근데 그 부하를 줄 가능성이 낮다면 수용 빈도가 별로 없고 수용 빈도가 별로 없고

참석자 1 
또 한 번 수정할 때 오래 걸리고 그런 쿼리들은 무시해도 된다는 얘기죠 오히려 그런 쿼리들은 니터한 상수를 쓰는 게 더 좋다 왜냐 아까 말씀드린 것처럼 칼럼 분포를 사용할 수 있잖아요. 
히스토라임을 그죠 오히려 그 컬럼 히트 시트를 사용함으로써 더 좋은 실행력을 만들어낼 가능성이 더 높아진다는 얘기죠 굳이 우리가 이렇게 sp를 막 분리하고 이렇게 할 필요 없이

참석자 1 
이렇게 하지 않더라도 높이마자 알아서 긴 값이 넓은 거미만 들어오면 자기가 알아서 프로스트으로 가고 좋은 거미가 들어오면 자기가 알아서 이것을 타고 그렇게 한다는 얘기죠 갈면서 안 쓰게 되면 sk 성능만 놓고 보면 파신 타입 말고 아이오 측면에서 sk 성능만 놓고 보면 리터를 상속할 때 더 좋다는 얘기입니다. 
좋은 시행계획을 만들어낼 가능성이 더 높다라는 얘기죠 리트럴 산수를 쓰게 되면 그럼에도 불구하고 리트라 산수를 못 쓰는 이유는 팔순 구가 때문에 그러는 거예요. 
왜 경에서
참석자 1 
동시에 많이 실행되는 그런 지표들이 있어서 패싱 타임이 차지하는 비중이 높아짐으로 인해서 늦어지는 또는 경합 때문에 못 쓰는 거죠. 
리트상스가 더 좋음에도 불구하고 못 쓰는 거 그 그래서 우리가 일반적으로는 이트레이스 때 쓰는 게 좋습니다. 
월티에서는 월티피에서 일반적으로 리트레이스 리틀 상수 값을 아니죠. 
반드면서 쓰고 쓰고 예외적으로 예외적으로 리트럴 상수값을 쓰는 게 좋다는 얘기예요. 
기본은 반지면서 쓰고
참석자 1 
예외적으로 이트럴 그래서 그 예외라는 것이 어떤 경우냐면 가스의 종류가 많지 않을 때 아까처럼 고객 번호를 만약에 리트 레시피를 쓰게 되면 고객 개수만큼 프로시가 만들어지는 거지만 예를 들어 성별이다. 
성별 그럼 기법 때 레시피 두 개 만들어지는 거지 않습니까 두 개 때문에 알패시에 무슨 저가 되겠습니까 레시피를 하나 더 만드는 건데 하나 더 카싱 하는 건데

참석자 1 
또 무슨 무슨 코드 근데 코드가 가스 종류가 하나 둘 3개밖에 안 돼요 그럼 기값에 에스크 하나 만드냐 2개 만드냐 3개 만드냐 문제지 않습니까 잠깐만요 3개밖에 안 된다고 하더라도 가세 분포가 균이라면 리터를 sqi 굳이 쓸 필요는 없어요. 
어차피 33% 33%면 그냥 발을 써도 되는데 균열하지 않을 가능성이 높지 않습니까 그럼 균열하지 않으면 의도적으로 리플라 레시피를 쓸 수도 있다는 얘기예요.

참석자 1 
또는 대치 프로그램이나 bw 올래성 등 정보기성 퀄들 아까 말씀드린 이쪽 정고객성 퀄들은 워낙에 오래 걸리는 쿼리들이기 때문에 굳이 발도 쓰려고 할 필요가 없다라는 얘기예요. 
0.01초 줄이려고 그리고 otp성 퀄리라고 하더라도 사용 빈도가 아주 낮은 쿼리들 초 단위로 막 10번 100번 1천 번 사용되는 게 아니고 1시간에 한 번 하루에 2번

참석자 1 
이런 컬들은 굳이 발만 쓰실 필요 없어요. 
리트레이시를 쓰시는 게 오히려 더 쿼리 성능 면에서 좋습니다. 
더 좋은 플랜을 만들어낼 가능성이 높다라는 얘기죠 질문 해보시죠 아까 무슨 주셨 이제 틀리죠 이게 같은 커리가 동일하게 여러 번 실행되니까 사실 바인드 변수를 거의 쓰는데 그렇죠 거의 쓰는데 근데 이제 아까 말씀 들어봤을 때 바인드 변수를 했었을 때 나타나는 부작용이 있잖아요.

참석자 1 
검토를 제대로 활용할 수가 없는 활용할 수 없는 사실 거의 거의 모든 에스크 대부분의 에스크를 거의 다 가이드 변수로 처리를 하고 있기 때문에 사실은 그냥 데이터 분포도는 통계 정보에 중에서 데이터 분포도는 활용을 거의 못한다고 봐야 됩니다. 
못하고 있는 거죠. 네
참석자 1 
제가 지금 말씀드린 게 그럼에도 불구하고 기본은 다 이 환경이라고 하면 이 환경이라고 한다면 기본은 다리로 쓰셔야 된다 워낙에 미치는 피해가 크니까 리터를 썼을 때 다만 의도적으로 리터럴을 써야 되는 쓰는 게 좋을 수 있다. 
예외적으로 그 예가 바로 여기 설명된 내용들이죠. 
가스 분포가 균열하지 않는 경우 균열하지 않고

참석자 1 
사용도가 낮은 경우 가스 분포가 균일하면서도 사용도가 높으면 높으면 아까 얘기하신 거 트링 해야 되는 거예요. 
균열하지 않고 그렇죠 분간 균열하지 않지 않습니까 저기 넓은 간 조회할 수도 있고 좁은 구간 조회할 수도 있고 수용도가 높아요. 
높아요. 그런데 좋은 실행기를 만들자고 니트럴를 쓰게 되면 팔심부가 생기는 거고 그러니까 팔심부어를 없애면서도 기원 시행을 만들어내기 위해서 이런 책이 필요한 것이죠.

참석자 1 
근데 얘가 만약에 어쩌다 한번 시행되면 커리면 복잡하게 이렇게 할 필요 없다는 얘기예요. 
그냥 리터럴로 처리해 버리면 되는 거죠. 
그럼 ot마이제가 알아서 넓은 구간은 풀스킨 좁은 구간은 인스스캔 알아서 할 거 아닙니까 훨씬 거를 일으키지 않으니까 어쩌다 한번 시험 되니까 그래서 이 pa이라는 것이 딱 정해진 어떤 공식이 있는 게 아니에요.

참석자 1 
내가 지금 t하고 있는 시스템이 어떤 시스템이냐에 따라서 판단을 달리하셔야 됩니다. 
이것이 oltp냐 올랩이냐 dw냐 그리고 부채 이건 이제 나중에 부모 되고 나서 또 하려 하지만 부부가 가능한 환경이냐 그렇지 않은 환경이냐에 따라서도 달라져야 되고 나중에 그 과정 spp 과정 들어오시면 제가 계속 강조 드릴 말씀드리는데 공식구로 하시면 안 됩니다.

참석자 1 
대부분 spp에 막 어떤 분들은 제일 많이 보고 오신 분이 7번 시험 보고 저한테 그 들어오셨어요. 
7번씩 했는데 안 되니까 그냥 들어오셨는데 제가 skp 가져가서 계속 드리는 말씀이 뭐냐면 공식으로 하셔서 그렇다 공식으로 탈턴으로 외워서 하셔서 그렇다 제대로 된 원리를 이해하려고 하지 않으시고 자꾸 공식만 외우세요. 
패턴만 외우시려고 하시고
참석자 1 
그 패턴을 배우기에 앞서서 원리를 먼저 아셔야 되거든요. 
그 패턴이 언제 적용되는 패턴인지 분명히 skt 중에는 패턴이라는 게 있어요. 
자주 사용되는 패턴이 분명히 존재하거든요. 
그 패턴만 열어볼 수 있는 거죠. 근데 문제는 그 패턴이 각각 언제 쓰는 패턴인지를 아셔야 된다는 원리를 먼저 아셔야 되는 거죠. 
그래서 항상
참석자 1 
원리를 정확히 아시고 또 어떤 이런 환경적인 요소들을 잘 감안하셔서 그 상황에 맞는 팀 해법들을 찾을 수 있는 그런 공부를 하셔야 돼요 스터게 공부하시는 분들은 너무 급하게 생지 마세요. 
이게 한두 달 공부한다고 되는 게 아니고 수업 몇 시간 들었다고 되는 문제가 아니에요. 
제가 저 스스로 말하지만 저 기본 과정 시 4일

참석자 1 
그것까지 사 이거 들었다고 에스큐 짤 수 있을까요. 
저 자신 못해요. 저 그럴 능력 없습니다. 
수업 8일 들었다고 해서 갑자기 에스크 전문가 되는 건 아니지 않습니다. 
훨씬 더 많이 공부하셔야 돼요 다른 내용들은 기본적인 원리를 다루는 것이고 이 원리를 바탕으로 현장에서 많은 경험들을 하셔야 돼요 경험들을 하신 걸 바탕으로 내가 자신감이 생겼을 때 그때 시험을 보시는 게 올바른 순서라고 저는 생각을 합니다. 
그렇게 서두르시면
참석자 1 
안 될 것 같아요. 자격증 자체가 큰 의미를 두지 않거든요. 
그걸 공부하는 과정 자체에서 얻는 게 더 크다라는 거죠. 
질문 있으면 더 해보시고요 예 말씀해 주세요. 
장인 변수를 사용해서 되는데 실질적으로는 실행계획을 봤을 때 달라지는 경우도 있더라고요 실행 계획이

참석자 1 
가이드 변수를 인드 변수마다 두 개씩 나올 때도 있고 fql 아이디는 같은데 그런 경우에 힌트를 써서 해결하긴 했는데 어떤 경우에 그렇게 발생할 수 있는지 좀 궁금해서 제가 이제 시간을 줄이기 위해서 사실 이게 생략하는 내용인데 이것도 그것까지는 또 나오는 내용이에요.

참석자 1 
이게 이제 고급 과정 구제를 열었습니다. 
지금 말씀드린 게 이제 발전의 부작용이고 이 부작용을 해소하기 위해서 해소하기 위해서 디드메스의 다양한 시도들을 합니다. 
제일 첫 번째 시도가 뭐냐면 바비노스 피킹이에요. 
피킹 규제 없어요. 여러분 규제 없고 그가 중에 나올 얘기인데 다 들어서 피킹 그니까 이 피크라는 말이 몇 본다는 뜻이에요. 
훔쳐본다는 뜻입니다.
참석자 1 
그래서 뭘 훔쳐보냐면 첫 번째 실행할 때 입력한 값을 살짝 훔쳐봐요 여기 보시면

참석자 1 
캐시에 존재하는지를 확인해 보고 이미 프로스트를 만들고 그다음에 반딩해서 실행한다고 그랬죠 그렇죠 실행하기 직전에 반딩하는데 반딩하는데 얘를 최적화하는 시점이 이미 sk가 날아왔고 이 반딩에서 이미 넘어왔거든요. 
너무 많기 때문에 이 최적화 시점에 이 바인딩 건수를 살짝 훔쳐보는 거예요. 
실제 바인딩한 시점은 프로시를 만들고 나서 바인딩 하지만

참석자 1 
그전에 최적화하는 과정에 걔를 살짝 훔쳐봐요 훔쳐봐서 그때 입력된 값을 가지고 시행을 만든다는 얘기죠 그래서 그래서 그때 만약에 첫 번째 실행 그 첫 번째 실행이라는 것이 라이브 켓이 올라가 시점 하드 파싱에서 라이브 켓이 올라가는 그 시점을 말하는 거예요. 
그 시점에 만약에 첫 번째 서울시를 입력했으면 서울시를 기준으로 히스트럼을 이용을 해서 실행을 만들어요. 
프리스캔 하나 실행이 만들어졌겠죠. 그죠

참석자 1 
그때 그렇게 실행을 하다가 얘가 매물이 떨어져 내려가요 다시 실행했더니 그때는 제주도가 입력이 됐어요. 
그럼 이번에는 어떻게 될까요. 이거 또 훔쳐 보니까 제주도가 인용됐으니까 여기는 인데스 스킨이 나오겠죠. 
그 어떤 현상이 발생해요. 그러면 어떨 때는 프로스 어떨 때는 이디스캔 실행 중이 막 수시로 바뀌어요. 
그래서 안타깝게도 이 기능은 나오자마자

참석자 1 
폴스로 오프 시키는 게 공관이 돼버리는 아주 불행한 기능입니다. 
비스 오라클 엔지니어들 설치하면서부터 아예 그냥 얘를 폴스로 다 막아버려요. 
장점이 없어요. 그죠 어떤 dba가 이거 그대로 쓰겠습니까 똑같은 프로그램인데 어떨 때 스캔 어떨 때는 디스캔 막 계속 시행이 수시로 바뀌어요. 
차라리 항상 느리면 그냥 느린 거냐 을 텐데 어떻든 빨랐다. 
어떤 느려졌다 운영자 관리자 입장에서 제일

참석자 1 
답답한 건 바로 그런 거거든요. 안정성이 떨어지는 거거든요. 
매번 가는 그래서 이 기능은 그냥 아예 처음부터 못 쓰는 기능으로 딱 포스로 세팅을 해버리고 그다음에 나온 게 적응적 커서 공이에요. 
적응적 커서 그 어댑티브 커서 셰어링이죠. 
커서를 하나를 쓰는 게 아니고 두 개를 두 개 이상을

참석자 1 
가지고 쓰는 거예요. 그래서 서울시가 들어왔을 때는 그러니까 풀스캔 하는 실행계획 인덱스 쓰는 실행계획 2개를 만들어놓고 서울시가 들어왔을 때는 프스캔 경기도로 들어왔을 때도 풀스캔 제주도가 들어오면 이게 스캔하는 그래서 그때그때 따라 적응하는 거죠. 
적응적으로 되게 좋은 기능이죠. 그렇죠 바로 그거다 우리가 원했던 게 그거다라고 생각할 수 있는데 얘도 역시 배운다 포스로 떠버려요. 
왜 그러냐면
참석자 1 
처음부터 그렇게 작동하면 그렇게 쓰면 될 텐데 얘가 시행착오법이에요. 
시행착오법 요 밑에 보시면 저거 커서요. 
공연의 문제점 시행처법이라고 돼 있죠 처음에는 이 기능이 작동하지 않아요. 
작동하지 않고 그냥 실행기를 만들어 놓고 코스트를 100을 예상하고 시행을 만들었는데 나중에 실제 시행해 보니까 코스트가 많이 해요. 
실제 코스트가 100이라는 것은 아이오콜이 100번 발생할 것 예상하는 거지 않습니까

참석자 1 
근데 실제 실행해 보니까 아이오클이 10만 번 발생해요. 
거 예상과 다르네 그러면 그제서야 얘가 딱 온으로 바뀌면서 이제 바인드 어웨어 몬으로 싹 바뀌어요. 
바뀌면서 그때부터 그게 작동을 해요. 
어때요 여전히 실행 계획이 들쑥날쑥 그죠 어떨 때는 이렇게 잡혀있다가 한 번 늦었다가 다시 하니까 더 빨라졌다가

참석자 1 
또 문제는 그렇게 가드 오헤어 모드로 바뀌어서 시행이 됐는데 또 시간이 지나니까 이게 또 밀려 내려가네요. 
다시 올라오는 시점에 또 다시 원법 또 시행착오법 그래서 여전히 이 기능도 완벽하지 않고 운영자들로부터 당황하게 만드는 그런 요소로 작동하고 있습니다. 
그래서 이 기능 역시도 대부분 시스템에서 다 그냥

참석자 1 
바로 요 파라미터인데 옵티마이즈 어드에티브 커서 쉐어링 요 파라미터인데 이 기능도 대부분 다 끄고 운영하고 있어요. 
오라클은 대부분 다 대형 시스템에서 주로 쓰지 않습니까 하나의 작은 실수가 큰 문제를 초래할 수 있는 그런 미션 크리티컬 시장을 주로 쓰기 때문에 이런 주로 오토매틱한 기능 어디 피부가 붙은 기능들 오케 매팅이 붙은 기능들은 대부분 다 꺼버려요. 
비비 그래서 이 기능도
참석자 1 
실제로 작동하지 않는다라고 생각하시면 돼요 저는 이 기능은 잘 쓰면 좋다고 생각해요. 
언제 이럴 때 이럴 때는 쓰면 좋다고 생각해요. 
한 번은 느리더라도 두 번째부터 빨라지면 얼마나 좋습니까 그죠 이쪽 시스템에서는 허리가 조금 늦게 걸려도 큰 문제가 없는 시스템이에요. 
대부분 다 느린 쿼리들이기 때문에 하지만 이쪽에서는 쓸 수가 없다는 얘기죠 정적 커다라는 얘기고

참석자 1 
또 이제 아까 질문하신 내용 중에 또 이제 피드백 카리넬라티 피드백이라는 기능이 있어요. 
카리놀라티 피드백 그런 기능들 때문에 또 그렇게도 돼요. 
카리나이트를 예상을 하고 실행을 했는데 해보니까 팔지너트가 예상과 달라 실제 실행해 보니까 그럼 또 얘를 또 그 피드백을 받아서 실행 결과를 피드백으로 해서 또 실행률을 또 고치는 기능들이 있어요.

참석자 1 
그런 기능들 때문에 말씀하신 것처럼 똑같은 sk이고 똑같은 값을 입력했는데 그때그때 조금 다르게 나올 수 있는 요소들이 있다라는 얘기죠 요즘에 이제 인공지능 얘기가 많이 나오면서 dbm에서도 그런 기능들을 계속 추가해 나가고 있어요. 
인공지능이라기보다는 셀프 러닝 셀프 러닝 옵티마이저 스스로 학습하는 옵티마이저 기능이 계속 도입이 되면서

참석자 1 
아까 얘기한 오토매틱 어댑티브 이런 이름이 붙은 사용자가 붙은 기능들이 계속 추가되고 있거든요. 
근데 계속 거기 말씀드리지만 오라클로 대부분 다 대형 시스템이기 때문에 그런 기능들은 대부분 다 끄고 있어요. 
작동하고 있지 않다라고 생각하시면 됩니다. 
아 그 추세는 바뀌지 않을 겁니다. 요즘에 여러분들 오라클이 자주 쓰는 마케팅 이용화 뭐예요. 
자율 주행
참석자 1 
제일 명 비 많이 들어오셨죠. 그죠 홍모면 매일 날아오죠 그거 쓸 수 있을까요. 
자율 주행 자주행 뭐예요. dba가 없어도 된다는 얘기예요. 
dba가 없어도 알아서 막 운영이 되는 db죠 인예로 인덱스가 자동으로 만들어져요. 
인덱스가 무서워서 쓸 수 있을까요. 아까 말한 거래소라든지 키움 스판이라든지

참석자 1 
이런 데서 은행에서 쓸 수 있을까요. 
갑자기 없던 인빅스가 갑자기 새로 딱 만들어졌어요. 
더 좋으려고 한 거지만 의도는 좋은데 만약 인빅스가 새로 만들어지면서 다른 비슷한 놈들이 이쪽으로 막 붙어요. 
그러면서 더 좋아질 수도 있지만 나빠질 수도 있거든요. 
옵티마가 완벽하지 않기 때문에 잘못된 판단을 언제든지 할 수 있거든요. 
은행에서 만약에 또는 증권사에 그런 거 쓰다가 난리 나죠 그죠 자율 주행 그런 비비는 어떻게 보면 마케팅적인 용어예요.

참석자 1 
또는 이쪽에 적용할 수 있겠죠. dw 쪽에 많은 기계분들이 요즘에 기계를 떠나고 계세요. 
오라이 하도 잘 주행 잘 주행하니까 이제 나는 앞으로 한 5년 후 10년 후가 되면 나는 일자리가 없어질 거라 생각해서 막 다들 다른 분들이 떠나고 계시는 그런 추세인데 그런 건 떨 필요 없어요. 
절대 그런 거는 있을 수가 없습니다. 
제가 볼 때는 어떻게 자율 주행을 합니까 비비를

참석자 1 
이런 데서는 가능하겠죠. 어느 정도 앞으로 근데 이쪽에서는 절대 자율 주행 할 수가 없어요. 
그러니까 너무 겁 먹지 마시고 기술력 향상해서 집중하시면 좋을 것 같습니다. 
지금 질문이 나오는 바람에 좀 제가 좀 구억가을 또 여서 보여드렸는데 또 또 다른 질문 있으실까요. 
질문 대답해 주시기 직전에 해 주신 말씀이 plt를 따거나 실력을 키우기 위해서는 현장에서 경험을

참석자 1 
통해서 예 다양한 고민을 해보라고 말씀해주죠 예 저 같은 경우는 현장에 직접적인 관련은 없거든요. 
이럴 때는 어떤 방법으로
참석자 1 
네 그런 분들을 위해서 제가 만든 책이 있죠. 
skt의 핵심 노트 거기는 문제 열심히 풀어보시면 되는데 그게 이제 그 교제가 제가 그런 분들을 위해서 에스큐 티니 워크샵이라는 과정을 만들었어요. 
에스큐 티니 워크샵 실전을 해보고 싶지만 해볼 수 없는 그런 분들을 위해서 신 워크숍이라는 과정을 만들었는데 그 교재 내용을 바탕으로 만든 책이 바로 그 책이에요.

참석자 1 
물론 다답지는 않고 스크래피의 시험 수준에 맞춰서 실제 교재에는 그것보다 더 고급 난이도의 어떤 그런 문제들도 더 많이 있지만 실제 에스큐피 시험에 나올 만한 수준의 문제로 이렇게 만든 정리한 책이 바로 데스크피 해식 노트거든요. 
제가 그걸 책으로 만들었기 때문에 스케일 투 워크샵은 sk 투 워크샵 교재를 과정을 또다시 지금 또

참석자 1 
왜냐하면 책으로 4명을 또 교육을 할 수 없으니까 또 대표 하고 있으니까 그 과정을 들어오시면 되겠죠. 
어려운 질문이 질문이에요. 그죠 신입 쪽은 대부분 다 경력자만 뽑거든요. 
db에도 마찬가지고 근데 그 경력은 어디서 쌓느냐는 거죠. 
신입들이 하고 싶어도 사다리를 타야지만이 사다리를 타고 올라갈 수 있는데 그 사다리 자체가 너무 높이 올라가 있기 때문에 사다리에 올라탈 수조차 없는 거예요. 
그럼 그
참석자 1 
심장이 어디서 땄느냐 그런 질문을 항상 하시는데 저도 모르겠습니다. 
열심히 하셔가지고 어떻게 해서든 사다리를 올라타셔야죠 올라타셔야죠 그래서 그 사다리가 높아서 그래서 그 사다리를 타기 위해서 spp를 열심히 따려고 하시는데 spp를 따는 것 자체가 또 너무 어려운 일이고 실상 경험이 없으면

참석자 1 
도저히 풀 수 없는 그런 실적 문제들이 많이 나오니까 어렵습니다. 
그래서 권하는 것은 제가 낸 책들 열심히 보시고 또 이 교육과정을 통해서 책에서 다루는 핵심 원리를 잘 이해하신 상태에서 책을 몇 번도 보시고 고과정도 들어보시고 열심히 반복하는 수밖에 없죠. 
결국 공부는 반복이잖아요. 반복 그죠 반복 학습 반복 학습

참석자 1 
허리를 많이 짜는 수밖에 없는데 많이 짜고 그 허리의 실행 계획들을 많이 분석하고 저는 그거밖에 없다고 생각해요. 
실행 계획을 무수히 많이 분석해 보는 거 말고는 튜닝을 잘하는 경우도 없습니다. 
책을 아무리 많이 본들 실전에서 실행 계획 분석을 많이 해보지 않고서는 실행계획을 정확히 이해할 수가 없거든요. 
제일 많이 물어보는 질문 중에 하나가 실행계획 분석하는 거

참석자 1 
저도 그런 거 모릅니다. 실행 계획도 이 논리적인 표현이에요. 
정확한 실제적인 프로션 내용을 정확히 표현하지 못합니다. 
실행 중이라는 게 트리로 표현하잖아요. 
트리로 근데 여러분들이 짜는 프로그램은 어때요 굉장히 복잡하잖아요. 
그렇죠 그 복잡한 프로그램을 논리적인 트리 모양으로 표현한 것에 불과해요.

참석자 1 
정확한 실행 목표를 정확히 표현하지 못하는 얘기죠 어떻게 모든 프로시저의 어떤 그 구현 내용을 트리 형태로 다 표현할 수 있겠어요. 
가능합니까 여러분들이 프로그램 짜는 프로 게 그렇게 간단해요. 
간단하지 않잖아요. 그렇죠 데이터를 엑셀 사 놓으면 굉장히 복잡하거든요. 
복잡한 부분을 최대한 논리적으로 표현해서 트리 형태로 만든 것에 불과하기 때문에

참석자 1 
많은 분들이 실행 계획 보면 왼쪽에 1 2 3 4 숫자 나온 거 가지고 실행 계획 1 2 3 이렇게 해석하시는데 그거 그렇게 하시면 안 돼요 그것 때문에 망칩니다. 
실행 계획 분석은 제가 나중에 우리 조인할 때 그 얘기를 드릴 건데 그런 식으로 그 실행 계획을 이 앞에 나오는 숫자를 보면서 숫자를 보면서 그 숫자대로 2 3 1 3 이런 식으로 이렇게 해석을 해서 망치는 거예요. 
실행기 해석을 절대 그렇게 실행되지 않거든요.

참석자 1 
그 공식이 유일하게 맞는 건 nlgn밖에 없어요. 
근데 그런 식으로 또 외우시니까 실장님 루틴을 잘못 이해하시고 자꾸 한 장으로 빠지시는 거 이건 제가 이제 나중에 조연할 때 다시 말씀드릴게요

참석자 1 
그래서 다시 말씀드리지만 공식으로 하시면 안 됩니다. 
정확히 이해하시는 데 집중하셔야 되고 또 시간이 많이 갔네요. 
더 질문 없으시면 잠깐 쉬었다가 끝났네요. 
그거 끝났네요. 그죠 끝났고 잠깐 쉬었다가 이제 본격적으로 우리 실습을 좀 해야 될 건데 실행 계획 확인하는 방법 오토 트레이스 확인하는 방법 또 에스크 트리스를 확인하는 방법을

참석자 1 
설명드리고 같이 실습하면서 계속 이어나가도록 하겠습니다. 
잠깐 쉬겠습니다. 10 40분이네요.
