참석자 1 
여기 안심콜 느끼신 분 아까 보셨죠. 
안심콜 해 주시고 와이파이 구정 해주시면 되겠고요 카페에 가입해 주셔야 돼 그냥 카페 말고 교육용 카페거든요. 
제가 시설 스크립트라든지 이런 것들 카페를 통해서 구매할 거니까 카페에 가입해야 되고

참석자 1 
중요한 거 남자 화장실 2580입니다. 
별 누르고 2580
참석자 2 
피트
참석자 1 
저는 기억하셨다가 나중에 비치에 왔을 때 급할 때 쓰셔도 될 것 같습니다. 
첫날이니까 좀 출석을 좀 불러볼까요. 
제가 답을 해 들어가 있는 것 같으니까 고주환 님 오셨습니까

참석자 1 
김관욱 님 예 김덕희 님 김만재기
참석자 2 
김수학님
참석자 1 
김지영 님 김지영 님 아셨어요. 박신재 님

참석자 2 
네
참석자 1 
박진희 형님 서민철 님
참석자 1 
서성준 님
참석자 1 
영우 디스하려는 오라클 엔지니어 하면서 맞죠.

참석자 1 
마찬가지로 엔지니어 일을 하시네요. 휴닝은 처음이신가요 신영근 님 심지연 님

참석자 2 
네
참석자 1 
고윤복님 유영숙님
참석자 2 
네
참석자 1 
이동현 님 이주현 님 이지은 님 네 네 이호경 님 전정민이네 조영민 님

참석자 1 
조준연 님 최정수 님 황 회장님
참석자 1 
한쪽이 안 오신 거네요. 그러면
참석자 1 
이동표 님은 잔금 결제가 아직 안 됐던데 네 맞아요. 
저희가 안내해 그쪽으로 해 주시면 될 것 같은데요. 
카드로 결제 따로 할까요. 네
참석자 1 
원래 저희 회사에 강의장이 있는데 25인 강 의장이에요. 
그러면 거리두기를 전혀 지금 현재 25분 25분 안 계시거든요. 
그래서 30분까지 됐다가 최근에 막 또 갑자기 급한 일 생기고 또 서비스 오픈 일정 잡혔다고 어저께 또 한 분 또 취소하고 그래서 5분이 취소를 하셨고 지금 한 25분이 입가를 하시게 됐어요. 
저희 강의장은 25개밖에 준비가 안 됐는데 지금 거리두기를 해야 되다 보니까

참석자 1 
이렇게 좀 별도로 강연을 대가를 하게 됐어요. 
큰 강의장을 대가하려다 보니까 약간 좀 누추한 곳으로 여러분들 모시게 돼서 죄송한 마음이 듭니다. 
이게 코로나 때문에 강의장 예약이 쉬울 것 같은데 또 의외로 그렇지가 않아요. 
강의장이 다 또 큰 업체들이 또 많이 또 미리 막 1년치를 다 예약하고 막 그래가지고 대형 광장들은 예약이 쉽지 않더라고요 10 15석 이런 데들이 있는데

참석자 1 
30석 40석 이런 데들은 대간이 쉽지가 않더라고요 방금 오신 분 처음이 어떻게 되세요. 
김치 김치형 김이세요. 안 계실 동안 출석을 불렀거든요. 
다 오셨네요.
참석자 3 
여기랑 관련이 있으신 거
참석자 1 
아니에요. 네 큰 강의를 찾다 보니까 이게 하게 되죠. 
주로 이제 저희 사무실이 연극 보호 쪽 쪽에 있다. 
보니까 그쪽에서 했는데 강남 쪽을 원하시는 분들이 많이 있어서 이번에 강남 쪽으로 좀 선택을 했고 강남 쪽에서 찾다 보니까 여기가 조금 큰 강의장이 그나마 있어서 여기서 하게 되었어요.

참석자 1 
그리고 질문은 가급적이면 수업 시간을 좀 해 주셨으면 좋겠어요. 
이제 수업 시간에 이렇게 질문 손득하게 서로니까 쉬는 시간에 해주시는 분이 계시는데 그러면 저는 수업 시간에도 계속 강의하고 쉬는 시간에 또 계속 강의를 해야 되거든요. 
너무 힘들어요. 제가 목이 상상 성격이 앉아요. 
그래서
참석자 1 
강의를 보시면 아시겠 저 혼자 계속 이방교를 하지 않습니까 그러면 하루 8시간 동안 계속 혼자 말을 해야 되고 끝날 때쯤 되면 막 진짜 좋을 것 같아요. 
너무 힘들고 어떨 때는 그래도 이번 과정 토요일마다 하니까 그건 안 돼 어쨌든 평일 가장 저희가 2월에 토요일 가장 예약을 갖고 있잖아요. 
평일 연속해서 4일 5일을
참석자 1 
8시간씩 4일 5일 하고 나면 정말 마지막 날 그때는 진짜 막 진짜 이러다 죽는 거 아닌가 싶은 막 위기감이 들 정도로 막 목이 너무 아프고 목도 목이지만 스트레스가 막 올라가요 말을 목은 아픈데 말을 멈출 수가 없잖아요. 
멈추면 강의가 중단이 되니까 정말 힘들어요. 
일단
참석자 1 
이는 수업 중간에 질문해 주시면 좋겠고 제가 힘든 것도 힘든 거지만 질문하신 내용들이 다 하나의 좋은 내용들이라서 다른 분들도 아셔야 되는 내용들이 많거든요. 
그러니까 제가 아까도 질문 하나 받았는데 수업 시간에 말씀드리겠습니다. 
했는데 그중 내 하나가 뭐냐면 이제 통계 정보라는 걸 이제 모르고 지내셨는데

참석자 1 
통계 정보를 듣고 나니까 저런 게 있었구나 통계 정보가 중요하구나 나는 여태까지 통계 정보 수집 안 하고 운영을 했는데 어떻게 됐던 건가 이제 이런 궁금증이 드셨을 수 있을 것 같은데 기본적인 통계 정수 좀 안 하더라도 오라클의 경우 오라클을 설치하게 되면 기본적으로 잡이 스케줄러가 하나 만들어져요. 
잡 스케줄러가 만들어져서 자동으로 수신되도록 세팅이 됩니다. 
어떻게 돼 있냐면 매일 밤 10시에서 아침 6시까지 8시간 동안

참석자 1 
윈도우가 오픈이 돼요. 10시부터 6시까지 8시간 동안 돌도록 맥시멈 8시간인 거야 6시간이 지나도록 등록 수입을 다 못 맞췄으면 자동으로 멈춰버립니다. 
왜냐하면 이제 곧 업무 시작될 시간이기 때문에 그 돌면 안 되겠죠. 
그래서 기본적으로 세팅이 저렇게 돼 있고 토요일에는 0시부터 이틀 동안

참석자 1 
빈도가 오픈이 돼요. 그렇기 때문에 토요일날 또 시간 제한 없이 계속 돌게 된다는 거죠. 
여러분들이 아마 선배 정도 수집 안 하셨으면 저 기본 모드로 작동을 하고 있는 거예요. 
근데 위험한 거죠. 아까 말씀드린 것처럼 보시다시피 10시부터 6시까지 도는데 그 시간에 배치가 돌고 있거든요. 
배치 꼬라는 그러면 배치 꼬랑이 돌면서 얘가 같이 막물려서 돌면서 어떤 애들은

참석자 1 
대치로 데이터를 입력을 하고 통계 정보가 수출이 되고 어떤 통계 정보 수입하고 나서 등록금 천만 번 들어가고 통계 정보가 실시간 정확한 정보를 반영하지 못하게 되는 문제가 생길 수 있다는 얘기예요. 
그래서 여러분들이 저는 어쩔 수 없이 기본 모드로 운영하시는 분들은 저걸 잘 보유를 하셔가지고 세팅을 바꿔주셔야 됩니다. 
배치 프로그램 시간과 맞물리지 않도록 잘 세팅을 해주셔야 돼요

참석자 1 
최근에는 실시간으로 수집하는 기능도 제공이 돼요. 
워크를 해도 뭐라크해도 데이터가 100만 건이 딱 수집이 되면 자동으로 수집이 되도록 근데 대부분 db들이 그걸 꺼놔요 되게 위험한 기능일 수 있거든요. 
중간에 갑자기 배치로 100만 평이 딱 들어갔는데 중간에 뚜껑 정가가 돌아버렸어요. 
그래서 실책이 바뀔 수가 있고 그로 인해서 생기는 장애에 대해서는

참석자 1 
책임질 수 없기 때문에 대부분 그런 기능들은 로라크의 경우는 꺼놓습니다.

참석자 1 
옵티마이저가 무엇인지에 대해서 이제 간단히 좀 살펴봤고요 이제 sql 처리 과정을 한번 자세히 좀 알아보도록 하겠습니다.

참석자 1 
스킬은 크게 4가지 단계를 거쳐서 시행이 됩니다. 
sk 파싱 단계 최적화 단계 로소스 생성 단계 실행 단계 이렇게 4가지 가정을 합치고 각각마다 처리하는 엔진이 다르죠 파싱은 파서가 처리를 하고 최적화는 옵티마이저가 처리를 하고

참석자 1 
로소 생성은 로소스 제너레이터가 처리합니다. 
마지막으로 에스큐 실행하는 것은 에스큘 엔진이 실행을 하게 되는 것이죠. 
제일 먼저 에스큐 파스가 사용자가 던진 레시피를 받아서 처리를 하게 되는데 레시피 파소가 하는 역할은 크게 두 가지 신텍스 체크와 시멘트 체크입니다. 
사용자가 작성한 스펙의 문법적 오류는 없는지 체크하는 거죠.

참석자 1 
사용할 수 없는 키워드를 사용하지는 않았는지 또 순서가 올바른지 이런 것들을 체크를 하는 것이고 그다음에 의미상 오류가 없는지를 체크를 해요. 
존 존재하지 않는 또는 권한 없는 원제트 여러분들도 아까 같은 경우는 브이터 레스트 제가 해보니까 다 알려놨었죠. 
그죠 그죠 제가 중간에 쉬는 시간에 지금 권한을 드렸거든요. 
지금 해보시면 될 겁니다.
참석자 1 
그러니까 문법 적은 오류가 없었지만 의미상 오류가 있었던 거예요. 
권한이 없는 뷰를 조회하려고 했던 거죠. 
그래서 그런 것들을 체크한 것이 시마틱 체크입니다. 
또는 존재하지 않는 테이블 또는 존재하지 않은 칼럼을 참조하는 경우도 있을 수 있고 그런 것도 체크하는 것이고요

참석자 1 
그다음에 이제 옵티마이저가 이제 그다음에 이제 그걸 받아서 그리고 이제 에스클 파스가 팔싱트리를 만들어요. 
여러분들 sql 문장은 테스트지 않습니까 테스트를 그대로 놓고 우리가 그걸 처리할 수는 없잖아요. 
그죠 그러니까 뭔가 쉽게 연산을 하기 위해서 개를 가지고 이제 의미 있게 팔심 트리를 만드는 거죠. 
팔심 트리를 만들어서 얘를 막 잘라서 토코나이제이션 하고 나서 셀렉트

참석자 1 
풀어고요 외어전을 안 해보면 조건 자안에 또 다른 서브가 있을 수 있지 않습니까 그러고 그를 또다시 그 안에서 또 사시 에서 또 이렇게 틀 걸 이렇게 만들어서 하여튼 처리하기 좋은 자료 구조를 만들어낸다는 얘기예요. 
파스를 만들고 만든 상태에서 체크 시멘트 체크하고 그것을 이제 옵티마즈에게 던져주면

참석자 1 
루티마이저가 최적화를 하게 됩니다. 최적화 과정에서 관여하는 엔진이 크게 세 가지가 있는데 커리 트랜스포머 말 그대로 커리를 변환하는 아까도 넓게 말씀드린 것처럼 사용자가 뷰를 사용했는데 뷰를 풀어내기도 하고 서브 커리를 풀어내기도 하고 사용자가 작성한 sk를 좀 더 최적화하기 좋은 형태로 변환을 시도한다라는 얘기입니다. 
그다음에 플랜 제너레이터 아까 말씀드린 것처럼 플랜드를

참석자 1 
다양한 플랜들을 그 에스키를 실행하기 위해서 가는 플랜들을 생성하는 겁니다. 
생성하고 나서 각각에 대해서 비용을 평가를 하죠. 
베스트 메이터 이런 과정 이런 엔진들이 서로 상호작용하면서 실행력을 만들어내게 되는 것이죠. 
아까 말씀드린 것처럼 옵티마이저는 자동차 내비게이션과 비슷한 기능을 갖고 있다라고 말씀드렸고 아까 다 말씀드린 내용

참석자 1 
그렇게 해서 옵티마이저가 만들어낸 어떤 실행 경로는 논리적인 경로예요. 
논리적인 경로 실제 실행할 수 있는 형태는 아니고 어떤 방식으로 데이터를 처리하겠다라고 하는 논리적인 결과물을 만들어내는 것이고 그것을 실제적으로 실행할 수 있는 마지막에 이 유치한 이 엑스피터 실행 엔진 실행할 수 있는 형태로 코메팅하는 과정이 로소스 생성 단계예요.

참석자 2 
응
참석자 1 
여기 보시면 요게 이게 실행 계획이거든요. 
실행 계획이 실행 계획 통해서 내부적으로 어떻게 처리하려고 하는구나 볼 수 있는데 이것은 실제 실행할 수 있는 형태는 아니죠. 
논리적인 형태죠 이것을 실제 실행 가능한 형태로 프로스를 만들어내는 거예요. 
여기 보시면
참석자 1 
데트 쪽에 인덱스를 이용해서 데트 테이블 에패스하고 반대쪽에 있는 emp 테이블을 nl 방식으로 네스트드 룩 방식으로 조용하겠다. 
이런 것으로 표현하고 있는 거지 않습니까 그래서 이 루틴이 의미하는 바대로 제가 한번 프로시를 만들어본 겁니다. 
피엘 에스케얼처럼 피에스케 형태로 프로시를 제가 만들어본 거예요.

참석자 1 
말하자면 이런 식의 프로스를 만들어낸다는 얘기죠 내부적으로 나중에 보시겠습니다만 이 실행 계획이 요런 루틴의 의미를 갖고 있어요. 
나중에 여러분들 애들 중에 배우고 나서 한번 한번 보시면 이해가 되실 겁니다. 
아직 우리가 죄는 안 들었으니까 이해되십니까 어떤 얘기를 하고 있는 건지 이런 식으로 프로시를 만들어서 실행을 하게 되는 거예요. 
질문 있으신 분이니까
참석자 2 
기초적인 질문인 것 같아요.
참석자 1 
예 실행 계획
참석자 1 
실행기 바꾸면 왜 무시게 되느냐 아 인덱스가 항상 빠를까요. 
어떤 조회 조건을 처리함에 있어서 인덱스를 쓰는 게 유리할 수도 있고

참석자 1 
풀스케이 유리할 수도 있거든요. 대표적인 게 성별이죠. 
성별로 좋은 고객 대비 천만 명인데 성별 이콜 남자로 찾았어요. 
근데 남자가 500만 여자가 500만 원이거든요. 
이때 인덱스 쓰면 될까요. 안 될까요.

참석자 3 
집이 그에 따라서
참석자 1 
인덱스는 많은 데이터 중에 소량의 데이터를 빨리 찾기 위한 도구예요. 
인덱스 우리가 나중에 배울 텐데 인덱스를 설명할 때 제일 쉬운 게 세개 있는 세균이지 않습니까 책 뒤에 세균을 이용을 해요. 
거기서 특정 단어를 찾아서 우리가 찾을 때는 이기스가 도움이 되겠지만 굉장히 많은 내용의 용어들을 검색할 때 세금을 이용하게 되면 세균 찾고 페이지 열고

참석자 1 
세균 찾고 페이지하고 세인 찾고 페이지하고 이거를 예를 들면 전체 세균 종류가 1만 개가 있는데 만 개 요거가 있는데 그중에 5천 개의 용어를 만약에 세균성 찾는다면 생각해 보세요. 
승인 착고 페이지 열고 승인 차고 이거는 5천 번을 반복해요. 
차라리 그럴 거면 이 패지보다 넘기는 게 더 빠르지 않을까요. 
그죠 그니까 인덱스가 항상 빠른 게 아니라는 얘기예요. 
인덱스는
참석자 1 
많은 데이터 중에 소량의 데이터를 빨리 찾기 위한 도구일 뿐이란 얘기죠 근데 방금 설명드린 것처럼 고객 테이블이 천만 명인데 그중에 500만 명에 해당하는 남자를 찾는데 인덱스를 썼어요. 
그러면 풀지캔보다 훨씬 더 느리다는 얘기예요. 
훨씬 더 느리다 실행력이 바뀐다는 얘기는 데이터를 엑세스 하면 방법이 바뀐다는 얘기고 옵티마이저는 그중에서 여러 가지 방법 중에 가장 좋은 하나를 선택하려고 하는 건데

참석자 1 
그게 최선일 수도 있고 최선이 아닐 수도 있는 거죠. 
시행 중에 바뀐다는 얘기는 서울에서 부산까지 가는데 경부 고속도로 갈 수도 있고 중부 고속도로 갈 수도 있고 저 옆에 지방 도로로 막 돌아갈 수도 있는 거예요. 
다음 질문이 뭐였죠.
참석자 3 
그러니까 여기에 게속
참석자 1 
차이 때문인 건지 속도 차이 때문인 거죠. 
결과적으로 실행 계획이 바뀌어서 아예 처리가 실패하는 경우가 생 실패하는 문제는 실패하는 문제는 시마텍 체크에 해당하는 신텍스나 시마틱 체크에 해당하는 거고요 여기까지 통과했어요. 
통과가 됐고 통 같은 더 쉬운 게 만들어졌을 텐데 이 팀 마이에서 쉬운 게 만들어졌을 거 아닙니까 여러 가지 경험 중에 하나를 선택했을 텐데

참석자 1 
각각마다 속도는 다 다른 거죠. 10가지 경우의 수가 있는데 각각마다 속도는 달라요 그중에 가장 빠른 걸 선택하는 것인데 그게 체적이 아닐 수도 있다는 얘기고 그것이 바뀌었을 때 속도가 달라지니까

참석자 1 
이해가 안 되신 것 같은데 속도 때문에 속도 때문이죠. 
속도 때문에 속도 때문에 당연할 수 또 다른 질문

참석자 1 
소스 보시면 제가 원래 교육할 때 아까 이제 원래 이렇게 좀 설명을 좀 하고 한다고 그랬는데 오늘 생략을 했기 때문에 아키텍처에 대한 간단한 설명을 좀 생략을 하고 왔습니다. 
여기서 좀 설명을 드리면 워낙 당연하게도 모든 데이터를 디스크에서 입을 수는 없어요. 
캐시를 이용을 합니다. 캐시를 메모리
참석자 1 
그죠 당연히 멤버 이용하는데
참석자 2 
음
참석자 1 
모든 데이터 베이스가 공통적으로 갖고 있는 메모리 구조가 있는데 이게 이제 오라클의 공유 메모리에요. 
공유 메모리 공유 메모리인데 보면 보시면 왼쪽에 보면 비비 버퍼켓이라고 있죠 이게 뭐냐면 데이터 베이스입니다. 
데이터 말 그대로 데이터를 캐싱 하는 영역이에요. 
데이터 블라 인덱스 블라
참석자 1 
이것들은 데이터를 캐싱 하는 그런 메모리 영역입니다. 
오른쪽에 보시면 셰어드 풀이 있고 쉐어드 풀 안에 라이벌 캐시라고 있죠 라이버 캐시 이거는 에스케를 캐싱하는 영역이에요. 
에스케 캐싱하는 영역 쉽게 얘기하면 코드 캐시입니다. 
코드 캐시 비비 범퍼 캐시는 데이터 캐시

참석자 1 
라이브 캐시는 코드 캐시 이렇게 생각하면 쉬워요. 
예
참석자 3 
저 파이브러리 캐시에 저렇게 올라와 있는 에스트

참석자 1 
예
참석자 3 
저 프로시저 형태로 변환되는 게 올라
참석자 1 
그렇죠 sk 텍스트 자체도 있고 실행 계획도 있고 실행 계획에 실질적인 프로시죠 프로시도 있죠. 
지금
참석자 3 
하신 거 중에 하신 티 마이데이션 노우 소프트 제너레이팅

참석자 1 
그렇죠 모든 처리 과정을 다 마친 완성된 최종 결과물이 담겨 있는 거예요. 
그러니까 skl이 있고 로소스도 있는 거죠. 
로소스 둘 다 예예 거의 다 이렇게 예 실행 계획도 있고요 실행 계획 그 모든 것들을 다 담고 있어요. 
이거 우리가 이제 에스킬 커서라고 얘기를 하는데 네 에스케 커서 안에 그런 모든 장문들이 다 담겨 있어요. 
에스케 문장
참석자 1 
그다음에 실행 계획 그다음에 공적인 프로시션까지도 다 담겨 있는 거 이렇게 에스케라고 단테 피돼 있는데 저기 에어는 에스케 커서입니다. 
스케 커서 안에 그 정보들이 다 다
참석자 2 
네
참석자 3 
그러면은 파트 파싱 되었을 때는 별도로 파트 파싱 과정 안 가 간 것

참석자 3 
가는 것도 이전에 실행했던 포트로 작용

참석자 1 
예
참석자 3 
그럴 때 재사용하는 거예요.
참석자 1 
이거 이거 쓰는 거죠. 지금 그걸 설명드리려고 하는 거예요. 
지금 니네 예스 들어준다고 미리 지금 앞서 나시는데 지금 그걸 설명드리려고 하는 거예요. 
그래서 sga는 메모리는 크게 두 가지 영역이 있다.

참석자 1 
데이터를 캐싱하는 데이터 캐시로서의 db 버퍼 캐시 그다음에 에스케어를 캐싱하는 코드 캐시 이거는 이제 이름이 다 다른데 오라클은 라이블 캣이라고 얘기하고 ms시컬 서버는 프로시저 캣이라고 불러요 ms 시컬 서버가 더 의미가 직관적이죠. 
그렇죠 프로시죠 시 프로 제가 아까부터 계속 말씀드리기를 프로시라고 했지 않습니까 sk는 집합적인 선언적인 언어지만

참석자 1 
결국은 실행하려고 하면 프레시가 만들어진다고 했고 그것을 그 프레시를 저장하는 캐시가 이 라이브 캐시거든 뭐라고 그래요 이 시컷 속으로 말하는 프레시 캐시 이렇게 크게 두 개의 컨퍼넌트가 있다라는 사실이죠. 
그래서 여기도 설명돼 있는 것처럼 sk 최적화 과정을 거친 skl과 실행 계획들이 여기에 캐싱이 돼 있다라는 사실이에요.

참석자 1 
왜냐하면 지금까지 설명드린 이 과정이 굉장히 무거운 과정이거든요. 
sql을 패싱을 해서 최적화하고 로소스를 생성하는 이 과정 자체가 굉장히 무거운 작업이에요. 
그 무거운 작업을 계속 반복할 수는 없지 않습니까 그죠 한번 해본 것을 어딘가에 캐싱을 해보고 소프트웨어는 다 결국 다 그런 것 같아요. 
그렇죠 그 부분 결국 캐시를 활용하는 메카니즘인데 반복적인 그런 무거운 작업들을 반복할 수 없기 때문에

참석자 1 
한 번 팔 거친 것들을 이제 라비오 캐시에다 캐싱을 해놓고 그것을 반복 재사용할 수 있게끔 하는 것이죠. 
그래서 우리가 설명드린 내용들을 다시 한 번 그림을 그려보면 파신 과정 최적화 과정 로소스 생성 과정 실행 단계를 거치는데 매번 최저가를 로 소스를 매번 고칠 수 없기 때문에 중간에 캐시를 먼저 확인을 해요. 
한 번 만든 놈을 캐시에 올려놓기 때문에 두 번째부터는

참석자 1 
캐시를 먼저 확인해서 캐시에 있으면은 그것을 바로 실행을 하고 없으면 모든 과정을 다 거쳐 실행하는 거예요. 
그래서 모든 과정을 다 거치는 즉 캐시에서 찾지 못해서 모든 과정을 다 거쳐서 실행하는 것을 하드 파싱이라고 얘기를 하고 pc에서 찾아서 바로 실행하는 것을 소프트 파싱이라고 얘기를 합니다. 
보시다시피 파싱은 무조건 해요. 그죠
참석자 1 
파싱을 하기 때문에 실행을 하려고 하면 어쨌든 소프트 파싱 하드 파싱 있는 건 둘 중에 하나 해야 되는 거예요. 
근데 모든 과정을 다 거치는 것을 하트 파싱 pc에서 찾은 것을 소트 파시라고 얘기를 하는 거죠. 
요 그림이 이해가 되실까요.
참석자 1 
캐시는 말 그대로 핏이기 때문에 모든 시기 항상 여기 있을 수는 없거든요. 
올라갔다가도 새로운 놈이 올라가려고 하면 기존의 값을 하나를 밀어내야 돼요 그렇죠 밀어내야 새로운 게 올라갈 수 있기 때문에 모든 게 다 항상 이 수는 없거든요. 
그렇기 때문에 항상 있을 수도 있고 없을 수도 있다는 얘기죠 그렇게 찾아보고 실행하는 그런 메카니즘을 갖게 되는 거죠.

참석자 1 
네네
참석자 3 
표시에 존재하게 되요.
참석자 1 
그러면은
참석자 3 
오 그래도 해가지고 프로 시적으로 생성이 되어 있는 것을 체크하는 거예요. 
여기서 케시에 존재하지 않으면 최적화랑 로스 형성을 다시 해서 실행을 하는 걸로 이렇게

참석자 1 
네네
참석자 3 
그래서 최종적으로는 로스를 생성하는 게 이제 먼저

참석자 1 
예예 그래서
참석자 3 
pc에 존재하는 걸 체크할 때 로소스가 있는지 그로소스를

참석자 3 
그냥 먹고 싫어 할 때니까 네 그냥 넘어가요

참석자 1 
여기는 spl 프로텍스도 고 실행기 있고 로스 수도 있다고 그랬잖아요. 
그렇게 다 있다고 하는 찾을 때 뭘로 찾냐 그걸 넣으시는 거예요.

참석자 3 
웍스키시에 존재한다고 했었을 때 네
참석자 1 
여기 이렇게 내가 찾고자 하는 sk 문장이 거기에 있는지 네 그 셀렉트 아까 프로 ep라는 베스크를 던졌어요. 
그 문장이 메모에 있는지 찾는 거죠.
참석자 2 
참 냄새
참석자 1 
이걸 차려졌으면 거기에는 실행 프로숍도 같이 있겠죠.

참석자 3 
이렇게 한 통으로 엮여서 이렇게
참석자 1 
이게 하나의 데이터 자료 구조예요. 그 안에 skl로 표현돼 있지만 아까도 얘기했다시피 이게 skl이라고 표현돼 있지만 이거는 사실상 skl 커서를 의미하는 것이고 그 커서에는 sk가 실행 계획과 프로시저와 또 그것을 실행하기 위해서 필요한 각종 정보들 발디면 수요 종류 또 그것에 대한 상태 값을 관리할 수 있는 기타 등등의 많은 정보들을 여기에 다 담고 있어요.

참석자 3 
한 통인지도 모르고 개별로 현재에 있다라고 한다

참석자 1 
좀만 뒤로 가시면 여기 여기 보시면 제가 지금 커서 필드 거기에 저장된 점보들이 쭉 나왔잖아요. 
거기에 이거 뒤에 있다. 보실게요 뒤에 또 나옵니다.

참석자 1 
그만큼 sk의 최적 가정은 무거운 과정이다라는 것이고 그렇기 때문에 라면 캐시가 필요한 것이죠. 
예를 들어서 우리가 내비션으로 다시 얘기를 해보면 서울에서 부산을 가려고 해요. 
그러면 그 중간에 얼마나 많은 경우가 있겠습니까 그죠 경부고속도로 이용하는 방법 중부고속도로를 이용하는 방법 또 기다렸던 방법 또

참석자 1 
경부고속도로 타고 부산 근처에 가서 또 있는 수많은 지방 도로들 또 부산 안으로 들어가서 또 수많은 시내 도로들 얼마나 많은 경우가 있겠습니까 여러분들이 내비게이션으로 딱 서울에서 부산까지 누르는 순간에 한 예를 들면 한 5초에서 10초만 흘러가죠. 
그렇죠 그 과정 동안에 그 내비게이션이 무엇을 하고 있을지 한번 생각을 한번 해보세요. 
선생님 계시죠 그렇죠 그 모든 경기수를 다 뽑아내서

참석자 1 
그중에 가장 쉬는 게 시간이 단축될 수 있는 하나를 찾아내는 거예요. 
실제로 옵티마이저가 그런 일을 해낸다는 얘기죠 예를 들어서 5개의 테이블을 증인한다고 하면 좋인 순서만 고려하더라도 오펙토리알 대시까지 경우가 존재해요. 
a b cb 2 5 개 테이블이 있다고 하면 존 수정을 고려하더라도 1시까지 경우의 순서가 존재하고

참석자 1 
조인 방식에도 nl 주인이 있죠. 소트 머니 주인이 있죠. 
해스존이 있죠. 조인 방식도 다양해요. 
또 인덱스를 이용할 수도 있고 테이블 프스캔 할 수도 있고 또 인덱스 스캔 마실 때도 레인 스캔 있죠 이니크 스캔 있죠 풀 스캔 있죠 패스트 풀 스캔 있죠 스캔만이 다양하다는 얘기예요. 
인덱스도 하나만 있으니까 일반 인덱스 2번 인데스 3번 인덱스

참석자 1 
수십만 가지 경우가 존재할 거예요. 만약에 저 경우에는 그럼 어떻게 하냐면 그 많은 경우들을 다 뽑아내서 각각 도로 비용을 다 평가를 하고 그리고 나서 그 중에 하나 체적을 뽑아내는 거니까 얼마나 하다하겠냐는 거죠. 
그 과정 자체가 여러분들이 워낙 컴퓨터가 서버가 빠르니까 순간적으로 처리되니까 그냥 별거 아닌 것 처럼 생각하지만

참석자 1 
매스킬 하나를 최적화하는 과정은 생각보다 굉장히 무거운 작업이에요. 
그래서 시간을 단축하기 위한 여러 가지 알고리즘을 내부에서 사용을 해요. 
읽어보시고 그래서 우리가 데이터베이스는 아이오 인텐시브 잡이라고 얘기합니다. 
아이오라는 얘기죠 성능은 아이유가 좌우한다고 얘기하지만 cpu를 많이 사용하는 cpu 인티시 잡이 몇 가지가 있는데 그중에 하나가 바로 하드 파싱입니다. 
하드 파싱 sq 파싱한 어전 가치가 그만큼 무겁다라는 얘기죠

참석자 1 
그래서 여러분들이 sql 문을 도스나 위닉스 프럼프트 상에서 실행하는 단순한 커뮤트로 생각하시면 안 돼요. 
dir 델 이런 거 있지 않습니까 체인지 디렉토리 이런 것들은 완전 커프라이된 상태로 나온 어떤 그런 명령어들이지 않습니까 근데 sk는 그렇지가 않아요. 
실시간으로 얘를 최적화를 해서 컴파를 해서 만들어내는 실시간으로 프로시를 만드는 개념이기 때문에

참석자 1 
굉장히 무거운 작업이다라는 얘기죠 그래서 가급적이면 하드 파싱이 최소화될 수 있도록 여러분들이 노력들을 많이 해주셔야 돼요 제가 하드 파싱이 얼마나 무거운지를 보여드리기 위해서 실수를 간단한 실수로 하나 보여드릴게요

참석자 1 
티움부터 팀 타이브까지 5개 테이블 만들었어요. 
5개 케이 만들었고 데이터는 현재 없는 빅 깡통입니다. 
빅 깡통이니까 아이온은 발생하지 않겠죠. 
실행하는 과정에서 그죠 아이온은 발생하지 않는 상태로 테스트를 해볼 건데

참석자 1 
5만 번을 실행을 합니다. 5만 번 그죠 1부터 5만 번까지 루프를 도는 거고 돌면서 이 t1부터 t 파일까지 비 깡통이라고 했지 않습니까 데이터가 하나도 없기 때문에 아예도 발생하지 않는 것이고 요 아이라는 변수를 1부터 5만까지 계속 바꾸도록 했어요. 
리터럴하게 그렇죠 그래서 말를 들면 여기 여기서 첫 번째는 여기가 1이 들어가고 두 번째 2가 들어가고 3 스킬 문장이

참석자 1 
여기서부터 여기까지가 다 이제표 문장이지 않습니까 그러니까 여기 sk 문장 자체가 계속 1 2 3 4에서 1부터 5만까지 계속 바뀌는 상황이에요. 
그러면 하드 파싱 5만 번 발생하겠죠. 
그죠 오마번 발생할 텐데 지금 보시면 오더 드라이트 썼습니다. 
오더 오더 드라이트는
참석자 1 
프롬절에 나열된 순서대로 실행해라 그런 뜻이에요. 
아까 얘기한 것처럼 히트는 명령어입니다. 
사제가 지정한 대로 실행이 되는 거예요. 
즉 존 순서는 고려하지 말라는 얘기예요. 
내가 실행하는 라는 대로 해라 그죠 그리고 아까 얘기한 것처럼 120가지 경우의 수가 줄어들어요. 
그죠 한 가지 경우에 수로 딱 세팅이 돼버리는 겁니다. 
맞죠. 그죠
참석자 1 
그 상태에서 시행해 볼 거고 두 번째는 오더 드라이크를 빼버릴 거예요. 
빼면 어떻게 해요. 티마이저가 120까지 경우수를 마저 고려하겠죠. 
그렇죠 그랬을 때 시간 차가 얼마큼 나는지를 비교해 보려고 하는 거예요. 
해볼게요 오도들은 힌트를 주고 시키겠습니다. 
5만 번의 파싱을 지금 하고 있는 거예요.

참석자 1 
이상하게 서브가 좀 무거운 것 같아요. 
사용자가 많아서 그런지 그럴 수 있을 것 같습니다. 
이건 사용자가 카사도 많다. 보니까 기본적으로 접속을 많이 하셔가지고 접속을 많이 하면 많이 만큼 메모를 많이 사용하거든요. 
좀 횟수를 좀 줄여야 될 것 같아요.
참석자 1 
제가 실습을 제 로컬에서 좀 보여드릴게요

참석자 1 
로컬 끼우는 동안 제가 하나 그다음 페이지를 좀 설명드리겠습니다. 
여러분들이 클레이스 걷는 법은 제가 이따가 오후에 이제 설명드릴 텐데 이게 레스켈 트레스를 걸면 나오는 화면이에요. 
레스켈 트레스를 걸면 이렇게 콜 정보가 나옵니다. 
콜 정보 sk 실행할 때 80 단계 실행 단계 패치 단계를 거쳐요 그래서 각각별로

참석자 1 
몇 번 실행됐고 cpu를 얼마큼 사용했고 아이온은 얼마큼 발생지 이런 정보들을 트리스톤에서 확인할 수가 있거든요. 
여기 보시면 어떻게 돼 있어요. 팔싱 단계에 그 5천 번 실행을 했죠. 
그죠 그죠 5천 번 실행한 겁니다. 5천 번 실행하기 위해서 팔싱도 5천 번이에요. 
맞죠. 아까 얘기한 것처럼 실행하려고 하면 일단 파싱을 해야 돼요 근데 그 파싱이 소프트 파싱이냐 하드 파싱이냐 차이가 있는 거죠. 
그죠
참석자 1 
그러면 하드 파스 몇 번 있을까요. 지금 그 정보 어디 나왔냐면 밑에 나와요 한번 해석해 보세요. 
뭐라고 돼 있습니까 파싱하는 동안 라이브 키시에서 찾지 못했다는 거죠. 
그죠 라이브 키시에서 5천 번 실행하는 동안 5천 번에 파싱을 했는데 그중에 첫 번째 한 번 첫 번째겠죠. 
첫 번째는 못 찾은 거예요.
참석자 1 
그러니까 하드 파싱을 한 번 하는 거죠. 
그죠 한 번에 하드 파싱을 했고 그럼 소프트 파싱 몇 번입니까 8999번이에요. 
그죠 5천 번 파싱을 했는데 그중에 한 번은 하드 파싱이니까 나머지 4999번은 프로트 파싱이 되는 거죠. 
이해되셨죠. 그런 것들 우리가 여러분들 클래스를 통해서도 저런 것들을 읽어낼 줄 아셔야 됩니다. 
특히 이제
참석자 1 
에스큐피 시험 보려고 입구 하신 분들 계시죠 그죠 에스큐피 시험 보신 분들은 그런 트레스 정보들을 정확히 읽어낼 줄 아셔야 돼요 종종 나옵니다 시험

참석자 1 
제가 로컬에서 다시 한번 보여드릴게요 시테이블 5개 만들었고요

참석자 1 
시간을 새 타이밍 시간을 보여주기 위해서 에스큐 플레스트에서는 시간을 보여줄 때 새 타이밍 오늘 해요. 
그러면 시간을 같이 보여줍니다 시간을 활성화시켰고 말씀드린 것처럼 오더들의 힌트를 주고 실행을 해볼게요

참석자 1 
추적을 쉬어야 될 것 같아요. 공말이 너무 많은 것 같아요. 
이만 번만 해볼까요.
참석자 1 
저기 아까 이미 한 번 시도했기 때문에 얘들이 라이브 키스에 올라가 있을 거 아닙니까 그죠 얘들을 비우는 명령과 요거예요.

참석자 1 
셰어도풀을 비우는 거죠. 라이브 캐시가 쉐어드프가 있기 때문에 셰어도프를 비우게 되면 같이 비어지겠죠. 
여러분한테 권한이 없을 겁니다. 권한은 이 비비에 대해 하는 권한이니까 혹시 권한이 있더라도 여러분들이 실제 운영하고 있는 이거 난리 납니다.

참석자 1 
꽤 오래 걸리네 아무튼 35초 걸렸습니다. 
35초 오더들은 이 좋은데도 불구하고 그런데 오더도 안 주면 더 오래 걸리겠죠. 
너무 많이 걸린 것 같아서 좀 줄여볼게요 시간이 너무 많이 걸려서

참석자 1 
물론 오도는 빨라야 되는데 오더도 저도 지금 만 분만 돌려볼게요

참석자 1 
여기 보시면 지금 돌고 있는 동안 얘를 조회해 보니까 레치 쉐어드풀 레치라고 나와요 그죠 이게 하드 파싱 할 때 나타난 배리 대요 그니까 혹시 문제가 있지 않나 싶어 보니까 정상적으로 돌고 있었어요. 
섀도 플레이가 그래서 이것이 하드 파싱 할 때 나타나는 대기 벤트입니다. 
그래서 보시는 것처럼 17초 걸렸어요. 
17초 17초 걸렸는데 이번에는 똑같은 프로그램인데 오더 드라 힌트를 뺐어요.

참석자 1 
똑같은 레시피 맞죠. 그렇죠 더티도 없고 모두들가 입고 부채니다. 
근데 오더드가 없으면 얘가 이제 병의 수를 더 고려해야 되겠죠. 
그랬을 때 얼마나 걸리는지 아까 10초씩 걸리던 것이 오더 히트가 이호에 따라서 시간이 얼마나 늘어나는지

참석자 1 
두 번째 할 때는 쉐어스을 플러시를 할 필요 없어요. 
에이스 문장 자체가 다르잖아요. 우리 오더드가 있고 오더드가 없으니까 에스피 자체가 서로 다르니까 비울 때가 없겠죠. 
새로 올라가는
참석자 2 
자
참석자 1 
시간이 한 10일 정도 늘어났죠 그죠
참석자 1 
그 늘어난 이유가 바로 더 많은 경우의 수를 고려했기 때문에 그러는 거예요. 
더 많은 경우에 수가 그래서 여러분들이 돌아가셔서 좋은 거 배웠다. 
스켈에다가 오더트를 넣게 되면 더 빨라지겠죠. 
그렇죠 절대 그러시면 안 됩니다. 그러면 확실 시간은 줄어들어요. 
다만 0.0 몇 초라도 근데 눈에 지금 만 번 실행할 때 이분 시간이지 않습니까 만 번 실행할 때

참석자 1 
미미한 시간이에요. 미미한 시간인데 그거 미미한 시간 줄이자고 이거 넣는 순간 패싱 타임은 아무래도 0.001초 줄어들겠지만 반대로 이 실행 정도가 막 꼬여가지고 그죠 더 좋은 실행 정도 놔두고 무조건 이 순서대로 실행하면서 아이유가 더 많이 늘어나는 그죠 실행 정도가 꼬여서 실행하는 과정에서 아이어를 더 많이 일으켜서 0.1초 0.01초 줄이자고

참석자 1 
10초가 늘어나는 그런 일이 생길 수 있습니다. 
절대 함부로 주시면 안 됩니다. 지금 그냥 원리적으로 옵티마이저가 조인서를 고려하기 때문에 생기는 시간 차를 보여드리려고 그러는 거예요. 
그만큼 우키마저 그 짧은 순간에 많은 일들을 하고 있더라 그것을 제가 이제 실습적으로 보여드리는 것뿐이니까 보도 일 난발하시면 안 됩니다.

참석자 1 
경우에 따라서는 오더 데이터를 쓰는 게 트이 되는 경도 있었어요. 
제가 예전에 감정원이라는 데를 갔었는데 sk 문장이 문이 들더라고요 이게 하나의 sk이에요. 
이게 실행 계획이지 않습니까 실행을 보더라도 무수히 많은 테이블 중에 하지 않습니까 그죠 그래서 이 개발자들의 목적이 뭐냐면 첫 번째 실행할 때는 5초 8초 걸린대요 보통 5초에서 8초 써있었죠. 
그죠
참석자 1 
5초에서 8초 걸린대요. 근데 두 번째부터는 빠르다는 얘기예요. 
왜냐하면 첫 번째 실행할 때는 저 많은 무수히 많은 테이블 주행하는 sk 문장을 탈싱하면서 실제로 8초가 흘러간 거예요. 
근데 한 번 올라가면 그때부터는 pc에서 실행 버스 찾아서 바로 실행하니까 그때부터는 바로바로 결과가 나오더라는 얘기죠 그래서 제가 그때 sk 분석해 보니까 요 프론자의 낡은 순서대로 조인하는 것이 최적이더라고요 그래서

참석자 1 
힌트를 이렇게 딱 줬어요. 오더다 힌트를 그러니까 옵티마죠가 더 이상 주유수를 고려하지 않죠. 
그때부터는 엔터 치면 항상 그냥 무조건 빨리 나오는 거예요. 
항상 첫 번째도 빨리 하고 두 번째도 빨리 나오고 만약에 이 프로듀얼 나된 순서가 최적이 아니었다고 하면 오더드 대신 리딩이라는 이 쓸 수 있어요. 
리딩 리딩 이크 써가지고 리딩에다가 거기다가 이제 테이블 레이어스를 이렇게 나열하실 수가 있거든요. 
나중에 되실 텐데
참석자 1 
그래서 주유소를 제한하는 형태가 크게 두 가지가 있는데 오더드랑 리딩이 있어요. 
오더드는 타 전에 나열된 순서대로 실행해라 리딩은 가로를 열고 가라앉다가 지정한 순서대로 하나 배운 거거든요.

참석자 1 
진행한 거죠.
참석자 3 
나중에 알고 있으면은 오더들에 대해서 알고 있으면은 다 오더들 같이 하는데 나중에 이제

참석자 3 
실제 이제 보석비가 잘못 사용되는
참석자 1 
그렇죠 그렇죠 아까 질문하신 중에 힌트를 가을 사용하지 않는 게 좋지 않느냐 그런 질문 나온 게 바로 그런 이유죠 힌트를 썼을 때 나올 수 있는 문제가 에시케일이 항상 유지가 되면 좋은데 에시케일이 바뀌었을 때 그 인트로 인해서 문제가 발생할 수 있죠

참석자 3 
그래서 네 이렇게 오더를 쓰면서 네 주석을 또 이렇게 달아주시기도 하는지 아니면은 오더 적으면 차라리 리딩으로 그냥 컬러를 이 하나씩 알려서 주면서 제작을 하는 게

참석자 1 
그건 마찬가지예요. 리듬으로 하더라도 나중에 케이블이 추가되면

참석자 3 
미팅으로 이제 아리아스 지정을 이렇게 해

참석자 1 
그거는 그거는 알아서 하시면 될 문제죠 그런 그런 위험성을 고려하신다고 하면 리딩 라이트 써서 지우시면 되는 거고 오 그거는 튜너의 마음이고 개발자의 마음이고

참석자 1 
아무튼 그렇게 취임을 했던 사례가 있다라는 얘기예요. 
네 보통은 우리가 아이오티에서 오더 드라이트가 어떤 조사를 올바르게 해서 아이오를 줄이는 목적으로 보통 쓰는 거지만 이 경우에는 아이오가 아니고 패싱 타임을 줄이기 위해서 어어드를 키트를 써서 트윙한 사례도 있었다라는 얘기예요. 
그만큼 파싱 타임이 일반적으로는 크게 문제가 안 될 수준으로 처리가 되지만

참석자 1 
에스케이 길어지면 길어질수록 조인된 태블이 많으면 많을수록 또 복잡할수록 서브 커리어도 많아지고 인내도 많고 복잡할수록 점점 최적화 시간은 오래 걸릴 수밖에 없다는 얘기죠 그만큼 당연하게도 그래서 아무튼 체력 과정이 굉장히 한산한 과정이다라는 것을 여러분들이 꼭 인식을 하시면 좋겠고

참석자 1 
그것이 이거 세션의 주제입니다.
참석자 1 
이거를 좀 시작을 하면 좀 시간이 좀 오래 걸릴 것 같아요. 
그래서 지금 시간을 벌써 11시 30분인데 토요일이고 그래서 아침도 못 드시고 오신 분들 많이 계실 것 같고 그래서 식사를 하고 이어서 하면 좋을 것 같습니다. 
질문 있으실까요. 하시고 없으시면 식사 후에 여기서 이어서 하겠습니다.

