참석자 1 
식사 마치고 저한테 커피를 사다 주신 분이 계시는데 참고 제가 요즘 커피를 안 먹고 있어요. 
목 상태가 안 좋아서 병원에 가보니까 역류성 후 이 있다고 그래서 커피부터 끊는다 그러더라고요 그래서 가끔 헛기침을 좀 자주 하더라도 이해해 주시고 다행히 다른 분이 지금 허 차를 사 오셔가지고 커피는 안 먹습니다.

참석자 1 
아까 좀 시간 전에 누가 질문하셨는데 뭐였죠. 
제가 같이 있을 때 좀 설명해 드리면 좋을 것 같아서 제가 이따 같이 해달라고 했던 질문하신 분들한테 식사하러 가시면서 점점 되면 택시 메모리에도 다 날아가잖아요. 
예예 그 후에 작업 좀 어떻게 해야 그 후에 작업이요

참석자 1 
db가 정전이 되면 정전이 될 수도 있고 물론 이제 정전에 대비해서 다 장치가 돼 있습니다만 어쨌든 비비를 내리는 순간 일단 로퍼팩스도 다 내려가고

참석자 1 
그 버퍼켓이도 다 내려가고 라이브 켓이 다 내려갑니다. 
완전히 아무것도 없는 초기화된 상태가 되겠죠. 
그다음에 뭘 해줘야 될까요. 그냥 자연스럽게 시스템이 구동되면서 구동되면서 다시 하나씩 올라가는 거예요. 
데이터들이 캐시도 마찬가지고
참석자 1 
특별히 줄 건 없습니다. 자연스럽게 새로운 에스p들이 시행되면서 에스p 올라가고 데이터들이 올라가면서 이제 로딩이 되는 거겠죠. 
근데 당연히 그러면서 전반적으로 디스카이가 많이 일어나고 또 새로운 레시피이 막 파생되면서 파생되면서 이쪽에 막 부화가 막 가중될 수 있어요. 
그래서 그것이 문제가 될 수 있는 시스템이라고 한다면

참석자 1 
일부러 기동하고 나서 몇몇 중간 시설을 막 미리 돌리는 그런 조치를 하는 시스템들도 있긴 합니다. 
문제가 될 수 있다라고 하면 대부분은 그렇게 사기 동적이 아주 많은 액티브하게 동장이 많은 그런 시스템이 아니라고 한다면 하나씩 하나씩 생기가 한 명씩 붙으면서 자연스럽게

참석자 1 
보통 그래서 보통 내렸다. 올리는 작업은 새벽에 하잖아요. 
그렇죠 새벽에 가면은 이제 직원들이 아침에 출근하면서 한 명씩 한 명씩 누르면서 자유롭게 계단들이 올라가고 에스크도 올라가고 여기서 쭉 올라가고 이렇게 되겠죠. 
근데 만약에 이게 시스템이 액티브한 그런 어떤 낮에 낮에 사람들이 많은 상황에서 갑자기 장에 가서 내려갔다가 올라왔어요.

참석자 1 
그러면 내렸다. 올라오는 순간에 살균이 확 붙으면서 실제로 평상시보다 훨씬 느리게 스킨 이용일 수 있어요. 
그런 경우라 한다면 내다 올렸을 때 일부 레스트들을 자주 수 시 일부러 수정해가지고 레스트가 데이터를 로딩해 주는 그런 조치가 필요할 수도 있기는 해요. 
그 정도로 막 유튜브 하는 많지는 않으니까 특별히 뭐 신경 안 써도 될 부분인 것 같습니다.

참석자 1 
또 질문 있으신 분 예 옵티마이징을 할 때 여러 가지 실행 계획을 비교해 보는 거잖아요. 
네네 근데 아까 했던 게 5만 건 만 건 했었던 게 파싱에 대한 내용이었잖아요. 
맞습니다. 네 파싱도 다양한 케이스를 비교하게 이거 그러니까 그 파싱이라고 한 것이 아까 그 파싱이라고 한 거지

참석자 1 
하드 파싱이 좀 그런 작업이라고 아까 제가 이거 돌리면서 이거 말씀하신 거지 않습니까 그렇죠 이게 아까 13초 걸렸던 게 24총가로 늘어놨던 거 그 안에는 파싱을 구분해서 제가 80이라고 표현했던 부분들은 이 모든 과정을 다 표현해서 말씀드린 거예요. 
그 중간에 이가 제가 깨웠던 거죠. 이것만 하고 표현할 수는 없잖아요.

참석자 1 
당연히 탈수만 했고 실력을 했고 예수 다 하게 됐던 것이죠. 
그런데 만약에 메모에서 찾았다고 한다면 메모리에서 똑같은 액체들이 만약 메모이 있었다고 한다면 파싱을 하고 바로 넘어가셨을 수 있겠죠. 
그런데 그런 상황이 아니게끔 만들었던 것이 뭐냐 하면

참석자 1 
베시켈이 계속 바뀌도록 제가 이렇게 만들었어요. 
여기 값이 베시켈 문장이 여기서부터 여기까지거든요. 
여기가 이 에시케 음션 자체가 1 2 3 4 계속 바뀌기 때문에 계속 새로운 에스케일이 되는 거예요. 
새로운 에스케이 그러니까 계속 파싱을 되 여기서 말한 파싱 하드 파싱 하드파시 최적화를 포함한 하드 파시

참석자 1 
그리고 아까 이제 질문하신 게 실기 바뀌어서 장애가 나는 상황 아까도 설명드렸습니다만 말씀드린 대로 시간이 늘어나는 거예요. 
시간이 늘어나는 건데 1초짜리가 3초로 늘어난다고 해도 큰 문제가 아닐 수 있는 시스템이 있는 반면에 1초가 3초로 늘어나는 순간 장애가 나는 시스템이 있어요.

참석자 1 
예를 들면 0.1초짜리가 3초로 늘어났다 그러면 하나 둘 세 한번 나오면 되니까 문제 없었다고 생각할 수 있지만 0.1초짜리 커리가 동시에 막 100번 1천 번 소용되는 그런 거리가 돼 있을 수 있거든요. 
그런 거리들이 만약에 0.1초짜리가 3초로 늘어 시간이 늘어난 순간 장애가 날 수 있는 거죠. 
일단 제가 이제 자주 지원하는 시스템 중에 하나가 이제 올리브 형이거든요. 
올리브영 올리브형 같은 경우
참석자 1 
3개월에 한 번씩 올려 세일을 해요. 
여자분들 많이 이용하시죠 우리 딸들도 보니까 올려세일 할 때 되면 제가 이제 올려세일 할 때마다 지원을 받는데 우리 딸들도 알더라고요 이 때 하는 날 여자애들이 워낙 많이 나오니까 그거 할 때마다 아빠가 거의 감사한다 이렇게 얘기하는데 거기는 이벤트 해요. 
어떤 특가 상품을 딱 내놓고 몇 시 몇 분 몇 초가 되면 그때부터

참석자 1 
100분에게 특별한 이제 할인 이벤트를 주는 거죠. 
그럼 동시에 그 순간적으로 특실이 꽉 물려요. 
그럼 그때 수용률 sk는 0.001초 반에 끝나야 되거든요. 
플랜이 딱 바뀌어서 0.01초 걸리는 애들이 에스 1번 비스 타입 앨범이 2번으로 바뀌는 거죠. 
그러면서 0.00초 걸리는 에스케이 갑자기 1초로 늘어나요. 
장애 납니다. 여러분
참석자 1 
공정이 확 늘어나면서 cp 상균이 확 올라가는 거죠. 
그러면 여기서 나오는 장애라는 것이 시스템이 다운된 그런 장애는 아니고 제대로 서비스를 못해준다는 얘기죠 제대로 서비스를 못 해주고 실피움은 데치면서 시스템이 버벅되는 그런 상황이 될 수가 있다라는 얘기 그런 일의 장에 말씀드렸던 거예요.

참석자 1 
또 질문 없으시면 주시면 오늘 좀 질문을 많이 해 주시니까 좋은 것 같습니다. 
많이 해주시고 이제 레스피 처리 과정까지 살펴봤고 이제 라이브 캐시의 구조 및 커서 공유라는 개념 제가 아까 그 커서라는 개념을 한두 번 말씀드렸는데 커서가 무엇이고 커서를 공유한다는 것이 무엇인지에 대한 개념을 설명드리도록 하겠습니다 라이브 캐시 구조입니다. 
아까 말씀드린 것처럼
참석자 1 
고유 메모리가 있으면 공유 메모리 안에는 크게 데이터 캐시와 코드 캐시가 있다고 말씀드렸습니다. 
제가 저도 이제 개발자 출신이에요. 개발자 출신이고 dba 생활도 했고 da로서 모델링도 해봤고 팀도 해봤고 제일 많이 한 건 튜닝이죠. 
저는 거의 튜닝만 15년 이상 했으니까 제가 이제 튜닝을 제일 먼저 시작하면서 제일 헷갈렸던 개념 중에 하나가 뭐냐면 커서를 공유한다 이런 개념이었어요.

참석자 1 
오락도 공부하다 보니까 커서 동이란 말이 나오더라고요 그 말이 잘 이해가 안 되더라고요 왜냐하면 여러분들 개발자들 다 아시겠지만 개발자들 우리 프로그램 개발 책들 보면 db 프로그램 책 보면 커서라는 말을 많이 써요. 
커서 그 우리가 말하는 커서는 커서를 오픈해서 커서를 캐치하고 캐치를 다 끝내면 클로즈 하고 그렇죠 그래서 r스 무분 넥스트

참석자 1 
아레스 무릎 퍼스트 코스를 이용해서 맨 마지막 레코드로 이동하기도 하고 맨 첫 번째 레코드로 이동하고 아스 네스트 한 칸씩 이동하기도 하고 아스 프리비어스 한 칸씩 뒤로 이동하기도 하고 이런 식으로 커서를 통해서 데이터를 앞으로 갔다. 
뒤로 갔다. 그러니까 데이터 셋을 데이터 셋을 컷을 오픈하고 나서 앞으로 한 칸 뒤로 한 칸 맨 앞으로 맨 뒤로 이런 식으로 컷을 통해서 데이터 이동을 제어하는데

참석자 1 
커서를 공유한다 이게 무슨 말일까요. 
개발자분들은 커서의 개념을 아까 제가 말씀드린 그런 식으로 데이터셋을 핸들링하는 어떤 그런 포인터 라로서의 개념으로 생각을 하고 있는데 커서를 공유한대요 이게 무슨 말일까 제가 헷갈렸던 개념 중에 하나가 그랬습니다. 
제가 이제 막 공부를 하다 보니까 커서에 크게 세 가지 커서가 있더라고요

참석자 1 
그러면서 이제 그 숙제가 풀렸던 거예요. 
여기 보시면 커서가 여기도 커서가 있죠. 
그죠 여기 유 sga 공유 메모리 안에 치어도프 안에 라이 패시 안에 커서가 있어요. 
이것이 지금까지 여러분들 설명드렸던 아까 그 커서입니다. 
spl 그 밑에 보면 이렇게 pga라고 하는 영역이 있습니다. 
pga
참석자 1 
pj pj가 뭘까요. 그렇죠 프로그램 글로벌 에어리어 또 다른 말로 프라이빗 글로벌 에어리어 또 다른 걸로 프로세스 글로벌 레어리어 한번 적어보세요. 
프로그램 글로벌 레어리어 약자 또는 프라이빗 글로벌 레어리어 또는 프로그램 글로벌 레리어 프로세스 프로세스 글로벌 레어리어 프로세스 프라이빗

참석자 1 
프로그램 용어에서 알 수 있는 것처럼 프로세스만을 위한 사적인 메모리 공간이에요. 
프로세스만을 위한 이 위쪽에 있는 이 sga는 시스템 글로벌 레어리어라고 해서 글로벌 시스템 글로벌 시스템 전체적으로 공유하는 메모리 양입니다.

참석자 1 
프로세스들이 공유하는 메모리 영이라는 얘기죠 공유하면서 데이터를 엑세스 안 영이겠고 이 pga는 프로세스만을 위한 독립적인 메모리 공간이에요.

참석자 1 
그래서 여기 보면 소프트웨어이라고 돼 있죠 소프트웨어 웨어 데이터를 조회를 해서 그룹 바이 오토바이 같은 걸 하게 되면 데이터를 정렬을 하게 되거든요. 
정리하는 과정에서 이 sga 버퍼켓시에 있는 데이터를 읽어서 소프트 에어리어를 가지고 내려와요 그래서 여기서 정리를 하는 겁니다. 
여기서 그런 목적으로 주로 pj가 활용이 됩니다.

참석자 1 
근데 여기 보면 pga 안에도 커서가 있어요. 
그죠 또 커서가 또 어디에 있냐 하면 이쪽으로 가보시면 자바 애플리케이션 비주얼 베이직 어플레이션 어플레이션에서도 커서가 있어요. 
보시면 커서가 여기도 있고 여기도 있고 여기도 있다라는 얘기가 그래서 여기 쉐어드 풀 라이브 캐시에 있는 커서를 공유 커서라고 얘기합니다. 
셰어드 커서 그래서 라이브 캐시에
참석자 1 
예 공인되는 슈어드 에스케 레어리어 두 번째 커스는 이 세션 커스라고 얘기해요. 
세션 커서  pja에 할당된 프라이빗 에스켈 에어리어 앞서서 얘는 슈어드 에스켈 에어이죠. 
시어드 에스켈 에어리어 그다음에 세션 코스에 있는 놈은 프라이빗 에스테 레어이요 마지막으로 여기에 있는 놈을

참석자 1 
애플렉션 코스라고 얘기합니다. 클라이언트 환경에서 이 코서를 세션 코스를 가리키는 핸들이고 각자 을 좀 설명드릴게요

참석자 1 
그래서 아까도 어제 말씀드린 것처럼 아까는 이제 여기 그림에 에스케이라고 돼 있었는데 지금 여기는 커스라고 돼 있죠 그래서 아까 말씀드린 에스케이 커스예요. 
이 커스에는 그 에스k을 실행하는 데 필요한 모든 정보들이 담겨 있어요. 
아까 말씀드린 것처럼 sk도 있고 실행 계획도 있고 공적 프로시션까지 만들어져 있는 겁니다. 
그런데 이 에스키를 실행할 때는
참석자 1 
얘를 여기서 바로 실행하는 게 아니고 이 정보를 읽어서 일단 이 세션 쿠서로 가지고 내려와요. 
세션 쿠서 가지고 내려와서
참석자 1 
둘레 차를 좀 준비해 보여드리면 왜 코스를 쉐우드 커서도 갖고 있고 트라이드 코셔도 갖고 있냐면 여러분들 객체 정보를 공부해 보신 적 있으시죠 네 없으신 분도 계시겠지만 저도 오래전에 이제 자바를 공부할 때 객체지향 프로그래밍에 대한 개념을 공부했던 기억이 나는데 그때 우리가 객체지향 오피라고 하는데 객체지향을 얘기할 때

참석자 1 
항상 첫 번째로 얘기하는 개념이 뭐냐면 클래스가 무엇이냐 대체가 무엇이냐 그죠 그때 뭐라고 얘기합니까 클래스는 뭐다 붕어빵이다. 
그러죠 붕어빵을 만드는 주형틀이다. 그래서 클래스를 인스턴스화 하는 것이 객체다 이렇게 표현을 해요. 
클래스를 인스턴스화 한 것이 객체다 그래서 클래스는 디자인이고 그것을 실체한 것이 객체다

참석자 1 
네 이제 오피 공부해 보신 분들은 딱 아실 텐데 아마 공부 안 하신 분들은 어려우실 겁니다. 
클래시는 예를 들면 붕어빵을 만드는 템플릿이에요. 
템플릿 템플릿이고 그것을 실제로 찍어내서 만들어낸 실질적인 붕어빵이 객체인 것이죠. 
이제 그래서 우리가 자바 자바나 c플꿀에서 코딩할 때 이런 식으로 코딩을 하죠. 
커서라는 클래스가 있다고 하면 커서 ce콜 뉴 커서

참석자 1 
그래서 이 커서는 클래스예요. 클래스 클래스인데 뉴 커서라는 이런 어떤 연산이라고 할까 이걸 통해서 실제로 객체가 만들어지는 거예요. 
그래서 객체가 만들어진다는 건 뭐냐면 실제로 그 클래스에 있는 내용들 코딩이겠죠. 
코드의 내용들을 실제로 실행할 수 있는 메모리도 활동하고 실제 실행할 수 있는 어떤 상태로 만드는 겁니다. 
이쪽에 있는 커서는
참석자 1 
디자인이에요. 디자인 커다란 놈이 이런 이런 놈이다. 
변수로는 이런 것들이 있고 또 그 안에 메소드들은 어떤 것들이 있고 어떤 하는 기능들이다 하는 것을 구현한 것이고 그것을 실제 실행할 때 이 오른쪽에 뉴 커서라는 어떤 연산을 통해서 실제로 실행할 수 있는 상태로 초기화를 하는 것이죠. 
메모리도 할당을 하고 신할 수 있는 상태로 만들어버리는 것이죠. 
그러니까 세션 코스가 바로 그런 역할을 한다라는 얘기입니다. 
그러니까 아까 말씀드린 것처럼
참석자 1 
레시케를 컴파일을 하게 되면 파싱을 하게 되면 이 공유 커스에다가 에시케일을 일단 실행할 수 있는 모든 정보들을 담고 있는 겁니다. 
그리고 실행을 하려고 하면 실행하려고 하면 얘도 실행을 하고 얘도 실행을 할 텐데 각각 실행하려고 하면 여기서 실행할 수는 없거든요. 
그 정보를 읽어서 이쪽으로 가지고 내려서 여기다가 메모리를 할당하는 겁니다. 
메모리를 할당하고 실제 실행할 수 있는 준비를 하는 겁니다. 
그래서 거기에 어떤 정보들을 담냐면 여기 보시면 있죠

참석자 1 
세션 컷에 담기는 정보들 고인 컷스를 가리키는 포인트를 일단 할당을 하고 그다음에 커서의 이름 코스트 변수 바이드 변수에 대한 주소가 그다음에 커서의 상태 상태를 관리하는 겁니다. 
여기서 커서를 오픈했는지 바운드했는지 실행 중인지 클로즈 했는지에 대한 정보를 가르키고 그다음에 sql을 처리하는 데 필요한 모든 기타 정보들을 여기다 다 메모리 할당하고 거기다 담는 거예요. 
실체화하는 것이죠. 인스턴스화하는 것이 인스턴스화하는 것이죠. 
그래서 여러분들이
참석자 1 
이 공유 커서와 이 공유 커스와 이 피지에 있는 세션 컷의 개념을 얘는 클래스 얘는 객체 이렇게 이해하고 보시면 아쉬우실 거예요. 
기존에 오피에 대한 개념 없으셨던 분들은 이렇게 설명하기 어려우시겠지만 적어도 오오피의 개념을 이해하신 분들은 클래스와 객체의 개념을 보시면 아마 이해가 쉬우실 겁니다.

참석자 1 
그다음에 마지막으로 이제 어플리케이션이 바로 우리가 일반적으로 개발자들이 알고 있는 커스터가 바로  어플리케션 커터예요. 
이 세션 커서를 가리키는 포인터죠 포인트이자 핸들입니다. 
핸들 그 이 핸들을 통해서 아까 말씀드린 것처럼 아스 무브 네스트 무브 퍼스트 넥스트 프리비어스 이렇게 옮겨다니는 거예요. 
그다음에 실행을 다 맞췄으면 클로즈를 하는 것이고

참석자 1 
그래서 여러분들 커서가 오픈돼 있다라는 것은 이 그림으로 보시면 돼요 보시면 어플리케션 커서가 있죠. 
지금 어플리케이션 커더가 있죠. 주변에 세션 커스가 있고 공유 커스가 있습니다. 
이렇게 애들이 서로 쭉 이렇게 연결된 상태 오픈돼 있고 오픈돼 있는 상태 이것이 커서를 오픈했다라는 의미가 되는 거예요. 
여기 여기 있는 정보를 읽어서 읽어서 저기에서 메모리를 할당을 하고 실행할 수 있는 상태로 만들고

참석자 1 
여기 있는 어프리의 커서를 통해서 커서를 제어를 하는 겁니다. 
이것이 커서가 오픈됐다라는 의미가 바로 이런 의미예요. 
그러면 컷을 받는다는 얘기는 보시는 것처럼 이 화살표가 끊기는 상태죠 끊고 플로즈한 상태가 되는 거죠. 
보시다시피 커서를 받았지만 받았지만 어때요 라이프 캐시에는 여전히 데이터가 살아있죠 그죠

참석자 1 
공유가 돼 있는 겁니다. 이 정보들을 여러 개의 클라이언트들이 같이 공유하면서 재사용을 하는 겁니다. 
커서가 닫혀 있지만 살아서 존재하는 겁니다. 
얘는 이해되시겠죠.
참석자 1 
그래서 우리가 커스를 공유한다고 했을 때의 그 커스는 지금 설명드린 세 가지 캐스 중에 뭐다 바로 이 고인 커스라는 얘기예요. 
라이브 캐시에 공유되는 고인 커스가 바로 보시다시피 이 pga는 공유 가능해요. 
안 해요. 공유 불가능하죠. 그렇죠 아까 얘기한 것처럼 pga라고 하는 것은 프라이빗 프로세스 프로세스만한 공정인 멤버의 공간이에요. 
그걸 어떻게 공유하겠습니까 보통 본다면 이 자우 애플리션이나 비교 에스피는 어때요

참석자 1 
체크라트 pc에 떠 있는 프로그램이지 않습니까 떠 있는 프로그램 그걸 어떻게 공유합니까 그죠 공유할 수 없는 거죠. 
공유할 수 있는 것은 바로 여기 공유 메모리에 떠 있는 이 코스를 공유할 수 있는 것이다. 
좀 어려운 개념이에요. 그렇죠 그래서 이해가 되시는 분도 계시고 이거

참석자 1 
어렵다. 그런 분도 계실 것 같은데 질문 해보실까요. 
네 실행 계획이랑 로퍼 시저가 이제 공유 포서에 들어가 있기 때문에 네 커서 예 pga 쪽에 있는 세션 코스에서는 그거를 이제 매번 이렇게 포인트를 가지고 접근해서 쓰는 건지 아니면 복사를 말 해서 쓰면 일단은 포인트를

참석자 1 
찾아요. 얘를 찾아갑니다. 찾아가서 얘가 이제 네모니까 그분이 하는 포인트를 찾아가서 예 포인트를 일단 찾아가야 얘를 읽을 수 있으니까 포인터를 찾는 거고 거기는 정보들을 읽어서 가지고 오는 거죠. 
실행하는 데 필요한 그 여기에는 이 sq를 실행하려고 하면

참석자 1 
메모리를 얼마큼 할당해야 되고 반주변수에는 어떤 것들이 있고 어떤 어떤 반 변소를 받아야 되고 그런 모든 정보들이 다 여기에 담겨 있는 거예요. 
그 정보들을 읽어서 읽어서 여기에 실제로 그것을 인스턴스화시키는 거죠. 
현 구현이라고 해서 인스턴스화시키는 거죠. 
실제 실행할 수 있는 형태로 메모리로 할당할 것이고 데이터를 읽어서 뭔가 처리를 하려고 하면 메모리가 필요할 거 아닙니까 그렇죠 예 그 정보를

참석자 1 
여기도 할당을 하고 얘기도 각자 할당을 해서 그 정보들을 각각 할당을 해서 실행을 하는 것이죠. 
공유 메모리도 놓고 그걸 할 수는 없잖아요. 
그죠 얘는 그것을 실행하는 데 필요한 정보들만 제공을 하는 것이고 실제 실행은 여기서 하는 그런데 실행계획은 어떻게 보면 다 똑같은 값을 갖고 있어요. 
그렇죠 똑같은 실행 이 spl은 똑같은 실행 얘를 가지다 쓰는 얘랑 얘랑 똑같으니 다를 것 같은데 똑같은 실행을 가지고 실행을 하는 것이죠.

참석자 1 
저쪽에 안 보이실 텐데 보시면 지금 이 이쪽 어플리케이션도 이쪽 pg에도 얘를 가리키고 있고 얘도 얘를 가리키고 있지 않습니까 똑같은 레스큐 실행을 가져다가 똑같은 방식으로 실행하는 거예요. 
똑같은 방식으로 또 다른 질문 있으신 분 이해가 안 되는 부분

참석자 1 
네 pda 영역으로 이제 메모리 새로 할당해가지고 이제 객체 개념으로 하나 이제 만드는 거잖아요. 
네 그거를 이제 애플리케이션 단에서 실행을 이제 하는 것 같은데 네 이 개념이 조금 조금 이제 명확하게 이해가 저 이제 pga 자체가 특정 프로세스에 할당돼 되어 있는 내용이 있잖아요. 
서버 서버 쪽에 서버 쪽에 예 잠깐만요

참석자 1 
제가 아까 말씀드릴 때 이게 이제 커서 오픈한 상태라고 얘기했는데 여기까지는 칼라이트단이에요. 
그분들이 안 보이시니까
참석자 1 
여기까지는 클라이언트 단입니다. 클라이언트 단이고 여기서 말하는 클라이언트는 제 pc일 수도 있고 와스일 수도 있는 거죠. 
lp서비일 수도 있는 거고 이쪽에 pj부터 이쪽은 db 서버입니다. 
db 서버 쪽에 여부터 여기까지는 db 서버예요. 
그 상태에서 질문 들어주실까요. 그게 궁금하셨어요. 
예 맞습니다. 그래서 왼쪽에 하나는
참석자 1 
이쪽 레이어는 클라이언트 pc일 수도 있고 와스일 수도 있고 에이플 서버일 수도 있는고 이쪽이 dba db 데이터 베이스 레이어 dbms 또 다른 질문 그러면 ap 단에서도 커서가 있다고 하면 예

참석자 1 
ap에서 커서에 내가 원하는 애플 정보가 있다고 하면 pj 거치지 않고 바로 라이브러리 표시로 그 정보를 가져오면 돼요 pj를 어떻게 안 거치죠 피즈는 거칠 수밖에 없지 않습니까 지금 그림으로 봐도 그 ap의 커서랑 pj 커서랑은 뭐가 다른 가요 용도 자체가 다른 거죠. 
얘는 그냥 포인터예요. 포인터 얘를 가리키는 포인트고 그 포인터 핸들 핸들을 통해서

참석자 1 
얘가 하는 역할은 커서를 오픈을 시켜놓고 그걸 위해서 모브 넥스트 브 넥스트 모브 넥스트 이렇게 이동하는 핸들 역할만 하는 거죠. 
그래서 커서를 오픈하고 모브 넥스트 모브 넥스트 하고 이동하고 eof에 도달하면 클로즈 하고 그럼 제어를 하기 위한 핸들 운전대 라고 생각하시면 되는 거고 그리고 실제로 얘는 실제로 자동차 얘가 이제 운전대로 표현했으니까 실제로 움직이는

참석자 1 
자동차가 되는 것이고 얘는 자동차를 만들기 위한 주형틀 템플릿 그런 게 있다는 거죠. 
이제 pga까지는 네 sqa를 실행하기 위한 것들을 이제 객체화시켜서 갖고 있는 거고 네 이제 어플리케이션 단에서는 실행 어찌됐건 sq 실행해서 가지고 온 이제 데이터셋을 컨트롤하는 커버하고 보면

참석자 1 
데이터를 가져온다고 해수셨는데 데이터 셋을 한 번에 다 갖고 온 건 아니에요. 
한 꺼씩 한 것이 정확히 얘기하면 어레이 단위로 예를 들어 어레이 사지가 디폴트가 한 10이나 15거든요. 
자바 기준으로 하면 10이에요. 10개씩 가져와요 10개씩 전체 결과식밥이 100만 권이라도 100만 건을 다 갖고 와서 거기서 아르스 테스트 하는 게 아니고 10개씩 10개씩 갖고 옵니다. 
어레이 단위로
참석자 1 
처음에 10개를 딱 가지고 와서 그 소진을 하다가 10개가 다 소진되면 다음 패치코를 통해서 또 10개를 가져오고 소진 소진 소진하다가 몇 개를 다 소진하면 다시 10개를 가져와서 소진 소진하고 우리는 r스 모브네스트를 100번을 한다고 하면 100번을 한다고 하면 머리 사이즈가 10이면은 실제로는

참석자 1 
디비 쪽은 10번을 갔다. 온 거예요. 
10번 가서 한 번에 10개 갖고 와서 모그네스 모그네스트 네스 10번 하다가 11번째 되면 더 이상 없으니까 또 db에 가서 10개 가져오고 어레이 단위로 가져오고 좀 헷갈렸던 부분이 이제 db 사이드라고 했었을 때는 저 이제 라이버리켓이랑 pja가 pg에 있다면 뭔가 이제

참석자 1 
실행하기 위한 어떤 것들을 가지고 있는 거고 실제로 아직 실행하기 전 그렇죠 실행하기 전 네 이거 실행하는 과정에서도 계속 이쪽 공부를 하려고 하죠. 
결국 이쪽 아까도 얘기했다시피 커서의 상태라든지 현재 어디까지 패치가 그런 정보를 여기에 다 담고 있는 거예요.

참석자 1 
여기 다 알고 지는 그런 게 없을 거고 그렇죠 그러니까 여기 저걸 읽어서 실제로 시장을 여기서 한다고 그랬잖아요. 
그래서 이쪽을 통해서 계속 상품을 더 갈고 라 그러면 얘가 이게 프로세스잖습니까 프로세스 이 프로세스가 결국 데이터를 계속 읽는 건데 이 프로세스가 메모리 공간이고 프로세스가 계속 일을 하면서 데이터를 갖고 오는 거고 그 갖고 오는 모든 상태 값을 얘들이 여기서 다 관리하는 거죠. 
코스를 오픈했다.
참석자 1 
창고 패치했다. 두고 패치했다. 1고 패치했다. 
그다음에 클로즈 했다면 신앙인을 위해서 발 뭘 입력했다. 
이런 정보들을 다 여기서 관리를 하는 거예요. 
그래서 그걸 관리하려고 하니까 메모리가 필요한 것이고 그 메모리를 여기서 다 그래서 여기서 실행을 실행하면서 평택 값을 관리하는 것이죠.

참석자 1 
이제 이해가 됐을까요. 해요. 소라는 용어가 네 위치를 가리킨다는 느낌으로 알고 있었는데 그게 바로 우리가 일반적으로 알고 있는 어플리션 커서인 거죠. 
포인터 핸들 이게 저도 이해를 하고 있었거든요. 
예전에요. 원래 전에 네네네 그래서 방금 말씀 주신 것처럼 이제 pga에 있는 커서는 이제 위치들까지 변하는 것들까지 정보를 계속해서

참석자 1 
위치가 변하면 그 정보들까지 계속 바뀌면서 가지고 있는 거라고 얘기하면 위치 정보라는 게 뭘 얘기할까요. 
위치가 저희가 패치를 어레인지 사이즈 단위로 이렇게 패치하거나 할 때 어디까지 데이터를 가져왔네 읽었다 가져왔다 그 어디까지 왔냐는 현재 몇 가지 읽었다를 알고 있는 거죠. 
그 데이터 위치를 알고 있을 필요가 뭐가 있어요.

참석자 1 
현재 나는 현재 전체 데이터가 몇 건인지 모르는 상태예요. 
네 그렇죠 끝까지 가보자는 모르는 거지 않습니까 아까 얘기한 것처럼 데이터를 한 번에 10만 개 100배 10만 개 10만 개로 다는 게 아니고 어레이 단위로 조금씩 조금씩 나눠져 있거든요. 
그러니까 내가 커다한 100에 총 몇 건지는 알 수가 없어요. 
다만 한 건씩 한 건씩 읽어오는 거죠. 
그래서 현재 한 번 읽었다. 하나 패치했다. 
2개 패했다. 3개 패치했다. 4개 패치했다.

참석자 1 
그 정도만 알고 있을 뿐인 거지 이게 전체가 이만큼인데 그중에 여기가 있다. 
여기 있다. 아는 건 아닌 거죠. 전체 몇 건인지 모르겠지만 현재 몇 권 교체했다까지만 알고 있는 거죠. 
네 감사합니다. 그러다가 쭉 읽다가 전체 10만 건 중에 100건만 있다가 컷을 받아버릴 수도 있는 거고

참석자 1 
끝까지 다 가서 eof에 도달한 다음에 받을 수도 있는 거고 그건 클라이언트에서 어떻게 제어해야 되냐에 따라 다른 거겠죠. 
보세요.
참석자 1 
이 디비에 비 테이블이라는 천만 걸때 테이블이 있어요. 
조금 이게 천명까지 테이블이거든요. 실행했습니다. 
그럼 지금 천 명 권을 다 갖고 왔을까요. 
앞에 계신 분 여기 뭐라고 돼 있습니까 백 그죠 지금 100권 가져온 겁니다. 
천만 건 중에 100권 가져온 거예요. 
그러다가 이제 얘를 쭉 스캔을 하다가 이제 쭉 가져 그러다가

참석자 1 
99 60 60 70 80 90 93 94 94 95 96 97 98 99 99에 도달하는 사람 100 100번째 제품이 열렸죠. 
그분은 이가 몇으로 바뀌었어요. 앞에 계신 분 110으로 바뀌었죠. 
처음에 100개 가져왔고 10개 더 갖고 온 거예요. 
10개 그러다가 좀 스캔을 또 해볼까요. 
스크롤 이렇게 하다 보면 105106 1007 108 100구 11개가 나오는 순간

참석자 1 
12120으로 할수 있죠 아 뭘 할 수 있습니까 한 번에 10개씩 갖고 오도록 갖고 온다는 거 알 수 있는 거죠. 
그 세팅이 어디에 있냐면 오렌지 기준으로 이제 뒷마다 클라이트마다 다 다른데 여기 보시면

참석자 1 
내부적으로 그렇게 세팅이 돼 있어요. 
여기 보시면 이셔 패치는 10 안 보이시겠습니다만 이셜 패치는 100 렉스 배치는 14도로 돼 있어요. 
첫 번째는 100개 가져오고 두 번째부터 10개씩 갖고 오도록 세팅이 돼 있는 겁니다. 
이 퀄리트마다 다 그런 세팅이 있거든요. 
그 세팅에 따라서 데이터를 갖고 오는 거예요.

참석자 1 
그러니까 한 번에 이게 1천만 건이라고 천만 권을 다 갖고 와서 거기가 어딘가를 가르키고 있다는 게 아닌 거죠. 
정해진 사이즈만큼씩 10개씩 10개씩 10개씩 그런 명령어를 이 어플리케이션 컨설을 통해서 명령어를 전달하는 거고 전달하는 거고 그 데이터를 이쪽에 전달해서 여기서 데이터를 이 서버 프로세스가 강의를 넓히는 게 좀 힘든데 이 서버 프로세스가 그런 처리들을 하는 거예요.

참석자 1 
이 클라이언트 쪽에서 명령을 전송하면 이 서버 프로세스가 그런 처리를 1건씩 1건씩 데이터에 있는 처리를 하는 것이고 그 데이터는 어디서 읽어요. 
여기서 있겠죠. 거기서 데이터 케이스를 읽을 것이고 또 읽으면서 현재 몇 권 읽었는지에 대한 정보들을 여기다가 관리를 하고 있는 것이고 여기서 관리하고 있는 것이고 그러다가 이쪽에서 전체 1천만 건이지만 예를 들면 100건만 있고 커서 클로즈 했습니다. 
클로즈를 딱 하면
참석자 1 
커서를 닫아버리는 거죠. 닫아버리는 거죠. 
그러면 이거 끊기고 끊기고 그래서 이런 상태가 돼버리는 거죠. 
이런 상태가 그럼 커서가 다친 거예요. 
그래서 이제 아무런 작업도 할 수가 없는 상태가 되는 거죠. 
더 이상 데이터를 가져올 수 없는
참석자 1 
커서에 대해서 이렇게 신도 있게 질문이 많이 나온 건 처음인 것 같습니다. 
그럼 앞에 계셨던 분들은 다 이해를 못하고 그냥 넘어갔다는 얘기가 되는 건데요. 
그죠 전 교육 가신 분들은 이해를 다 하셨거나 아니면 이해 못한 채로 그냥 공조문만 남고 가신 거겠죠. 
또 질문 없으세요.
참석자 1 
그러면 저 마지막 크고 어서 저 큰 그림에서 네 지금 tg 형에서 지금 초기가 된 거예요. 
그렇죠 초기가 돼 있죠 네모리 다 해지해버렸어요. 
가지고 있을 수도 있고 추가될 수도 있고 이게 이제 그것까지에서 다룬 내용인데 어플리케이션 커서 패싱이라는 게 있어요.

참석자 1 
그것을 또 갖고 있을 수가 있다는 얘기죠 그래서 없앨 수도 있고 얘를 또 캐시면서 갖고 있을 수도 있어요. 
저는 이제 프로 프로 에서 이제 소를 하는데 그게 이제 프로시에서 이제 클로우즈 선언을 하잖아요. 
네 클로 선 하면은 애플리케이션 단에서도 그냥 코트가 다 바뀌는 걸로 이해하고 있어요. 
다쳐요 다치는데 어플리케이션 커서 패싱 기능이 있어서 그것을 활성화시키면은 명시적으로 내가 클로즈 하지만 실제로 클로즈 되지 않고 살아 있어요. 
메모리에
참석자 1 
어플레이션 메모리에 그러니까 그게 그 과정에서 더 다룬 내용이고

참석자 1 
어필리 커서 캐싱이라고 있죠 커서 캐싱이라고 그래서 그림으로 표현하면

참석자 1 
이런 개념이 되는 거예요. 여기 보시면 캐시가 있잖아요. 
이렇게 캐시 캐시 표현한 거거든요. 여기서 클로드 하지만 실제로 이 캐시에 감이 있어서 여전히 오픈된 상태로 남아 있을 수가 있다라는 얘기예요. 
그 캐시는 여기도 있을 수 있어요. 세시 커서 캐싱이라는 것도 있거든요. 
여기서도 마찬가지로 여기서는 클로즈 했지만 저쪽 분들을 위해서 여기서는 클로즈 했지만 여전히 이쪽에 살아 있을 수 있다는 얘기예요.

참석자 1 
이것을 우리가 세션 커서 캐싱이라고 하는 것이고 어프레이션 커서 캐싱도 있다는 얘기예요. 
이거는 우리가 고까지 해서 다룰 내용이니까 지금 더 깊이는 안 들어갈게요 저는 아까 요 위에 것만 설명드린 거예요. 
기본적인 것만 기본 단에서 여러분들 이해를 하시고 저런 기능들도 있다라는 것만 좀 이해하시고 나중에

참석자 1 
공부를 하시다 보면 저런 개념을 접하실 바가 있으실 겁니다 가져온다고 하는데 00 pta 하고 10건에 대한 거는 기초 라이브러리 질문이 가능 데이터는 여기서 가져오지 않겠죠. 
데이터는 데이터는 라이키스로 가져오는 게 아니고 여기서 가져오겠죠.

참석자 1 
얘는 스킬 정보를 갖고 있는 거예요. 
코드 키시라고 했어요. 코드 키시 스킬을 실행하는 데 필요한 정보들을 담고 있는 거고 그 정보들을 가지고 와서 가지고 와서 여기서 실행할 수 있는 상태로 만들고 결국 sq 실행은 얘가 하는 거거든요. 
서브 프로세스가 얘가 실행할 수 있는 상태로 만들어 두고 그때부터 이제 이쪽에서 10권 가져와라 10권 가져와라 말리면 그 작업은 얘가 하는 거예요. 
얘가 하는 거고 데이터는 어디서 가져올까요.

참석자 1 
여기서 가져 온다는 얘기죠 데이터 캐시에서 서로 존재 이유가 다른 겁니다. 
얘는 데이터 캐시 영역이고 얘는 코드 캐시 영역이고 그리고 얘도 마찬가지로 키이기 때문에 실제 원본은 디스크에 있어요. 
디스크에 있는데 디스크로 바로 가는 게 아니고 여기를 먼저 뒤져보고 없으면 디스크에 가고 찾아보고 없으면 스펙 가고 그거 이따 우리가 오후에 이제 데이터 바이오에서 다룰 내용에 대해 미리 말씀드렸는데

참석자 1 
좋습니다. 지금 뭐 당연히 당연하게 나올 수 있는 질문인 것 같습니다. 
아까 지금 쉬는 시간 점심시간에도 어떤 분이 이제 나 또 이번에 하는 애인데 내가 보니까 아키텍처에 관심들이 많으시는 것 같아요. 
관심이 많으셔야 됩니다. 관심이 많으셔야 되고 공부를 더 하셔야 되는데 아쉽게도 라까지는 설명을 못해요. 
저희가 4일이고 4일이면 32시간밖에 안 되거든요. 
3간 동안에 인덱스
참석자 1 
보훈 범위 처리 조인 다 하면서 납부하고 못 하고 다 할 수는 없거든요. 
그래서 제가 이 시간에 하는 거니까 더 공부하실 분들은 이제 나중에 그것까지만 들어오시면 돼요 1번이 오라클 섞는 거가 1번이 2번이고 2번이 고급이 아니고 2번과 2번을 통틀어서 기본적으로 다뤄야 될 내용을 지금 이 교육 시간에 다루는 거예요.

참석자 1 
그리고 그 과정에서는 1건과 이건을 통틀어서 조금 더 구업 개념 아까 말씀드린 어플리션 컨서 캐싱 패션 컨서캐싱 그다음에 락에 대한 개념도 그런 것들을 고고 가정에서 다루고 있다. 
그래서 그런 궁금증들은 나중에 고가장 들어가셔서 해결하시면 좋을 것 같습니다. 
지금 오늘 이거 다 하다가는 조금까지 못 갈 것 같아요. 
어쨌든 질문하시는 분들 제가 최대한 말씀드릴 거니까 궁금증 있으시면 바로 질문해 주시고요 여기까지 하고 넘어갈까요.

참석자 1 
안녕하세요. 해 많이 하셨을 것 같고요

참석자 1 
커서를 공유한다라고 했을 때 커서는 쉐어드 프레이밍 커서다 그래서 여기 보시면 sk 지금 라이브 퀴즈 2개가 캐싱이 돼 있지 않습니까 고객 테이블을 고객 등급으로 그룹 관리해서 카운트하는 에스케이 하나 있고 사원 테이블에서 사원 번호를 조회하는 스킬이 있고 보시다시피 왼쪽에는 풀 스캔하는 실행기고 오른쪽에는 인덱스를 이용해서 테이블 이렇게 쓰는 실행기를 갖고 있다는 것을 볼 수가 있습니다. 
이것이 커서예요. 이거 커서
참석자 1 
커서 2개의 커서가 있고 왼쪽 커서를 보시면 프로세스 2개가 지금 동시에 실행하고 있는 겁니다. 
즉 공유하고 있다는 얘기죠 하나 ski가 실행계획를 두 개의 프로세스가 공유하고 있는 것을 볼 수가 있고 우측은 보시면 사원 번호 조건을 가지고 물음표입니다. 
물음표에다가 새로운 값을 계속 1번 4번 2번 4번 3번 사 계속 새로운 값을 다딩 해가면서 실행하는 거예요.

참석자 1 
재사용하는 거죠. 그죠 이 레시피를 처음. 
실행했을 때 사원 번호 이콜 1로 주였을 때 첫 번째 실행할 때 얘를 파싱을 해서 메모에 올려놨을 것이고 그다음부터는 2번 3번 4번은 계속 이 시대를 재사용한다는 얘기죠 이 것을 재사용한다 계속 그렇게 해서 계속 실행을 하다가 한 10만 번쯤 캐치하다가 힘들어서 잠깐 멈추고 작업을 멈추고 화장실 갔다. 
오거나 또는 커피 한 잔 하나 갔다. 
오거나 담배 피우러 갔다. 올 수 있겠죠.

참석자 1 
그러면 그 순간에 얘는 매물이기 때문에 얘가 밀려 내려갈 수 있거든요. 
새로운 에스케이 딱 올라오면서 얘가 밀려내려갈 수 있겠죠. 
사라졌다는 얘기 에이지 아웃됐다는 얘기야 그 상태에서 화장실 갔다가 딱 와서 다시 진행합니다. 
그럼 어떻게 될까요. 메모리서 찾아보고 없네 그러면 어떻게 돼요. 
하드 파신을 또 해야 되겠죠. 컴파일을 또 하는 거예요. 
새로 또 최적화를 해서
참석자 1 
컴 파일을 해서 올려놓고 그때 또 또 다시 재생하는 거예요. 
언제든지 a 창업이 될 수 있고 다시 실행한 시점에 다시 올라오면서 또 같은 과정을 반복한다는 얘기죠 아까 이쪽에서 질문하시려고 그랬던 것 같은데 문인가요

참석자 1 
예예 저기 라이브러리 캐시인데 저게 pga 캐시에서 라이브러리 캐시를 하나 이렇게 포인트로 잡고 객체화를 잡고 있어도 이렇게 에이지 아웃 되는 경우가 있을까요. 
이 영역에서
참석자 1 
베이지가 될 수 있습니다. 예 잡고 있는 건 아니거든요. 
그것을 딱 찾아서 읽는 그 순간에만 락을 딱 걸어서 데이터 읽고 나면 풀어요. 
풀어요. 감사합니다. 계속 잡고 있지 않죠. 
그러면 그 잡고 있으면 진짜 문제 되죠 그럼 절대 계속 실행되는 반복도 제일 많이 실행되는 그런 sk 같은 경우는 모든 프로세스들이 계속 걔를 참조하고 있을 텐데 절대 그런 걔는

참석자 1 
하지 않고 밀어 수 있죠 또 다른 질문 없으시죠 없으시면

참석자 1 
그래서 소프트 파싱과 하드 파싱에 대한 개념 그렇게 이해하시면 되겠고요 이름 없는 sql 문제라는 제목으로 제가 이제 제목을 잡아봤는데

참석자 1 
이 라이브의 키시에는 에스테만 캐싱 되는 게 아니고 베스트만 캐싱 되는 게 아니고 프로시저들도 캐싱이 됩니다. 
프로시저 사용자 정의 함수 그러니까 db 저장용 함수 db 저장 프로시저 트리거 같은 다양한 프로시저들이 캐싱이 됩니다. 
프로시저 아시죠 디비 저장용 함수 디비 저장용 함수 프로시저 트리거 같은 이런 것들이 다 캐싱이 돼요.

참석자 1 
그런데 함수나 프로시나 틀리거나 패키지 같은 애들은 이름이 있죠. 
그죠 만들 때부터 크레이트 펑션 이름 그래서 하기 때문에 이름이 있어요. 
이름이 있기 때문에 걔들은 컴파일 된 상태로 디셔더에 저장이 돼요. 
그렇기 때문에 메모리에서 밀려 내려간다고 하더라도 다음 번에 메모리에서 없으면 걔를 그대로 컴파된 상태로 그대로 읽어서 실행하면 되는 거예요.

참석자 1 
무슨 얘기지 알겠죠. 캐시를 찾아보고 네 없다고 하면 디셔널에 가서 그 정보를 읽어서 올려놓고 실행하면 됩니다. 
컴파일 되는 놈은 그대로 그래서 명시적으로 드랍하기 전까지는 영구 보존이 됩니다. 
디셔널리에 데이터 디셔널이 영구 보존이 되는 것이고 언제든지 개를 다시 적재해서 공유 재생할 수 있습니다. 
이름이 있는 라이브 캐시 오브젝트죠 라이브 캐시 오트 줄여서 엘시오라고 얘기합니다. 
엘시요 엘씨요 그니까 이름이 있는 엘시오가 있고

참석자 1 
이름이 없는 lco가 있다라는 건데 이름이 없는 lco는 대표적으로 스키 그다음에 그다음에 어나니머스 스피 에스케 어나니머스 스피 레스케 아실까요. 
우리가 프로시저를 만들 때 크레이트 프로시죠 이렇게 말 쓰시지만 디클레어로 시작하는 프로 있죠. 
그죠 디클레어로 그죠 그것을 우리가 어나니머스피 레시피라고 해요.

참석자 1 
걔는 이름이 없습니다. 이름이 없기 때문에 스킬도 그렇고 어는 스킬 스킬도 그렇고 이름이 없기 때문에 어쨌든 이름이 없는 애들을 메모리를 찾아야 될 거 아니에요. 
그렇죠 찾을 때 그럼 이름이 없는데 어떻게 찾느냐 결국은 풀 텍스트가 이름이에요. 
풀 텍스트가 에스키엘 문장 자체가 이름이고 피엘 에스키엘 프로그램 자체가 이름이 된다는 얘기죠 안나님 스피엘 에스키엘 같은 경우는 그래서 얘들은

참석자 1 
비셔널에 저장하지 않습니다. 아까 이제 제가 이제 담배 피워 라는 얘기를 했는데 에스크 실행하다 담배 피워 가지 않습니까 갔다. 
온 거 밀려나면 그냥 사라지는 거예요. 
사라지는 겁니다 만약에 프로시저 같은 경우는 사라진다고 하더라도 그 원본은 디션을 있으니까 그것을 그냥 이거다 실행하면 되는데 얘는 그냥 사라져버리는 거예요. 
디션에 들어하지 않기 때문에 그럼 다음 번에 입힐 때 또 컴파일이 일어난다는 얘기예요.

참석자 1 
최저가 이 그래서 이름 전체 전체 텍스트 자체가 1인이다라는 얘기입니다. 
그래서 버려지고 나면 다시 실행할 때 똑같은 최적 과정을 반복해서 수행한다라는 것이죠. 
굉장히 중요한 겁니다. 예수교의 문장 자체가 커서를 식별하는 식별자다라는 것이고 이것이 굉장히 중요한데 예를 들어서

참석자 1 
여기 보시면 똑같은 레시필 있죠 ep 테이블에서 epmo 7900으로 조회하는 똑같은 레시필인데 우리가 보기에는 다 똑같은 레시필인데 db 써 볼 때는 다 다른 그래요 왜 그럴까요. 
자 대소 문자가 다르고 그죠 여기는 빈칸이 하나고 빈칸이 2개고 그죠 또 스킨 한명을 명시했고 얘는 명시하지 않았고 주석을 달았고 주석을 안 달았고

참석자 1 
힌트를 명시했고 힌트를 명시하지 않았고 에시케 텍스트 자체가 다르지 않습니까 전부 그 의미적으로는 다 똑같은 에스켈이지만 얘들은 비밀을 써볼 때는 다 다른 시필래요 다 각각 최적화를 하고 다 각각 메모리를 공간을 따로 할당받아서 각각의 커서 공간을 할당을 만든다는 얘기가

참석자 1 
즉 공유가 불가능하다라는 얘기예요. 의무적으로 다 같은 레시피임에도 불구하고 공유할 수 없다. 
그래서 우리가 여러분들 sk 표준 같은 거 개발 표준 같은 거 만드는 거잖아요. 
그죠 대소 문자 가급적이면 똑같은 스킬들이 많이 완성되지 않게끔 하려고 표준을 만드는 거예요. 
대문자로 할지 소문자로 할지 그죠 그다음에 줄 바꾸면 어떻게 할지 개발 프로젝트 나오면 다 그런 거 있죠. 
개발 표준 같은 거
참석자 1 
가급적이면 똑같은 시기이 양산되지 않게끔 하려고 하는 거고 사실 그거보다 더 중요한 건 뭐예요. 
가독성 때문에 그런 거죠. 그렇죠 개발자마다 다 다른 스타일을 개발하면 가독성이 떨어지니까 그 가동성 때문에 그런 것도 있지만 똑같은 spm이 많이 메모리 올라가는 것을 방지하기 위한 그런 용도도 있습니다. 
사실은 개발자에 따라서 이렇게 스타일이 다르게 해서 생기는 문제는 사실 크지는 않아요. 
스케일이 몇 개 더 올라간다 해서
참석자 1 
네모 효율이 얼마나 떨어지겠습니까 그죠 진짜 문제는 이런 케이스가 아니고 이런 케이스예요. 
커스터머 테이블에서 로그인을 처리하는 어떤 개발을 어떤 개발자 맡았는데 그 개발자가 어떻게 개발을 했냐면 이렇게 개발을 한 거예요. 
로그 나이디 오라킹 로그 나이디 자바킹 로그나이디 터닝

참석자 1 
이 로그 앱이 이 입력 값 로그인 앱이 이 입력 값 부분이지 않습니까 이 부분을 리터롤로 처리한 거죠. 
사용자마다 sk이 바뀌게끔 처리한 거예요. 
바뀌게끔 우리가 여기 무슨 리터 레시킬이라고 하거든요. 
리터럴 레시킬 리터럴 레시킬 아까 보셨잖아요. 
아까 우리
참석자 1 
그러졌네
참석자 1 
아까 보신 거 기억나시죠 그죠 제가 노트 돌리면서 sk 문장 자체가 아이가 1 2 3 4 바뀌게끔 처리한 거 꼭 이걸 리터 sk라고 얘기했고요 그렇게 개발하게 되면 어쨌든 sk 문장이 바뀌기 때문에 결국 sk는 프로시라고 말씀드렸고 결국 오라킹을 처리하기 위한 프로시가 내부적으로 만들어지고 자바킹이 로그인할 때 처리하기 위한 프로시가 내부적으로 만들어지고

참석자 1 
토미가 로그인 했을 때 이 스키를 처리하기 위한 프로시가 내부대로 만들어지는 겁니다. 
sk는 결국 프로시를 만드는 거라고 그랬죠 프로시저가 각 사용자 로그인 아이디 별로 각각 만들어지는 거예요. 
이 시 때문에 만약에 고객이 100만 명이면 최대 10만 개의 프로시저가 만들어져야 된다는 얘기죠 예를 들어서 11번가에서 오늘 낮 12시에 특가 이벤트를 한다고 딱 공지를 했어요. 
12시에
참석자 1 
그럼 어떻게 될까요. 한 11시 50분쯤부터 상대들이 막 로그인을 시작하겠죠. 
그죠 이벤트 참가하려고 전체 천만 명인데 100만 명인데 100만 명 중에 10% 10%면 10만 명이죠. 
그렇죠 10만 명이 로그인을 합니다. 
그럼 실제로 10만 개의 프로시가 만들어지는 거예요. 
그 짧은 순간에 짧은 순간에 그러면서 막 나비 캐시가 막

참석자 1 
이 프로시어로 가득 차겠죠. 그죠 그러면서 다른 것들을 막 밀어내고 밀어내면서 이 로그인을 처리하는 프로시어들이 10만 개가 막 만들어져서 메모리를 막 차지합니다. 
그래서 막 메모리의 경험을 막 일으키고 브라드프시에 바로 이걸 하게 된다는 만약에 여러분이 만약에 로그인을 처리하는 프로그램을 개발하려고 했을 때 이런 식으로 개발하시겠습니까 특이하지 않을 거 아닙니까 어떻게 할 거예요.

참석자 1 
8m 드리는 방식으로 그죠 입력값을 받아서 로그인이라는 하나의 프로시를 통해서 로그인 아이디를 받아서 처리하도록 파라미터 들리는 방식으로 개발할 거라는 얘기가 가능하죠. 
그거 이 안에 있는 이 프로시 안에 있는 내용이 다르면 내용이 다르면 각각 할 수밖에 없겠지만 결국 다 같거든요. 
그죠
참석자 1 
로그인 처리하는 프로그램이 데이터 액세스 경로가 다르겠습니까 다 똑같이 똑같은 인덱스를 사용할 것이고 똑같은 테이블 참조할 것이고 다 루틴이 똑같을 거 아니에요. 
이 루틴이 똑같은데도 불구하고 똑같은 루틴을 100만 개를 만든 것은 당연히 엄청난 비율을 양산할 수밖에 없는 것이고 파이도 드리는 방식으로 같은 방식으로 처리를 할 수가 있겠죠. 
그래서 우리가 에시케를 프로시를 당연 이렇게 만들어야 되는 것처럼 sk를 이렇게 만드는 방법이 있는 게 있는데 그게 바로 갈비 변수예요. 
갈비 변수 갈비 변수가 없는 거 바로 그거예요.

참석자 1 
하나의 프로세서로 모든 로그인을 다 처리하겠다라는 거죠. 
하나의 프로세서로
참석자 1 
실제로 이것 때문에 개발자가 이렇게 개발해가지고 장애가 나는 경우도 있을 수 있고 장애가 안 나더라도 어떤 배치 프로그램이 1시간 단위로 한 번씩 이렇게 돌아요. 
근데 그 배치 프로그램을 개발자가 갈비면을 안 쓰는 거예요. 
근데 그 배치 프로그램 한번 딱 볼 때마다 한 10만 개 50만 개의 데이터를 처리한다는 얘기죠 50만 개의 스 처리한다는 얘기예요. 
그러면 그 순간에 cpu가 쭉 올라갔다가

참석자 1 
떨어졌다가 또 한 시간 있다가 또 다시 쭉 올라갔다가 이렇게 떨어졌다. 
이런 생각이 나오는 이유가 바로 거기 있는 거죠. 
개발자 한 명이 대화를 잘못해서 저희가 가지 변수를 쓰지 않았을 때 생기는 그거에 대해서 실습을 통해서 한번 살펴보도록 하겠습니다.

참석자 1 
원래 오브젝트라는 뷰가 있어요. 우리 앞에는 말 그대로 모든 오브젝트를 보여주는 뷰인데 그 뷰를 이용을 해서 피라는 테이블을 만들었습니다. 
조회를 해보면 키 테이블에는 6만 8천 건이 들어 있습니다. 
6만 8천 건이 들어 있고
참석자 1 
데이터를 더 늘리기 위해서 한 번을 더 입력할게요 t백을 읽어서 키 백을 한 번 더 입력을 해요. 
그러면 6만 8천 건이 더 들어가겠죠. 
그죠 그럼 대략 한 14만 개 정도의 데이터가 지금 들어가 있는 상태입니다. 
그리고 올 오브 주체는 오브젝트 아이라는 칼럼이 있는데 얘가 지금 이렇게 시리어를 하지 않아요. 
그래서 시리하게 만들기 위해서 업데이트를 쳐요.

참석자 1 
오브젝트 아이디로 계속 조회를 할 거 같거든요. 
1 2 3 조회를 할 건데 중간에 이걸 빠지면 안 되니까 1부터 13만 7500까지 쭉 일련 번을 부여하기 위해서 로너을 업데이트 친 거예요. 
이해되시죠 그래서 1부터 13만 7500원까지 시료하게 값이 부여가 됐습니다. 
이 상태에서
참석자 1 
오브젝트 아이디에다가 인덱스를 만들어요. 
인스 만들었고 그래서 그 인덱스로 조회를 할 겁니다.

참석자 1 
5만 번만 해볼까요. 너무 오래 걸리면 안 되니까 2만 번만 해보세요.

참석자 1 
실행을 할 건데 그 t라는 테이블을 읽어서 1부터 2만까지를 읽어요. 
2만번 실행하는 겁니다. 근데 sk이 여기서부터 여기 컨테이션 있는 것부터 컨테이션 있는 데까지니까 요 땡땡x는 반인디 변수예요. 
그죠 땡땡 엑스는 그래서 에스케이 바뀌어요. 
안 바뀌어요. 레스케일 안 바뀌죠 그죠 레스케 안 바뀐 상태로

참석자 1 
이 유징 아이라는 요 키워드를 통해서 요 1부터 2만이라는 값이 여기다 이렇게 대입이 되는 거예요. 
1 2 3 4 이런 식으로 에스케이 전혀 바뀌지 않습니다. 
스킬이 그대로 유지된 상태로 1 2 3 1부터 2만까지 입력을 하면서 이만 번 실행하는 겁니다. 
한번 그랬을 때의 시간
참석자 1 
좀 많이 해볼게요 요즘 빨리 되네 5만 10만 원 할까요. 
10만 기기마다 속도가 달라서 너무 빨리 끝나면 재미없잖아요. 
플러싱을 했습니다. 일단 플러싱 해서 메모리를 비운 상태로 캐시 라이브 캐시를 비운 거죠. 
라이브 비운 상태로
참석자 1 
10만 번을 실행했습니다. 10만 번 실행하는데 2.68초 걸렸어요. 
2.68초
참석자 1 
바디먼을 쓴 겁니다. 그리고 여러분들 오라클에 보면은 브이달라 레시케이라는 게 있어요. 
브이달라 레시케
참석자 1 
9 달러 sk에는 뭐가 있냐면 라이브 캐시에 현재 공유돼 있는

참석자 1 
라이브 캣이 공유되는 에스캐럴들을 다 갖고 있어요. 
라이브 캣이 그러면 가끔 실행한 에스캐럴들이 메모리 있겠죠. 
그렇죠 그래서 제가 걔를 찾기 쉽게 찾기 위해서 테스트 원이라는 주석을 달아놓은 겁니다. 
테스트 원이라는 주석을 가지고 찾아볼 거예요.

참석자 1 
vt 레시피를 조하는데 보시는 것처럼 테스트 1이라는 주석을 가지고 찾는 거예요. 
어떻게 나올까요.
참석자 1 
보시는 것처럼 에스케이 변하지 않은 채로 오직 트라이드 이콜 땡땡 엑스라는 스킬을 가지고 파스코를 10만 번 했습니다. 
10만 번 했고 실행을 10만 번 했어요. 
그다음에 패치를 10만 번 했죠. 유니크하게 입었으니까 한 건씩밖에 붙지 않는 거예요. 
로드가 2인 건 왜 그럴까요. 제가 처음에 2만 번 시작했다. 
너무 빨리 끝나니까 한 번 더 했죠. 
그죠
참석자 1 
플러싱을 하고 다시 했어요. 그 플러싱 했을 때 얘가 임베드데이션 됐고 다시 한 번 심한 번 실행할 때 한 번 더 했기 때문에 로드가 2가 된 거예요. 
제가 막 다시 한 번 하지 않았으면은 이게 일이었을 겁니다. 
결국 이 로드가 뭘까요. 하드 파싱 했을 때 하드 파싱 했을 때 플러싱을 해도 저하고 횟수는 스트레스 고 플러싱을 하면 소도 저 하는 해도

참석자 1 
여기 보시면 하나 더 뭐죠 인베레데이션이 있거든요.

참석자 1 
임베르디는 한 번 됐지 않습니까 제가 까 플러싱 할 때 제가 인베르디션 된 거고 다시 한 번 이제 실행이 되면서 로드가 한 번 더 된 거죠. 
그래서 이거는 이제 하드 파스팅 횟수가 되는 것이고 이거는 이제 파스콜리고 이건 엑스피션이고 패시고 그죠 보시다시피 한 번 파스 한 것을 10만 번 재사용했다는 건 우리가 알 수가 있어요. 
그죠 그래서 시간으로 보면은
참석자 1 
2.68초 걸린 것이고 이번에는 똑같이 똑같은 스키를 실행을 해요. 
똑같은 sk 실행할 건데 얘는 테스트 2라는 주석을 달았습니다. 
쉽게 찾기 위해서 차이점이 있으면 뭐냐면 얘는 반디면서 썼는데 얘는 어때요 에스크로 문장이 어때요 여기서부터

참석자 1 
이 아이까지 가수 된 문장이에요. 그죠 그리고 이 아이라는 부분이 1 2 3 4부터 1부터 10만까지 계속 바뀌죠 에스q 문장이 계속 바뀌는 구조예요. 
그러니까 파싱이 10만 번 일어나겠죠. 
그죠 그럴 때 시간 아까도 우리가 하드 파싱의 시간을 봤는데 다시 한 번 보는 겁니다. 
얼마 쯤 말할 것 같으세요. 이거 한번 돌려볼게요

참석자 1 
이미 2초 지나갔습니다. 바이트를 서스 쓰지 않았을 때 효과예요. 
이게 바로 박연수를 왜 써야 되는지 아시겠죠. 
똑같지 않습니까 sk 구조는 똑같은데 방식을 썼느냐 안 썼느냐의 차이로 인해서 이렇게 많이 시간이 차이가 납니다.

참석자 1 
지금 내부적으로 뭘 하고 있는지 아시겠죠. 
그죠
참석자 1 
시장에서도 똑같잖아요. 여기도 10만 여기도 10만

참석자 1 
어떤 트릭도 없습니다. 여러분 혹시 트릭 쓴 거 아니야 그럴 수 있는데

참석자 1 
1분이 걸렸어요. 1분 아까 25초 걸렸는데 1분 걸렸어요. 
끝까지 얘기 메모리를 좀 뒤져봐야 되겠죠. 
메모리 어떤 모습으로 로딩이 돼 있는지 그래서 이번에는 테스트 2라는 값으로 줘서 조회를 합니다. 
어떻게 나올 것 같으세요. 여러분들 한번 상상해보세요. 
뒤에 보면 어떻게 나올까요. 조회를 해볼게요 저 어때요

참석자 1 
여러 개 아까는 한 건 하나 라이브 핏이 하나만 나왔는데 지금 여러 개가 나왔죠 베스트 영상을 보시면

참석자 1 
오젝 타이지가 10만일 때 99 1 3 4일 때 99 1 3 5일 대 6 7 8 9 그죠

참석자 1 
우리들 아이디별로 각각 메모리에 떠는 걸 볼 수 있죠 각각 파트 파싱을 했고 각각 각각 파트 코를 일으켰고 매번 로드를 했고 실행을 했고 패치를 했습니다. 
각각 커서가 새로 만들어진 겁니다. 총 10만 개의 커서가 만들어졌겠죠. 
그죠 10만 개의 고서가 더 놀라운 건 뭐냐면 끝까지 가볼 거야 끝까지 갔더니 몇 개 있습니까 여기 있는 867개

참석자 1 
10만 번 실행했는데 지금 메모리에는 867개밖에 안 남아 있어요. 
나머지 다 어디 간 거예요. 그렇죠 올라갔다가 새로운 게 올라가서 밀려 내려가고 밀려 내려가고 10만 개를 만들었는데 10만 개 중에 대다수 다 밀려 내려가고 새로운 것이 올라가면 다 밀려 내려가는 거예요. 
그 새로운 게 올라오려고 하면 기존의 걸 찾아서 밀어내버려야 되거든요. 
그 과정에서 메모리 해서 막 경합이 일어나요. 
메모리를 서로 점유하려고 막 경합이 일어나고

참석자 1 
게다가 제가 지금 경합이라는 표현을 썼는데 지금은 실제로 경합이 있는 상황이에요. 
없는 상황이에요. 없죠. 나 혼자 혼자 실행을 한 거거든요. 
나 혼자 심험을 시행한 겁니다. 그렇기 때문에 경험은 실제로 없어요. 
하드 파싱에 하는 과정에서 걸리는 시간만 존재했을 뿐이지 경험은 남지 않습니다. 
그런데 아까처럼 개발자 이렇게 하면 어떻게 돼요.

참석자 1 
동시에 막 수십 개 수백 개의 세션이 막 쓰면서 로그인 처리할 거 아닙니까 그들 간에 서로 메모리를 경쟁을 해요. 
서로 메모리 차지하려고 교합까지 생깁니다. 
그러면 지금 같은 2초가 2.5초가 1분 걸리는 정도의 시간이 아니고 그거보다 훨씬 더 많은 차이 걸릴 수 있다는 메모리가 가까이 생겨 진짜 메모리가 메모리 병이 생기면서 심피오가 탑 백을 쳐요. 
탑 백을 칩니다.
참석자 1 
조심하셔야 될 부분이에요. 라베키시 이 가디언스 부분이 여러분들이 사실은 이걸로 인한 폐해가 과거에 굉장히 많았습니다. 
왜 그랬냐면 저도 그랬습니다만 프로그램 db 프로그램 개발 책들 보면 예시를

참석자 1 
이런 식의 예시를 많이 보여드리고 있거든요. 
이런 식의 db 개발 책을 보면 책에서 예시로 이런 거 들어드려요. 
이걸 보고 공부한 개발자분들이 계속 이렇게 짜는 거예요. 
이게 편하거든요. 개발하기가 바이드면서 쓸려고 하면 바비면 쓸려고 하면 이디면 선언해야 되죠 또 실행하기 전에 바이드면스에다가 값을 바이딩해야 돼요

참석자 1 
근데 니트로 스택은 그게 쉽거든요. 그냥 이렇게 sk를 스트링을 처리해버리고 여기다 그냥 값을 그냥 문자로 결합해 버리면 되니까 프로 개발이 훨씬 편해요. 
프로그램 개발자에도 이런 식으로 예시를 보여주니까 개발자도 이런 식으로 짜요. 
그래서 예전에는 이 문제로 인한 시스템 부하가 굉장히 자주 발생했었습니다. 
그런데 요즘에는 어때요
참석자 1 
프레이멈을 많이 쓰죠. 그죠 스프린 프레이머 아이바티스 마이바티스 스프린 같은 프레이멈을 쓰기 때문에 비교적 과거보다 이런 현상들이 덜 해요. 
해요. 확실히 줄어들었습니다. 거꾸로 이제 어떨 때는 이렇게 짜야 될 경우도 있는데 이렇게 짜라 그러면 이건 어떻게 하죠. 
이런 개발자도 있어요. 요즘에 이제 대부분 이제 프레임업에서 샵 해가지고 이렇게 발로스를 처리하지 않습니까 대부분 개발자들은 그것만 아는 거예요. 
그것만 알고 거꾸로 리터럴로 처리
참석자 1 
해야 되는 경우에 어떻게 해야 되죠 이렇게 묻는 개발자들이니까라고 그래서 어쨌든 과거보다는 이런 식의 개발로 인한 프레임이 많이 줄어들었기 했지만 여전히 그런 문제들이 발견이 됩니다. 
어디서 발견될까요. 주로 솔루션들 솔루션들 이 큰 대기업 업체들은 대기업 에스아이에서는 대부분 프레임을 쓰기 때문에 저 문제도 잘 발생하지 않는데 솔루션들 있잖아요. 
솔루션들
참석자 1 
근데 솔루션 개발 업체에서 프레임업을 쓰지 않고 개발자들을 데려다가 이제 개발을 시키는 거죠. 
근데 그 개발자들이 이런 식으로 개발하는 거야 그래서 여러분들도 시스템 가보면 이런 문제들이 실제로 나타날 겁니다. 
조회를 해보면 그런 것들 찾아서 해결하셔야 돼요

참석자 1 
그래서 제가 실제적으로 제가 경험했던 사례들을 좀 보여드리고 싶은데 질문을 많이 받다 보니까 시간이 너무 많이 가서 제가 일단 생략하기로 하겠고 마지막으로 리터레스크를 추출하는 방법을 알려드릴게요 별별 시스템에서 가서

참석자 1 
저희 카페에 가보면 있는 내용인데 요 요거 저희 카페 디변 카페 있지 않습니까 디변 카페 61번 조회를 해보세요. 
실례성 61번 하고 뒤를 보시면 니트로 레스크를 추출하는 방법을 제가 이렇게 올려놨어요. 
이 쿼리를 이렇게 조회를 해보게 되면
참석자 1 
미트라 레시큐드를 찾아낼 수가 있습니다.

참석자 1 
실제로 보시면 제가 제 시스템을 좀 돌렸어요. 
돌렸으면 보이시죠 아까 제가 돌렸던 그 허리

참석자 1 
퀄리티 쭉 잡히잖아요. 그죠 그래서 똑같은 새끼에 다섯번 이상 실행된 애들 찾은 거예요. 
여러분들 시스템에 가서 한번 이걸 이걸 돌려보세요. 
돌려보시면 이런 패턴들이렇게 개발된 에스크들이 쉽게 찾아질 거예요.

참석자 1 
여기까지 하고 잠깐 쉴까요. 질문 있으실까요. 
하나만 봐도 될까요. 질문 질문 없으시면 지금 45분입니다. 
45분인데 2시에 2시에 시작하겠습니다. 
잠깐 쉬겠습니다.
