참석자 1 
저기 지금 끊기는 거는 이제 어쨌든 그 중에 해결할 수 있도록 요청하셨으니까 그리고 우리 서버 환경은 여러분들 실습 우리 교육하는 내내 계속 오픈이 돼 있으니까요. 
여러분들 집에 가셔서도 언제든지 접촉해서 실습이 가능하시니까 저도 말씀드리지만 오늘 했던 내용들 실행 계획 확인하고 오토 트레스 확인하고 그다음에 트레이시를 메모리에 남겨서

참석자 1 
그 정보를 확인하는 이 실습을 무수히 반복하셔서 자동적으로 될 수 있도록 충분히 연습을 해보셔야 됩니다.

참석자 1 
남은 시간 이제 한 30분 남았는데 남은 시간은 이제 아이오에 대한 내용을 좀 하겠습니다. 
아이
참석자 1 
오늘 오늘의 주요 주제는 옵티마제였던 것 같아요. 
옥티마저 옵티마제가 무엇이고 옵티마자의 역할 그리고 옵티마이저가 처리한 그런 결과를 우리가 어떻게 확인하는지 스스트 분석 분석 확인하는 그런 내용이었고

참석자 1 
결국 옵티마이저의 역할은 뭘까요. 옵티마이저 역할 좋은 시래기를 만들어내는 거지 않습니까 그럼 그 좋은 실행 계획기로 하면 뭘까요. 
좋은 실행 계획 그렇죠 비용 최소화 근데 그 비염이라고 하는 것은 또 뭘까요. 
아이오죠 그죠 결국은 옵티마의 역할은 아이오 최소화입니다.

참석자 1 
아이유를 최소화할 수 있는 실행 계획을 만들어내는 엔진이에요. 
아이유가 그 비용이거든요. 아이유가 그 시간이에요. 
결국 허리 수행 시간을 결정하는 것은 다른 데 있는 것이 아니고 아이오입니다. 
아이오 아이오에 의해서 허리 수행 시간이 결정되는 것이다. 
결국 sq 튜닝은 아이오 최소화하는 거예요. 
아이오 최소화 그렇기 때문에
참석자 1 
어제 데이터베이스라고 하는 놈이 어떻게 데이터를 읽고 쓰는지 그에 앞서서 데이터 저장 구조를 먼저 알아야 되겠죠. 
데이터를 어떻게 저장하고 그 저장된 데이터를 어떻게 읽는지 살펴봐야 될 것 니다. 
그래서 3장입니다. 3장 데이터 저장 부서입니다. 
데이터 저장 부서
참석자 1 
여기 이제 디비들도 계시지만 개발자분들 같은 경우는 모르실 수도 있는 내용인데 데이터를 저장하려고 하면 제일 먼저 테이블 스페이스를 먼저 정의를 해야 됩니다. 
테이블 스페이스는 테이블 스페이스는 말 그대로 스테이스예요. 
데이터를 저장할 수 있는 공간을 정의하는 거죠. 
크리에이트 테이블 스페이스라는 명령을 통해서 테이블 스페이를 정의합니다.

참석자 1 
그래서 테이블 스패스를 만들면서 그 테이블 스패스에 또 데이터 파일을 붙여요 데이터 파일을 결국 이제 데이터는 테이블 스트레스라는 논리적인 구조지만 결국 데이터는 데이터에 빨리 저장이 되는 거죠.

참석자 1 
이해를 돕기 위해서 테이블 스크레스 만든 명령어를 보면 좀 더 이해가 쉬울 것 같아서 db분들 좀 도와주세요. 
제가 db 한 지가 오래돼서 농용을 잘 기억 못할 수도 있거든요. 
뒤에 분들 좀 도와주세요. 크레이트 테이블 스페이스 이렇게 만들어요. 
테이블 스페이스 마이 마이 tbs라는 이렇게 프스트를 만드는 거야 만들면서 데이터 파일을 정의합니다. 
데이터 파일
참석자 1 
그거 시드라이브 밑에 오라클 모라 데이터 밑에 마이 tbs 죠 dbf 이 사이즈 메가 맞나요. 
여러분들 네 맞아요. 지금 테이블 스패스 하나의 파일이 하나 있는 구조입니다. 
지금
참석자 1 
태그 스패스의 팔이 하나일 수도 있고 두 개 이상일 수도 있어요. 
두 개 살 때는 어떻게 하죠. 어떻게 합니까 하고 하고 마하고 붙입니까 아니 데이터 파일 2개 만드시나 봐요 예 두 개 1번 tbs 옆에 1번 티에서 옆에 말을 해요. 
다시 사이즈는 사이즈 같이 주는 거 아니에요.

참석자 1 
아무튼 그런 명령이 있습니다. 이렇게 하고 이렇게 만들어놓고 나중에 붙일 수도 있어요. 
알터 테이블 스페이스
참석자 1 
아이 tbs에다가 레드
참석자 1 
에드 데이터 파일 그러니까 처음부터 두 개 되게 만들 수 있고 하나만 만들어놓고 나중에 애드 벤다 파일 해가지고 또 계속 추가해 나갈 수 있는 거예요. 
그러니까 테이블 스트레스는 논리적인 단위가 있는 거고 결국 그 논리적인 단위는 파일로 연결이 되는 거예요. 
그래서 하나의 파일을 가진 테이블 스페이스도 있고

참석자 1 
10개의 데이터 파일을 가진 테이블 스트레스도 있는 거예요. 
무슨 일인지 아시겠죠. 저런 식으로 테이블 스트레스를 먼저 정리를 합니다. 
그럼 지금 이렇게 하게 되면 100m짜리 공간을 가진 테이블 스피스가 만들어진 거죠.

참석자 1 
데이터를 저장하기 위한 테이블 스텝을 먼저 저장하고 정리하고 그 안에다가 세그먼트를 만드는 거예요. 
세그먼트 세그먼트는 뭐냐면 테이블도 세그먼트고 인덱스도 세그먼트예요. 
그럼 테이블 인덱스로 한 말을 썼는데 비주얼의 세그먼트라는 말을 쓸까 세그먼트가 뭔지 정의를 내리실 수 있는 분 세그먼트가 뭘까요.

참석자 1 
데이터베이스에는 다양한 로제트가 있어요. 
테이블도 있고 인덱스도 있고 펑션도 있고 폴셔도 있고 시퀀스도 있고 뭐 있습니까 시너님도 있고 뷰도 있고 다양한 오브젝트들이 있죠. 
그죠 다양한 오브젝트들이 있는데 그중에서 데이터 저장 공간을 필요로 하는 오브젝트를 특별히 세그먼트라고 부르는 거예요. 
펑션에 데이터 저장공간이 필요합니까
참석자 1 
신원이면 데이터 적용이 필요합니까 필요 없죠. 
그죠 테이보이나 인덱스에 대표적으로 저장용이 필요한 겁니다. 
그래서 다양한 오브젝트 중에 사용자 데이터를 저장하기 위한 저장 공간을 필요로 하는 그런 오브젝트를 그의 세그먼트라고 불러요 말을 하면 세그먼트는 테이블이 세그먼트 이디스크 세이먼트란 얘기예요. 
그래서 테이블 스트레스를 만들고 그 테이블 스트레스에다가

참석자 1 
테이블 만드는 거죠. 어떻게 만들어요. 
이렇게 만들었으면 크리에이트 테이블 마이 테이블 만들어 놓고 여기다가 테이블 스페이스를 지정합니다. 
마이 케이블 여기다 이제 클럼도 지정하겠죠. 
시원 바차투 는 넘버 이런 식으로 하고 나서 테이블 스페이스를 마이 tbs 이렇게 지정하는 거예요. 
그래서 마이 테이블이라 테이블은
참석자 1 
마이 티비에 가 테이블 스패스 저장하겠다라는 거죠. 
케이블 스패스를 달리할 수 있거든요. 
똑같은 테이블을 만들었더라도 케이블 스패스를 지정할 수 있는 거예요. 
이런 식으로 테이블 만들고 인덱스 만들 때도 마찬가지예요. 
크레이트 인덱스 테이블 스페스 어디 어디 이렇게 진행하는 겁니다. 
그런 식으로 해서 테이블을 딱 만들면 새로 만들면 빈깡통만 만든 거죠. 
실제 데이터는 없어요. 그냥 껍데기만 만든 거예요.

참석자 1 
껍데기만 만들더라도 기본적으로 기본적으로 하나의 익스텐트가 하나 이상의 익스텐트가 기본적으로 만들어져요. 
익스텐트 하나 익스텐트 이 스텐트는 뭘까요. 
에스케이티 공부해보신 분 중에 누가 있었지 아까 한 분 계셨는데 skp 해보신 분 시험 한 분 계신데 skp 시험에 도전하신 분

참석자 1 
예 미스탠트가 뭐예요. 블록의 연속된 집합 오케이 블록의 연속된 집합이라는 정의도 있고 그거보다 제가 더 좋아하는 정의가 있는데 못 가요. 
그것도 맞아요. 블록의 연속된 집합이다. 
그거보다 더 좋은 집관적인 저기는 뭐냐면 공간을 확장하는 단위다 공간을 확장하는 단이다. 
그래서 크레이트 테이블 아까처럼 크레이트 테이블을 하게 되면 기본적으로

참석자 1 
최소 하나 이상의 익스텐트가 만들어져요. 
비강성이죠. 그래서 비강성 만들어놓고 거기다 데이터를 입력을 하는 거예요. 
입력을 하라 예를 들면 2개를 할 때 하는 겁니다. 
이스텐트를 그 이가 이제 막 이해 될 거 아닙니까 꽉 찼어요. 
찼으면 공간을 확장해야 될 거 아니에요. 
어떻게 확장하냐면 이 테이블 스크리스 안에 있는 빈 이스텐트들이 많이 있거든요. 
그중에 빈 이스텐트 하나를 저기다 붙이는 거예요.

참석자 1 
결국 이 세그먼트랑 이 세그먼트랑 이 세그먼트들이 조금씩 이 텐트를 붙여나가면서 땅따먹기를 하는 거예요. 
테이프 스패스를 처음 만들었을 때는 그냥 빈 이스텐트들만 쫙 있는 상태인데 이 익스텐트들을 세그먼트들이 하나씩 하나씩 가져다가 자기의 땅덩어리를 땅땅없게 해나가면서 늘려나가는 것이죠. 
이해되십니까
참석자 1 
보시다시피 처음에 이 패블 스패스를 이렇게 하나 만들게 되면 100메가짜리가 만들어지고 10메가짜리 파일 안에 이스텐드 단위로 많은 익스텐트들이 존재한 상태예요. 
빈 익스텐트들이 빈 깡통 이스텐트들이 많이 존재하는 상태들이고 그 이스텐트들을 세그먼트들이 하나씩 하나씩 하나씩 가져다 쓰는 거예요. 
그래서 그것이 다 차면
참석자 1 
100m가 꽉 차면 이제 더 이상 데이터를 전달할 수 없는 상태가 되는 거예요. 
그러면 이제 에드 에드 파일을 해가지고 헤드 스트레스에다가 파일을 추가해 주거나 아니면 사이즈를 늘려주거나 이렇게 처리를 하게 되는 거죠. 
그래서 테이블 스테이스 세그먼트 세그먼트 세그먼트는 공간을 필요로 하는 오브젝트라고 했고 이 스텐트는 공간을 확장하는 라인이라고 말씀드렸습니다.

참석자 1 
참고로 최근 버전에서는 세그먼트 만들면서 익스텐트를 하나도 갖지 않게 만들 수도 있어요. 
아시는 분 뭐라고 하니까 거를 원래는 샘 모트를 만들면 기본적으로 하나 이상 익스텐트가 만들어진 상태로 샘 모트가 만들어지는데 최근 버전에서는 아예 스탠트를 안 만들게 만들 수 있어요. 
최초의 데이터가 처음. 들어가는 시점에 비로소 디스텐트가 만들어지게 할 수 있어요. 
포드 그렇죠 디퍼드
참석자 1 
디포드 크레이션 크레이션 디포드 크리에이션 세 평가 뭔가요 그런 게 있어요. 
디포드 시킬 수 있다는 얘기 이 스탠트가 처음 만드는 시점을 디퍼드 연기시킬 수 있다는 얘기죠 참고로 보셔도 됩니다. 
그다음에 이 스텐트 안으로 들어가 보면 이제 블락이 있어요. 
블락 블락 블락은 뭘까요. 블락
참석자 1 
이 스텐트는 공간을 확장하는 단계가 있어요. 
블록은 블록은 뭐라고요 아이오가 접근하는 단위 줄이면 아이오 단위 아이오 단위 데이터를 읽고 쓰는 단위라는 얘기예요. 
이게 무슨 뜻이냐면 우리가 인서트를 하지 않습니까 데이터를 인서트를 해요.

참석자 1 
레코드를 입력을 합니다. 그리고 그 데이터를 읽어요. 
입력하고 읽고 할 때 그 레코드라고 하는 것은 이 블록 안에 저장이 되는 로거든요. 
이 블록은 보통 8k바이트예요. 8k바이트 안에 많은 레코드들이 입력이 될 텐데 지금 보시면 여기는 이제 그림 보면 한 다섯 개 정도 레코드가 있는 건데 실제로는 훨씬 더 많아요. 
몇 백 개가 될 수도 있고 그죠 몇십 개가 될 수도 있습니다.

참석자 1 
몇백 개의 레코드가 있는데 그중에 특정 레코드를 입으려고 해요. 
블라인에 저장된 두 번째 레코드를 만약 입고자 한다 그러면 그 두 번째 레코드만 쏙 골라 읽을 수 있냐 하면 그 수가 없다는 얘기죠 그 레코드가 속한 블락을 통째로 읽게 된다는 얘기예요. 
통째로 이해되십니까 왜냐하면 아이오 단위가 블록 단위이기 때문에 특정 레코드만 쏙 골라 빼고 필요 없고 심지어는

참석자 1 
그 두 번째 코드의 세 번째 컬러이 성별이에요. 
성별면 일바이트지 않습니까 그죠 일 바이크 m 아니면 w가 들어가 있을 텐데 그 일바이트를 읽고 싶어도 그 일바이트만 골라 입을 수가 없다는 얘기예요. 
그 일바이트가 속한 레코드를 읽어야 되고 그 레코드가 속한 블록을 통째로 입을 수밖에 없다는 얘기죠 결국 나는 일바이트 데이터를 읽어야 되는데 8킬로

참석자 1 
8천 바이트를 읽어야 되는 비효율을 기본적으로 내재하고 있습니다. 
정리하면 이 스텐트는 공간을 확장한다니 블락은 아이오 다니다라는 거 혹시 질문 있으실까요. 
질문 네 익스텐트는 그러면 기본적으로
참석자 1 
공간을 물리적으로 이렇게 가지고 있는 게 생성이 되어지고 있는 게 있고 기본 이제 형성이 앞으로 되어질 기본 값이 또 따로 있는 겁니까 아까 여기 태브 스패스를 한번 완성해볼게요

참석자 1 
이거 씨 밑에 올려 볼까요.
참석자 1 
이 밑에 워킹 밑에 만들어볼게요 만들었어요. 
만들었으면 디비에 익스텐트라는 뷰가 있어요. 
익스텐트 그가 있고 테이블 스페이스 게임을 마이 tbs

참석자 1 
원래 디베인 과정 아닌데 이거 설명하고 있네 한번 써 봐

참석자 1 
뷰가 또 다른데 그 풀이
참석자 1 
여기다가 테이블을 만들어 볼게요 이렇게 만들면 죄송합니다. 
이게 이 세프 말고 프리 블록을 조회하는 뷰가 따로 있어요. 
제 뷰 명이 정확히 기억이 안 나는데 그 100마를 만들면 잠깐만요 여기 보면 디데이 테이블 스피스

참석자 1 
많이 그렇죠
참석자 1 
이게 로컬 시스템으로 돼 있으니까 이것도 이제 스페이스를 할당하는 크게 두 가지 방식이 있는데 1mg씩 딱딱 이렇게 하수 지정할 수가 있고 자동으로 늘어가게 하는 방법도 있어요. 
어쨌든 이 스템틀이 미리 이제 이렇게 만들어져 있는 거예요. 
100mg만큼의 예를 들면 1mg짜리 이 스템틀을 여기 이제 지정을 구체대로 안 했는데 여기다가

참석자 1 
밑에서 짜를 지정할 수 있거든요. 그러면 1mg짜리로 100mg를 만들어 놓는 거죠. 
1m짜리가 100mg만큼의 빈 공간이 만들어지는 거고 그 이스텐트들을 테이블들이 하나씩 나씩 가져다 쓰는 거예요. 
세그멘트들이 미리부터 다 만들어져 있는 거예요. 
그렇죠 센테 미리 이렇게 다 만들어져 있는 거고 그것을 1m가 단위로 하나씩 세그먼트들이 가져다 쓰는 거죠.

참석자 1 
뷰 이름이 아마 dba 프리 이렇게 프리 스페이스인가 그런 뷰가 있는데 뷰 명까지가 정확히 지 않네 dba 프리 케이스인가 그런 뷰가 있어요.

참석자 1 
집이 안에서 네 그게 아니 테이블 스페이스를 이름을 다르게 해서 여러 개 생성해서 테이블별로 그렇게 해당 특정 테이블 스케이스 내에 이제 이런 종류의 테이블을 모아놓고 생성해서 모아놓고 그렇게 테이블 좀 공유를 할 수 있죠 그렇게 관리를 보통 많이 그렇게 하죠. 
근데 그런 것들을 주로 하는 분들이 dbl들이잖아요. 
정책적으로 업무 영역 플로우 테이블 스트 만들 수도 있고 그렇게 안 할 수도 있고 그런 것들을 결정하는 게 디스죠 제가 개발기에서 테이블을 생성할 때 테이블 스테이시를 지정하고 만들어본 적이

참석자 1 
아무튼 이 얘기를 우리가 길게 할 필요는 없을 것 같아요. 
이거는 이제 db의 과정에서 다루는 내용이니까 우리는 트윙을 얘기하는 거고 트윈 하는 과정에서 결국 뭘 얘기하고 싶었냐면 아이오 단위가 블록 단위다 이거 설명하게 그럼 블락이 뭐냐를 알아야 되니까 블록이 뭐냐 하면 테이블 스페스 안에 세그먼 단에 익스텐트 안에 할당된 여러 개 블라우들이라는 얘기죠 그래서 아까도 말씀하신 것처럼 이 스텐트의 정의를 공간을 확장하는 단위라고 얘기하기도 하고

참석자 1 
연속된 블록의 집합이라고 얘기하기도 해요. 
보시다시피 블록 4개가 하나 둘 4개가 지금 연속되게 놓여 있지 않습니까 이 텐트 안에 그래서 이 텐트를 연속된 블랙 집합이다. 
이렇게 제안을 하기도 합니다. 그래서 지금 중요한 것은 우리가 기억해야 될 것은 테이블 스트레스가 뭐냐 그 안에 어떻게 이거 중요한 문제가 아니고 우리가 데이터를 입고 있을 때 블랙 다이를 입는다 이제 그것이고요

참석자 1 
그 얘기가 왜 없지 여기 있다. 말씀드린 것처럼 블록 단위로 와이어를 합니다. 
그러면 아래 두 spl은 io 측면 상체가 있을까요. 
없을까요.
참석자 1 
지금 emp 테이블에서 셀러리가 2천보다 크다는 조건으로 조회를 했고 그다음에 셀러리로 디세팅 정렬했어요. 
그래서 위에 커리와 아래 코의 차이는 위에서는 이메인과 셀러리만 셀렉션을 했고 아래에서는 아스타를 썼습니다. 
그 차이가 있는 거예요. 그럼 위에 커리어 아래 커리에 있어서 아이오 측면에서 성체가 있을까요. 
없을까요. 차이가 있다라고 생각하시는 분

참석자 1 
차이가 없을 것 같다고 생각하시는 분 사실 지금 시점에는 차이가 없다라고만 보셔야 되겠죠. 
왜 그럴까요. 블록 아이오 다니는 블록 단위로 아이유 온다. 
그랬잖아요. 아이오는 그래서 위에 커리어 아이 코리는 모든 칼럼을 읽느냐 아니면 내가 필요로 하는 두 개 칼러만 있느냐 차이인데

참석자 1 
나는 이메일과 셀러드만 필요한다고 해서 그거만 쏙 블라입을 수는 없거든요. 
결국 이메일과 샐러드가 속한 레코드를 통째로 입어야 되고 그 레코드가 속한 블록을 통째로 입어야 되기 때문에 그 위에 코리나 아리콜이나 아이유 측면에서 성 차이가 없다라는 것이죠. 
결국 아이유가 성능이고 아이가 차이가 없기 때문에 위에 커리는 아래 코리는 결국 성능이 똑같다는 얘기가 되는 거예요. 
그러면
참석자 1 
상식과 좀 안 하죠. 여러분 분명히 개발자 초 초 개발자일 때 분명히 선배들이 절대 아스타 쓰면 안 돼 저기 칼럼 지정해야 돼 이렇게 배웠을 텐데 오늘 트윙 수업을 들어보니까 똑같다라는 얘기죠 여러분들이 여태까지 알고는 상식이 잘못된 걸까요. 
앞으로 돌아가셔서 아스카를 막 써도 될까요. 
그렇지 않습니다. 분명히 성금 차이가 있어요. 
제가 말씀드린 것은 iot 면에서 차이가 없다라는 얘기지 분명히 차이가 있을 텐데 어떤 요소들이 있냐면

참석자 1 
우선은 인덱스 구성을 보셔야 되는데 만약에 이 테이블에 이메일과 샐러드만으로 구성된 인덱스가 있다고 하면 위에 거리는 인덱스만 입고도 처리가 가능해요. 
그죠 여러분 교재 제가 훌쩍 넘겨가면 교재를 먼저 살피려고 좀 보여드리고 싶은데 어디에 있냐면

참석자 1 
흐름상 좀 제가 지금 앞쪽으로 먼저 넘어갈게요 남은 시간이 얼마 안 됐죠 3 21페이지 지금 하고 있어요.

참석자 1 
위쪽 컬리 보시면 emp 테이블에서 조회를 하는데 여기서 참조하는 컬럼은 이네임과 셀러리밖에 없습니다. 
이네임과 셀 그래서 만약에 이 테이블에 이네임과 셀로 구성된 인덱스가 있으면 위에 거리는 그 인덱스만 입으면 돼요 반면에 아래 코리는 아스타를 썼기 때문에 모든 컬러는 다 읽어야 되겠죠. 
인덱스만으로는 해결이 안 된다는 얘기죠 그러면 똑같이 레코드가 100만 개가 있을 때

참석자 1 
테이블에 더 많은 블록을 차지하겠어요. 
인디스가 더 많은 블록을 차지하겠어요. 
테이블 당연히 테이블에 더 많은 블록을 차지하겠죠. 
인덱스에도 100만 건 테이블에도 100만 건이지만 인덱스에는 칼럼이 2개밖에 없는데 테이블에 한 100개 칼럼이 있거든요. 
그럼 똑같이 100만 개를 저장했을 때 테이블이 훨씬 더 많은 블락을 차지하겠죠. 
그렇죠 더 많은 면적을 차지한다는 얘기예요. 
더 많은 면적이기 때문에
참석자 1 
당연히 더 많은 군락을 읽을 것이고 그래서 마침 이 테이블에 이메인과 셀러론만으로 구성된 인덱스가 있을 경우에는 위쪽 거리는 인디스 마이 될 것이고 아래쪽은 테이블까지 가야 되니까 당연히 아이오 차이가 발생한 겁니다. 
근데 만약에 그런 이기스가 없다고 하면 부커리는 똑같다는 얘기예요.

참석자 1 
두 번째는 네트웍 트래픽을 고려하셔야 되는데 위에 쪽에서는 이네임과 셀러링은 그 아이오 적으로는 모든 칼럼을 다 읽었지만 클라이언트에게 보낼 때는 이메일과 셀러드만 보내죠 그죠 근데 아래쪽에서는 모든 칼럼 예를 들면 테이블에 칼럼이 00개면 200개를 다 보내요 네트워크 트래픽이 더 많이 발생할 수밖에 없습니다. 
노트 컬러는 다 보내놓고 그중에서는 클라이언트 쪽에서 이네임과 셀러리만 선택을 하는 거예요.

참석자 1 
그럴 필요 없죠. 그렇죠 피한 컬러만 전송받을 수 있도록 그렇게 코딩하셔야 되기 때문에 당연히 알타를 쓰면 안 되고 마지막으로 소트 공간의 차이가 있습니다. 
여기 오도바이가 있는데 오도바이가 있는데 데이터를 정렬할 때 위쪽에서는 일단 기본적으로 emp 테이블에서 셀러리가 2차보다 큰 데이터를 다 읽어야

참석자 1 
읽고 그중에서도 이메일과 셀러리 값만 가지고 소트를 합니다. 
소트를 할 때는 pga를 이용한다 그랬죠 아까 그렇죠 pj를 이용하고 pj는 메모리인데 메모리가 부족하면 디스크 템플 테이블 스크서 이용한다고 했어요. 
그 과정에서 얘는 2개 칼럼만 가지고 정리를 하기 때문에 훨씬 더 적은 공간이 필요한 반면에 아래쪽에서는 어때요 모든 칼럼을 다 갖고 정리 해야 되죠 칼럼이 만약에 500개면 500개 칼럼을 다 읽어서

참석자 1 
오00b 클럼 다 가지고 pga를 활용하고 부족하면 해피 탭을 쓰게 되니까 더 많은 메모리를 사용할 것이고 또 메모리가 부족하니까 디스크를 써야 될 가능성이 더 높아지겠죠. 
그 과정에서 성인이 늘어질 수밖에 없다는 그래서 당연히 아스타를 쓰시면 안 돼요 여러분들이 여태까지 알고 계신 것처럼 아스카를 쓰시면 안 됩니다. 
필요한 컬러 매칭 하셔야 되는데 적어도

참석자 1 
데이터베이스에서 데이터를 읽는 단계에서 아이와 하는 측면에서는 둘의 차이가 없다라는 거예요. 
둘의 차이가 아이와 하는 측면에서는 인덱스 구성이 딱 마침 이렇게 있는 경우만 아니라고 한다면 아래 측면은 똑같다라는 거죠.

참석자 1 
그래서 결론적으로 블라가이오 개수가 그 성능이다라는 얘기예요. 
블라가이 개수가 고 성능이다.
참석자 1 
그래서 여러분들 sql 성능을 측정하는 가장 중요한 성능 지표가 io예요. 
그런데 혹시 트윈 컨설팅 받아보셨어요. 
튜너들이 와서 튜닝을 합니다. 그러면 개발자분들에게 튜닝한 결과를 전달하죠. 
전달할 때 어떻게 전달할까요. 기존에 거리는 10초 걸렸는데 이렇게 히트를 주시면은 3초로 줄어듭니다. 
시간으로 할까요. 아이유로 할까요. 아이유를 한다는 얘기예요. 
왜냐하면 시간은
참석자 1 
그때그때 다르거든요. 운이 좋으면 메모리에서 입어도 빨리 끝나는 거고 운이 없으면 디스크 아이가 많이 발생해서 내리고 시간은 그대로 달라요 만약에 혹시라도 여러분들 그 튜너 중에 시간 기준으로 잡으세요. 
기존에 100초 걸렸는데 제가 할 때 하면 3초밖에 안 걸립니다. 
이렇게 하는 신호가 있으면 그 가짜 신호예요. 
엉터리입니다. 눈속임에 불과한 거예요. 
실제 해보니까 정말 3초 만에 끝나
참석자 1 
나중에 보니까 도로 10초로 늘어났어요. 
왜 히트이 안 좋아지면 다시 늘어지거든요. 
혹시라도 그런 식으로 트윈 가이드 전달하는 튜너가 있으면 그 사람은 가짜예요. 
가짜 치면입니다. 어떻게 되냐면 아이유 기준으로 해야 돼요 보세요. 
기존 코리대로 수행하게 되면 아이유가 100만 개죠. 
힌트를 이렇게 주거나 풀을 이렇게 바꾸면 아이오가 5천 개로 줄어듭니다. 
이렇게 하셔야 돼요 말씀드렸다시피 아이오는 고정 불변이에요.

참석자 1 
논리적인 인량은 변하지 않는다는 얘기예요. 
항상 입장하거든요. 그거 기준으로 기존에 100만 개였던 게 5천 개가 줄었습니다. 
해야지 정상적인 투어라는 얘기 그래서 우리가 성능을 측정하는 가장 중요한 성능 지표는 시간이 아니라 바로 바이오 백스라이에요.

참석자 1 
제가 어떤 경우를 봤냐면 예전에 이제 거래소 한국거래소 증권거래소죠 증권사 차세 변하는데 차세대 했던 업체가 우리나라에서 제일 많은 si 업체였어요. 
근데 프로젝트가 끝나면 공수를 받지 않습니까 사람들한테 검수를 받아요. 
기능적인 검수도 받고 성능이 잘 나오는지도 확인을 하고 그래서 사용자들이 화면을 딱 눌러서

참석자 1 
정상적으로 결과가 잘 나오는지 보고 또 속도도 제대로 나왔는지 검증을 합니다. 
그 검수할 때 제가 이제 우연히 봤는데 옆방에서 동료 개발자가 뭐하고 있는지 아세요. 
지금 검수하고 있는 그 화면을 막 조회를 하고 있는 거예요. 
옆방에서 왜 그럴까요. 메모리 메모리를 올려놓는 거예요. 
그 화면에서 있는 데이터들을 미리 눌러가지고 데이터를 막 올려놔요

참석자 1 
그럼 이쪽에서 이제 검수할 때 현압이 막 눌러보니까 정말 기능도 정상으로 잘 작동하고 성도 빨리빨리 나오는 거죠. 
오케이 통과 사인을 했습니다. 왜 사인한데 나중에 가서 눌렀는데 안 나와요 왜 그럴까요. 
피스카이가 일어나니까 외모에서 아까는 읽었는데 이제는 디스크 아이가 발생하니까 늦어지는 거예요. 
그러니까 왜 그런
참석자 1 
뭐라 할까요. 그건 운석이만 할까요. 
그죠 바로 그거예요. 아 아이 때문에 아이오가 상당히 좌우하기 때문에 그런 장난들 심을 제가 직접 본 적이 있습니다. 
그다음에 아까도 계속 말씀드렸다시피 옵티마이저가 판단하는 기준은 코스트라고 그랬죠 코스트 코스트가 곧 아이오다라고 말씀드렸고

참석자 1 
그러면 이 실행계획에 나온 코스트가 무엇이냐 아까도 제가 이미 말씀드렸는데 코스트가 뭐라고 했습니까 아이오 콜 횟수 예상되는 아이오 콜 횟수 이 sk를 이 방식으로 시행할 때 예상되는 아이오콜레스를 구한 거예요. 
인덱스를 스캔하는 단계에서의 26번의 아이오콜이 발생할 것이다. 
예상하는 것이고 태프까지 가는 과정에서 800개가 더해져서 총 826번의 아이유 콜이 발생할 것으로 예상을 한다는 얘기입니다. 
근데 보시면
참석자 1 
아이오 코스틱 모델이 있고 cpu 코스틱 모델이 있죠. 
감사한 모델인 건 아이오 코스틱 모델이에요. 
전통적인 과거의 방식입니다. 지금은 cpu 코스팅 모델을 주로 사용합니다. 
그래서 아이오를 그냥 콜 횟수로 하는 것이 아니고 그 아이오를 시간으로 환산을 해요. 
그런데 그 시간이라고 하는 것이 절대적인 시간 예를 들면 826초 26초가 아니고 상대적인 개념으로 어떤 상대적인 개념이냐면

참석자 1 
싱글 블록 아이오 기준의 시간 아니라고 표현하는 거예요. 
아이오에는 디스크라이는 두 가지가 있거든요. 
싱글 블록 아이오가 있고 멀티 블록 아이오가 있어요. 
다음 시간에 설명드릴게요 그래서 싱글 블랙 아이가 있고 멀티 블라 아이가 있는데 우리 시스템에서 싱글 블랙 아이요 하는 시간을 기준으로 26번 싱글 블랙 하이 아이오 하는 정도의 시간 전체적으로 826이니까 826번 싱글 블록 아이오하는 시간

참석자 1 
시스템마다 싱글 블라가 시간이 다 다르거든요. 
예를 들면 시스템 통계라는 것인데 그게

참석자 1 
아직도 연결이 안 되시네
참석자 1 
요게 시스템 통계를 보는 뷰예요. 시점 52 x 점 10점 달라 여기 보시면 시스템 통계를 조회를 해보니까 우리 시스템에서의 cpu 속도 우리 시스템에서의 싱글 블라우 리드 타임 멀티 블라우 리드 타임 이런 것들이 미리 계산이 돼 있어요. 
지금 이제 수집을 안 해서 답이 없는데

참석자 1 
저거를 미리 수집해 놓을 수가 있거든요. 
싱글 블라 하는 시간 멀티 블라가이 하는 시간 시피 속도 또 멀티 블라가이 계 이런 것들을 시대 통계적으로 미리 계산 갖고 있는 거예요. 
그래서 시스템마다 다 다르다라는 얘기죠 아이요 속도가 키피 속도도 다르고 싱글 블라 가요 시간도 다르고 멀티 블라 아이오 시간도 다르고 다 다르다는 얘기죠

참석자 1 
다르기 때문에 절대적인 시간으로 얘기할 수가 없는 거예요. 
파리 스템이 있고 느리스템이 있는 거니까 그래서 절대적인 26이 짧고 26 26초가 아니고 보일 시스템에서 26번 싱글 블락 아이 하는 정도의 시간이 걸릴 것으로 오티마는 예상한다 전체적으로는 826번 팀플 블록 아이오 하는 정도의 시간이 걸릴 것으로 오키마이어는 예상을 한다는 의미예요.

참석자 1 
이해되십니까 되게 어려운 얘기인데 제가 되게 친절하게 설명을 드렸는데 어때요 이해되시나요. 
이해가 되시는 분
참석자 1 
거의 다 이해가 되셨네요. 그렇죠 손 안 드신 분은 아마 쑥소로 손을 안 드신 걸로 그렇게 저는 이해를 하겠습니다. 
멀티 블랙 아이오를 하더라도 그거를 싱글 블랙 아이 그렇죠 맞습니다. 
멀티 블랙 아이 아이 하더라도 그것을 싱글 블랙 아이오 시간으로 탄산을 해서 계산하는 값이에요. 
싱글 블라가 뭐냐 멀티 블라바이어가 뭐냐는 뒤에서 나오죠 그죠 그래서 나오는데 우선 이제 그 정도 개념으로

참석자 1 
설명드리겠습니다. 그래서 다시 강조드리지만 블랙 아이오가 성능이다. 
그걸 기억하시면 되겠습니다. 더 진도를 나가고 싶은데 시간이 다 됐네요. 
그렇죠 질문 있으시면 질문 받고 지금 오늘 여기서 마치도록 하겠습니다. 
질문 예 보세요. 혹시 비비 블록 사이즈 말고 오스 블록 사이즈에

참석자 1 
당연히 영향을 받죠. 근데 월스까지 내려갈 필요는 없을 것 같고요 월스 단에 그래서 오라클레 블록 사이트 8kg인데 오라클 단에서의 논리적인 또 다이고 그것이 이제 내부적으로 들어가면 원스트라스 아이오가 스타일이 또 달라요 당연히 그거에 영향을 받죠. 
내가 8k로 가트로 아이오콜를 했는데 그것이 내부적으로 더 쪼개져서 더 잘게 근데 ost는 더 큰데 일반적으로

참석자 1 
오라클이 8%지 않습니까 근데 오스타에서는 기본적으로 1메가 단위를 보통 많이 하고 최근에는 버크 사이즈로도 아이가 하긴 해요. 
오히려 더 오스가 더 큰 단이라서 오스 기본적으로 차이가 없을 것 같고 이제 나중에 설명드릴 멀티 블랙 아이오 또 할 수 있거든요. 
그때는 사이즈의 영향이 있을 것 같습니다. 
신경 안 써도 될 것 같아요. 일단은 그거는 어쨌든 그거는 고정된 거니까

참석자 1 
거기까지 우리가 들어갈 수 없을 것 같고요 기본적으로 싱글 플라 기준은 차이가 없어요. 
왜냐하면 여러분 8kg인데 50단은 기본적인 1메가 단위로 하니까 차이가 없다고 보시면 될 것 같습니다. 
또 다른 질문
참석자 1 
근데 또 저거는 있어요. 여러분들 여기 스트라이핑을 많이 하지 않습니까 디스크를 스트라이핑을 하기 때문에 노라 페기는 8k로바이트인데 저 디스크 레이어로 내려가게 되면 그것이 또 작게 쪼개져 있어요. 
자기 줄겨져 있어요. 실질적으로는 스트라이핑을 더 잘게 쪼 있기 때문에 그것 때문에 또 차이가 있을 수 있겠는데 거기까지 가 너무 깊이 있는 그거는 이제

참석자 1 
sa 레벨 시스템 어드민 레벨에서의 어떤 연보인 거고 우리는 지금 sq 레벨에서 형상을 보는 거기 때문에 그 레벨까지 들어가서 의미는 없을 것 같습니다.

참석자 1 
많이 지나가는 거 다 이 스타팅하죠. 
모든 스텝
