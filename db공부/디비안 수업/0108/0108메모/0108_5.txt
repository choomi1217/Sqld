참석자 1 
그 실행기 분석하는 방법 좀 알려주세요. 
이 점이 꼭 나옵니다. 제가 이제 여러분들 마지막 날 설명드리려고 만든 여러분 그제 맨 마지막 뒷페이 한 여러분 맨 마지막 맨 마지막 날 설명 드리려고 했던 내용인데 얘기가 나온 김에 좀 말씀을 드려볼게요 그런 질문을 가장 많이 받는데 실행계획 설명하는 방법

참석자 1 
저도 모르니까 어떻게 알려드리겠습니까 저도 모르겠어요. 
실행 이는 방법은 예를 들면 우리가 아직 nlg는 안 배웠지만 여러분들이 이제 미리 공부하시는 분들이 이런 거 많이 들어보셨을 거예요. 
위에서 아래로 그니까 그니까 시블링 노드 형제 너들끼리는 위에서 아래로라는 얘기가 부모 자식 간에는 안에서 바꾸어 자식 투서 읽으라는 얘기야 그러면 위에 슬기는 어떻게 읽어야 돼요

참석자 1 
이거 이제 이게 2번과 3번은 같은 노드에 있으니까 자식부터 읽어야 되겠죠. 
그러면은 3을 제일 먼저 읽고 그다음에 2번을 읽어야 되겠네요. 
그렇죠 3 2 그다음에 5 4 1 이렇게 해석하시죠 보통 그죠 32 54 1 이런 식으로 해석합니다. 
그럼 그렇게 해석하시면 밑에 두 번째는 어떻게 해석하시면 될까요.

참석자 1 
4 3 2 1이 되겠네요. 그죠 그럼 그렇게 해석하면 맨 밑에 거는 4 3 어떻게 됩니까 5 2 6 1이 되나요. 
예 아무튼 근데 사실 이 3개 hp는 다 똑같은 지킬에요. 
같은 방식으로 시행이 됩니다. 맨 위에 거는 전통적인

참석자 1 
에네이션 실행 계획을 표현한 것이고 두 번째는 프리테치라는 어떤 내부적인 어떤 그런 메카니즘이 작동하는 것을 표현한 것이에요. 
맨 마지막은 배치 아이가 작동한다는 걸 표현한 것에 불과한 것이고 이 3개의 에스크은 정확히 똑같이 시행됩니다. 
똑같은 방식으로 이거 보실까요. 이거 어떻게 해석될까요.

참석자 1 
쭉 안으로 들어가죠. 그러니까 자식부터 겠죠. 
4 3 2로 해석합니다. 그렇게 실행되지 않아요. 
얘는 9번으로 표현하면 2 4 3 1입니다. 
이 쿼리에 대한 실행 계획이거든요. 우리가 아직 ng는 우리가 그거는 아직 안 배웠고

참석자 1 
서브컬이라든지 이러면 안 좋겠지만 아직 이거 설명드릴 단계는 아닌데 아무튼 그런 식으로 번호로 해석하게 되면 오히려 잘못 해석하게 된다는 걸 제가 지금 말씀드리는 거예요. 
여러분들이 그런 책들을 보고 그 책 제목이 뭐였더라 무슨 오라클을 위한 초보자를 위한 개발자를 한 베스트이 그 책이 있거든요. 
얇은 책인데 그 책에 보면 딱 그렇게 설명하고 있어요. 
저 숫자 가지고
참석자 1 
숫자 가지고 설명하고 있습니다. 제가 가서 책 이렇게 봤거든요. 
그렇게 공부하신 분들이 망치는 거예요. 
잘못 이해하시는 거죠. 제 시험도 이런 거 나오잖아요. 
문제입니다. 그래서 근데 피해는 그런 거 없잖아요. 
오히려 뒤쪽에 나 뒤는 제가 출가하지 않았거든요. 
뒤쪽은 제가 관여하지 않았어요. sbs 쪽에 어떤 분이 출가했는데

참석자 1 
제가 그거에 대한 문제의 제기를 몇 번 카페에서도 했어요. 
sq b에서 sk 실행 순서를 또 어떻게 설명합니까 앞에 여기 설명 안 했지만 레스케를 이런 식으로 설명하죠. 
레시케 어떻게 진행합니까 프럼절 실행하고 그다음에 웨어절 그룹 바이 헤딩 세 이렇게 한대요 몇 시에 이렇게 시행이 됩니까 이게 말이 돼요. 
프럼 저부터 시행한다는 얘기는 예를 들면

참석자 1 
emt랑 벨트를 하면은 둘을 먼저 카트 을 만들어 놓고 그죠 이자에서 카트 곡을 먼저 만들어 놓고 그다음에 필터링한다는 얘기네요. 
거기서 또 말이 안 되는 거예요. 저는 길게 시들지 않습니다. 
k 아까 말씀드린 대로 어떻게 실행할지는 옵티마이저가 동적으로 결정하는 것이지 프로지 먼저 실행하고 조건별 실행하고 그다음에 그룹 파일로 헤딩 헤딩하고

참석자 1 
셀렉트는 나중에 오토바이 한다 말도 안 되는 얘기거든요. 
이거 만약에 인덱스를 타게 되면 오토바이를 제일 못 처리하는 거예요. 
인덱스 타면서 오더바이를 여기서 배치하게 되면 이것도 말이 안 되는 얘기입니다. 
근데 이 예수 교리에서 이렇게 설명이 있거든요.

참석자 1 
그래서 이거는 실제적인 sql의 실행 순서가 아니고 논리적인 어떤 창조 관계에 있어서 선행 관계를 표현한 거예요. 
창조 관계에 있어서 수험절에 선언한 것을 온전해서 참조할 수 있고 온에서 선한 걸 조인해서 조인해서 선한 걸 그니까 위에 거를 아래쪽에서 참조할 수 있다는 얘기죠 위에 거를 아래쪽에서

참석자 1 
그런 어떤 성의 관계를 표현하기 위한 어떤 논리적인 표현이지 이게 실질적인 실행사와는 무관하다는 얘기예요.

참석자 1 
이 문서가 전혀 근거는 없는 거 아니고 이게 어디 나왔냐면 msc컬 서버의 msd의 라이브레에 나오는 얘기예요. 
근데 거기는 분명히 가르키고 있어요. 
이것은 실제 실행 순서가 아니고 논리적인 선행 관계의 창조 관계에 있어 선행 관계를 표현하기 위한 논리적인 표현이다라고 딱 설명을 하고 있거든요. 
근데 그걸 누군가가 그걸 실행 순서라고 갖다가 딱 누군가 책을 쓰고 누군가 그렇게 교육을 하고 하면서 이거 실제적인 sk의 실행 순서처럼 사람들이

참석자 1 
인식을 하고 그렇게 공부하고 심지어 sql 기회도 그렇게 시험 문제를 내고 풀고 그리고 이걸 외우고 있다는 얘기잖아 그거 실제 시행성와 전혀 무관한 거예요. 
논리적인 선행의 관계 사도 측면에서의 그걸 밝힌 겁니다. 
그리고 실행 계획상에서 이 번호도 말씀드린 것처럼 그렇게 해석하시면 안 된다라는 얘기예요. 
얘도 그렇고 얘는 어떻습니까 얘는
참석자 1 
위에서 아래로 하게 되면 2 1 4 3 6 5가 되겠죠. 
그죠 근데 얘는 스칼라 서브크릿 이는 기획입니다. 
정확히 얘기하면 65가 먼저 실행이 돼요. 
65가 위에서부터 2 1 4 3 6 5가 아니고 65가 먼저 왜냐하면 65가 메인 콜리거든요. 
메이커이고 위쪽에 있는 분들은 스칼라 서브 커리예요.

참석자 1 
스카라 서프커는 메이커를 실행하면서 뻔뻔히 실행하는 거지 않습니까 스카라스크 실행 계획이거든요. 
근데 그런 식으로 공식으로 외우게 되면 잘못 해석하는 거죠. 
이것도 실제로 그런 질문이 나왔던 사례입니다. 
이게 어떤 분이 카페에다 질문 올린 글인데 자기가 배운 걸로 위에서 바로 해서 하니까 1 2 3 4 5로 해석이 된다는 거죠. 
근데 실질적으로는 아랫부분이 제일 먼저 실행이 되는 거거든요. 
잘못
참석자 1 
이해하게 되는 대표적인 사례죠 얘는 어때요 해시인을 하게 되는데 우리가 해시 안 배웠으니까 얘 좀 설명하기 부족한데 우리 이거 하시면 나중에 배우면서 말씀드릴

참석자 1 
여러분들 우리 영어 배울 때 영어 배울 때 우리 중학교 때 다섯개 배웠지 않습니까 어떻게 해석했습니까

참석자 1 
톰은 햄버거를 좋아한다 주어 먼저 해석하고 목적어 동사 이렇게 해석돼 있죠 그렇죠 이런 게 중학교 때는 통해요. 
중학교 1 2학년 때는 통하는데 고등학교 가면 어떻게 됩니까 이렇게 되죠. 
그죠 만약 번역식 도끼를 하게 되면 어떻게 됩니까 나는 방법이 없어요. 
그렇지 그냥 어떻게 해야 돼요 직독을 해야 되죠

참석자 1 
나는 이해한다 미스터 윤이 컨택을 했고 너를 컨택했고 어떤 이렇게 해야 되지 않습니까 그죠 직독 해야 된다는 얘기죠 직독직해 폼은 좋아한대요 햄버거를 나는 안다 윤 씨가 어제 전화로 당신에게 연락한 사실을 그가 받은 청구서와 관련하여 9월 16일에 이런 식으로 도 집계를 했다는 거예요. 
실행 계획도
참석자 1 
번역식 도회 하듯이 그렇게 공식으로 하려고 하면 대부분 다 안 맞습니다. 
그래서 여러분들 우리 영어 잘하려고 그러면 숙어를 많이 공부해야 된다고 하지 않습니까 숙어 관영적 표현들을 많이 익혀야 된다 영어를 잘하면 숙어를 그런 얘기 숙어를 많이 해야 된다 그래서 얘기가 나오는 거예요. 
저도 지금까지 10년 넘게 신해와서 굉장히 많이 플랜드를 봤지만 플랜을 해석하는 방법을 설명하라고 하면 설명 못해요. 
저는
참석자 1 
경험에 근거한 규칙이 있을 뿐이에요. 
경험에 근거한 규칙 많이 분석하는 과정을 통해서 경험적으로 알게 되는 것들 그래서 다시 말씀드리지만 이 실행 계획이라고 하는 것은 어떤 절차 프로시저죠 프로시저를 논리적인 틀의 구조로 표현한 것이기 때문에 정확히 표현하지 못하는 한계가 분명히 있다라는 사실이에요. 
그걸 알고 이해하셔야 돼요
참석자 1 
그래서 지금 지금 설명드린 내용이 카페에 제가 원래 올렸던 겁니다. 
325번 1693원 다시 한번 읽어보세요. 
설명 드렸던 내용들이 카페에 그대로 글이 있으니까

참석자 1 
튜닝을 좀 쉽게 배워볼까 싶어서 들어왔는데 점점 어려워지죠 그렇죠 점점 어려워지는 느낌이 드실 거예요. 
저도 사실은 여러분들 튜닝을 교육 들어오시는 목적 자체가 튜닝이 어려우니까 들어오셨을 텐데 저는 거꾸로 튜닝이 어렵다는 사실을 알려드리고 싶어요. 
여러분 어렵다는 사실 어렵기 때문에 단기간에 누가 속성으로 하려고 하지 마시고 제대로 정석으로 정석을 밟아라

참석자 1 
그 얘기를 하고 싶어요. 저는 속성을 할 수 있는 방법이 없습니다. 
실제로 그런 방법이 있었으면 저 같은 사람이 먹고 살겠습니까 다 춤 잘해서 저기 하는 밥 그만 밥 못 먹자 여자 그래서 이거 이제 나중에 한번 제가 조인을 하고 나면 그때 다시 한 번 이제 말씀드리기로 하고 오늘 이제 저희가 남은 시간에 해야 될 내용은

참석자 1 
어쨌든 이제 이미 트링을 해보신 분도 계시고 stp에 도전해 보신 분도 계시지만 아까 우리가 설문에서 보신 것처럼 대부분 트레이스들을 한 번도 안 해보신 분들이 대부분이고 그러니까 그런 내용들을 먼저 좀 다루고 넘어가도록 하겠습니다. 
설계를 어떻게 하고 나고 스트레스는 어떻게 확인하는지 그런 내용들을 설명드리도록 하겠습니다. 
1장으로 가겠습니다. 1장
참석자 1 
stl 분석 도구에 대한 내용들이 나왔는데

참석자 1 
저도 이제 나이가 이제 좀 되고 또 특히 저희 부모님들이 이제 연루하시니까 이제 부모님을 모시고 병원을 자주 가게 되고 저도 이제 병원에 자주 가게 되더라고요 저도 사실 이 몸이 좀 안 좋은 편인데 병원에 갈 때마다 느끼는 거는 의사들의 어떤 의료 행위와 저 같은 어떤 튜닝하는 사람들의 어떤 진단 취하는 행위들이 많이 비슷하다는 생각을 그걸 병원에 갈 때마다 합니다. 
우리가 병원에 가게 되면
참석자 1 
어떤 절차가 있죠. 그죠 무조건 병원에 가면 1번 mri 찍는 거 아닙니다. 
그죠 병원에 가면 게 우선은 청진기로 이렇게 진단한다든지 혈압을 재보기도 하고 정형외과나 외과 같은 데 가면 엑셀을 찍어보기도 하겠죠. 
우선 이제 가볍게 진단을 해보고 그렇게 해서 원인이 찾아지면 다행이지만 그렇지 않으면 좀 더 정밀한 진단을 하게 되죠. 
혈액 검사를 한다든지 아니면 아니면 초인 초음파를 찍어온다든지 그렇게 해서도 병의 원인이

참석자 1 
바뀌지 않으면 이제 그때 ct 촬영도 하고 mri 촬영도 하게 됩니다. 
그런 것처럼 sk을 분석할 때도 10번 그냥 트레이스 걸고 이렇게 하는 게 아니고 단계적으로 하는 거예요. 
그래서 청진기나 혈압 측정에 해당하는 것이 익스플레이 플랜입니다. 
실행 계획을 확인하는 거죠. 여기서 말한 실행 계획은 예상 실행 계획입니다. 
예상 실행 계획
참석자 1 
그다음에 이제 혈액 검사나 초음파에 해당하는 것이 오토 트레이스 마지막으로 ct나 mri에 해당하는 것이 sk 트레이스 내지는 이벤트 트레이스입니다. 
그래서 이 스킬 트리스랑 이벤트 트리스가 스케일의 가난한 가장 디테일한 정보를 보여줘요. 
이거보다 더 디테일한 정보를 보여주는 정보는 없습니다. 
그래서 여러분 sql 튜닝은 트레스 분석 과정이라고 보셔도 될 정도로 트리스가 분석이 굉장히 중요합니다.

참석자 1 
이 크리스 부족 과정을 생략할 수 없습니다. 
여러분들 ct나 mri 해석할지 모르는 의사가 있을 수 없지 않습니까 그죠 그런 것처럼 에스큘 프레이스가 어려워서 복잡하다 나는 이것만 가지고 트윙하겠다. 
또 이것만 가고 트윙하겠다. 이건 불가능하다는 얘기예요. 
어렵더라도 반드시 에스큘 프레이스의 선을 넘어가셔야 됩니다. 
그래서 제 교육의 가장 핵심은 sql 프레스 분석이에요. 
다른 분이 교육을 받고 가시면서
참석자 1 
제일 만족했던 부분들을 뽑으라 하면 에스트 프레스에 대한 분석 기법을 정확히 이해할 수 있게 됐다라고 이렇게 평가를 했습니다. 
그래서 오늘 시험 시작한 내겠지만 아직 우리가 sq 트레스까지 못 받고 이제 시작하지만 오늘 이후에 다음 주부터 계속해야 될 내용들은 sp 트스 분석입니다. 
그렇게 분석을 했으면 병명을 이제 확인을 하고 약을 처방하기도 하고 기저기 시술을 하기도 하고 심할 때는 절개 시술을 하지 않습니까 그런 것처럼

참석자 1 
게스크를 전환하기도 하고 힌트 제일 쉬운 건 힌트예요. 
그렇죠 힌트 하나면 딱 세팅하면 갑자기 느리는 소리가 갑자기 빨라지기도 하고 고통스러운 건 인덱스를 조정해야 될 때입니다. 
인덱스를 추가하거나 변경하면 당장 내 콜이 빨라지는데 또 다른 예상치 못한 다른 퀄들이 늘어지는 현상들이 생길 수가 있거든요. 
그렇기 때문에 되게 조심스러운 작업입니다. 
인데스를 추가하고 변경한 것은
참석자 1 
굉장히 조심스러운 작업이고 변경 영향도를 많이 분석을 해서 하셔야 돼요 그래서 되게 조심스러운 작업이고 또 심할 때는 테이블을 구조를 바꿔야 되겠죠. 
반정기를 한다거나 아니면 별도의 직계 패를  만든다거나 모든 커리가 다 인덱스만으로 이 되는 건 아니거든요. 
이렇게 반정 교화를 하고 별도의 직계 쪽을 만들어서 테이블 구조를 바꾸는 거죠. 
이런 절차를 거쳐서 팀을 하게 되있고
참석자 1 
가장 기초적인 진단은 이제 예상 실행 계획 분석입니다. 
예상 실행 분석을 하려고 하면 먼저 플랜 테이블이 만들어져 있어야 돼요 플랜 테이블이

참석자 1 
프렌셉을 만들어야 되는데 이건 시간 관계상 넘어가겠습니다. 
왜냐하면 기본적으로 팬지 입으로는 프레드 업이 기본적으로 만들어져 있거든요. 
만들어져 있기 때문에 그걸 그냥 쓰시면 돼요 그래서 시스 밑에 시스 밑에 플랜 테이블 달러라는 테이 이미 만들어져 있어요. 
만들어져 있고
참석자 1 
그 테이블을 참조하면 퍼블릭 신원이 만들어져 있기 때문에 이것을 그대로 사용하시면 돼요 만드는 것 까지 설명 안 드리겠습니다.

참석자 1 
다만 아셔야 될 것은 이 플랜이 이게 오렌지나 푸드나 이런 데 때 잘 안 보이는 경우가 있어요. 
플랜이 잘 안 보이죠. 왜 안 보이냐 여기 세팅하도록 돼 있거든요. 
플랜 데이브를 오른쪽 같은 경우 여기 보시면 인바이어먼트에 가보면 여기 프렌테 에브를 이 지정하도록 돼 있어요.

참석자 1 
이게 제대로 지정이 돼 있지 않으면 트레이 안 나오는 거죠. 
그래서 여기 찾아가셔서 시스점 플랜 언더바 테이블 깔라라고 테이블을 지정을 해 주셔야 되는 거예요. 
시약이 잘 안 나오면 원인 중에 가장 대표적인 게 플라테이블이 잘못 추정돼 있거나 정해 있지 않을 때가 있거든요. 
그래서 그걸 찾아서 커리틀에다가 플래스테이블의 위치를 정확한 위치를 이렇게 지정을 해 주시면 됩니다. 
그래서 말씀드린 것처럼
참석자 1 
시스 밑에 플랜트 백을 달러가 이렇게 만들어져 있으니까 얘를 참조하도록 그렇게 지정을 해 주시면 되겠습니다.

참석자 1 
이렇게 프랜트을 만들고 나서 익스플레인 플레이라는 명령을 통해서 코리를 이렇게 시행을 하게 되면 이 코리의 실행 계획이 플랜 테이블에 저장이 돼요. 
플랜 테이블에 이렇게 저장이 된 것을 조회를 해보면 이렇게 나와요 테이블이에요. 
테이블 테이블에 저장이 된 것이고 전혀 포맷 되지 않은 상태로 이렇게 나옵니다. 
그래서 얘를 포맷팅을 해야 되겠죠.
참석자 1 
예전에는 우리가 이것을 커메팅하기 위해서 커미팅하는 커리들을 막 들고 다니면서 배를 이용했었는데 지금 그럴 필요가 없는 게

참석자 1 
에스큐 플러스 기준으로 말하면 이 스크립트를 실행을 하면 됩니다. 
이 스크립트를 실행하게 되면 그 플랜트를 읽어서 이렇게 예쁘게 플레팅을 해줘요. 
이리 이 스크립트 여러분들 그 안에 이렇게 저장이 돼 있습니다. 
이렇게 이거 실행하는 거예요. 그래서 여러분들 이거 그대로 그냥 갖다 쓰시면 돼요 파이팅 하셔도 된다는 얘기예요. 
이 리 리 에스케 플래스에서 이렇게 하죠. 
예를 들면 에스케 플래스에서 익스플레인

참석자 1 
스플렌코 텔렉트 이엔피 이렇게 하시고 나서 이렇게 하시고 나서 여기 있는 것처럼 알 dbms 어드민 btl ft레스 이 골뱅이는 스크립트를 실행하라는 뜻이고 무릎표는 오라클 홈을 의미하는 거예요. 
무릎표는
참석자 1 
원래 그 코 밑에 rd 드메스 밑에 어둠 밑에 uta x pls라는 스크립트를 실행해라 그런 것이죠. 
근데 얘를 딱 열어보면 이 문장이 들어가 있어요. 
이렇게 스크립트에 보면 이걸 그냥 갖다 시행해도 된다는 얘기예요. 
여러분 여기서
참석자 1 
플레이 플랜 또 이렇게 하고 얘를 그냥 이렇게 실행하면 된다는 얘기죠 무슨 얘기지 아시겠죠. 
스크립트에 있는 것을 취할 수 있고 그 스크립트에 있는 내용이 이거니까 이거 갖다 그대로 쓰셔도 된다.

참석자 1 
이렇게 지금 머릿속에 시행 계획을 굳이 저렇게 어렵게 볼 필요가 있나 나는 이미 저렇게 안 하고 보고 있었는데 어떻게 보면 돼요

참석자 1 
오렌지 기준을 말하면 컨트롤 인으로는 되죠. 
그죠 컨트롤 인으로는 그냥 실행이 나와요 그죠 여러분들이 설치한 커리 박스에서도 마찬가지고 커리 박스에서도 이렇게 해놓고 컨트롤 이 누르면 툴마다 명령은 또 다르니까 그렇죠 컨트롤 이네요.

참석자 1 
접속이 종료됐네요.
참석자 1 
커리 박스에서도 그 컨트롤 2 누르면 시는 이 나오는 거예요. 
그리고 이 커리툴들이 아까 말씀드린 익스플레인 플랜을 돌리고 그 결과로서 테이블에 저장된 플랜대로 저장된 정보를 읽어다가 포미팅 해 주는 역할을 얘가 대신해주는 거예요. 
커리 툴들이 무슨 얘기지 아시겠죠. 그래서 여러분들이

참석자 1 
그래서 이렇게 쿼리 트롤에서 그냥 컨트롤 기 눌러서 쉽게 확인하는 방법이 있지만 그럼에도 불구하고 여러분들이 아까 제가 설명드린 이 방법들을 활용할 줄 아셔야 돼요 트인 전문가가 되려고 하면 왜냐면 쿼리툴들은 기본적인 정보밖에 안 보여주거든요. 
근데 플랜 테이블에는 여기 보여지는 정보 말고도 훨씬 더 다양한 정보들을 수집해서 갖고 있어요. 
그런 정보들을 다 보고 싶은 거죠.
참석자 1 
근데 컨트롤에서 보여주는 정보만 보면 그런 정보를 확인을 못하는 거예요. 
예를 들면 아까 여기서 우리가 이렇게 했지만 얘를

참석자 1 
여기다가 옵션들을 다양하게 줄 수 있거든요. 
cdr이 아니라 아웃 라인 보겠다. 아웃트라인 정보를 보겠다. 
또 이런 정보들이 보인다는 얘기죠 아웃트라인 정보들이 그러면 엘리어스 정보를 보겠다. 
엘리스 성분이 커리 블락 관련된 이런 것들이 나오고 모든 걸 다 보겠다. 
아니면 어드벤스드를 보겠다.
참석자 1 
훨씬 더 다양한 동물들이 보여지거든요. 
이렇게 그렇죠 또는 모든 걸 다 보겠다. 
올 옵션을 어떻게 주느냐에 따라서 더 많은 풍성한 정보를 볼 수 있는데 만약에 커리트론에서 제공하는 이런 컨트롤 이 명령을 쓰게 되면 그냥 기본적인 정보밖에 못 보는 거예요. 
좀 더 고급 레벨로 가려다 보면 아웃프라인 정보라든지 또는 커리 블록 레인이라든지 이런 정보를 활용할 때 아셔야 되는데 그런 걸 활용을 못하게 되시는 거죠. 
그러니까 여러분들이
참석자 1 
기본 저도 평상시에는 그냥 컴프롤이 써요. 
컨트롤이 쓰지만 좀 더 분석을 하려고 할 때는 sk 플러스로 들어가서 이 명령을 이용해서 옵션들을 조절해가면서 내가 필요한 정보들을 선택적으로 보게 볼 수밖에 없다는 얘기죠 이런 활용점들을 알고 계셔야 됩니다.

참석자 1 
그래서 이런 식으로 실행 계획을 확인하는데 이 실행 계획은 어디까지나 예상 실행 계획입니다. 
예상 실행 계획 예상을 강조하는 이유는 실제 실행될 때 이것과 다르게 실행될 가능성이 있다는 얘기예요. 
100% 거의 대부분 99%는 같습니다. 
같지만 간혹 다르게 실행될 수도 있다라는 거죠. 
그래서 어디까지 이것은 예상 실행 계획이다라는 거

참석자 1 
그래서 이 실행 계획을 통해서 테이블을 풀 스캔 하는구나 아니면 인디스를 스캔 하는구나 인디스를 탄다고 하면 어떤 인디스를 타는구나 조인을 한다고 하면 어떤 조인을 하는구나 이런 것들을 우리가 판단할 수가 있는 것이고 그걸 통해서도 허리가 느린 원인을 파악할 수 있겠습니다만 대기는 쉽지 않습니다.

참석자 1 
실제적인 취임을 하려고 하면 내가 짠 커리의 실제적인 일량을 확인할 줄 알아야 돼요 내가 짠 커리가 아이오를 100만 개를 내는지 10만 개를 치는지 화면은 단락 10개의 레코드가 출력이 되는데 10개의 레코드를 출력하기 위해서 내부적으로 얼마큼의 많은 블록들을 읽고 있는지를 아셔야 된다는 얘기죠 그것을 확인하기 위해서 사용하는 게 바로 오토 프레이스입니다. 
오토 트레이스 에스클 프로트 지금 말씀드리면

참석자 1 
셋 오토 페이스 온이라는 명령을 실행하고 그다음에 이어서 에시피를 실행하시면 돼요 한번 해보실까요. 
해보세요. 로스테스 치시고 여기 있는 명령어 대로 그대로 셀라 아스타 19.2mp 왜어 emp에너 이콜 750이다. 
이렇게 쳐
참석자 1 
에스큐 플러스를 못 키우는 분 계실까요. 
여기 도스로 들어가셔서 도스로 들어가셔서 에스케 플러스 노 로그 이렇게 하시면 돼요 노 로그 노 로그는 뭐냐면 sk 플러스랑 프로그램은 띄우는데 로그인을 하지 말라는 얘기야 로그인하지 말고 플러스만 띄운 거고 그 상태에서 커넥트

참석자 1 
코 예를 들면 에뷰 00 에뷰 00 뭐 있죠 그다음에 네 이런 식으로 로깅을 하시면 됩니다. 
이렇게 아까 써주신 분
참석자 1 
저기 제가 한 대로
참석자 1 
보트로 들어가시고요 이거 하셔도 돼요. 
이거 하셔도 되는데
참석자 1 
확인
참석자 1 
체스 세팅 하셨습니까 포켓 세팅 안 하시면 좋고요 케 세팅을 먼저 하셔야죠

참석자 1 
여기 눌러볼까요. 눌러보시고 브라크 아니면 여기 뭐가 또 있을까요.

참석자 1 
네 매니저 강사님 화면 혹시 같이 볼 수 있을까요. 
그리고 팀에서 설명 없이 그냥 다 직접 입력하고 허리 팝스 에스크 버스가 안 드시는 분들은 이거는 따로 공부하셔야 돼요 이건 오라클 접속에 관련된 문제거든요. 
저희가 지금 튜닝을 공부하는 거지
참석자 1 
오라클 접속 방법을 제가 지금 설명드리는 것은 좀 시간 남길 수 있을 것 같아서 우선은 이따 쉬는 시간에 보기로 할게요 지금 이걸 하게 되면 미리 세팅을 다 해 오신 분들이 계속 기대하셔야 되니까

참석자 1 
그렇게 접속 방법은 우리 인터넷 조회서 번호 다 나오잖아요. 
pns 세팅 하는 법 pns로 세팅하셔야 되거든요. 
그래야지 이게 가능해요. 그게 아이디 패스워드만 입력해버리면 지금 db가 지금 어디에 어느 db에 붙을지가 지금 현재 지정이 안 된 상태지 않습니까 그 어느 db에 붙을지를 피 세팅을 통해서 네임을 지원하는 것이고 그 네임을 입력을 해서 그 네임이 가르키고 있는 db에 접속을 하게 되는 거거든요. 
근데 트레이스 세팅 없이 그냥 아이피 패스워드만 입력하면 어떤 db에 붙지

참석자 1 
내 로컬에 있는 db에 붙을 건지 아니면 저 멀리 원격에 있는 db에 붙을 건지 그게 지정이 안 된 상태니까 당연히 로그인이 안 되겠죠. 
그래서 피 세팅을 먼저 하셔야 돼요 트레세트를 어떻게 해야되냐 그러면 이제 그거는 좀 따로 좀 인터스를 찾아보시면 쉽게 알 수 있거든요. 
tns 세팅하는 데 필요한 정보는 제가 보내드린 거고 지금 안 되시는 분 tns 세팅 안 하신 분

참석자 1 
한 분 두 분 많이들 안 하셨네요.
참석자 1 
지금 그걸 우리가 지금 설명할 수는 없을 것 같고 쉬는 시간에 좀 따로 설명드리도록 하겠습니다.

참석자 1 
우선 이제 물론 에스큐 플러스 없더라도 요 똑같은 내용들을 커리 박스에서 커리 툴드에서 확인할 방법이 있으니까 그거 좀 이따 알려드릴게요 해보신 분은 아시겠지만 오토테스를 활성화시키고 sq를 실행하게 되면 제 3자는 skl 결과가 나오고요 그다음에 실행 계획이 나옵니다. 
실행 계획 그다음에 그 밑에 보면 실제 실행 통계가 나와요 실행 통계 이 sk를 실행하는 과정에서

참석자 1 
실제적인 일량 아이오가 얼마큼 발생했고 그중에서 메모리에서 얼마큼 읽었고 디스크에서 얼마큼 읽었고 클라이언트와 네트워크 간의 데이터를 얼마큼 주고받았고 메모리를 소스를 메모리에서 했는지 디드크에서 했는지 처리 관수 몇 건 이런 실질적인 정보들이 이렇게 나옵니다.

참석자 1 
그래서 제가 이제 개발자를 교육할 때 항상 두 가지를 강조해요. 
앞으로는 반드시 실행력을 확인하셔라 그다음에 sk 트레스까지는 튜너가 아니니까 잘 모르더라도 적어도 오토 프레스를 통해서 이걸 확인하라는 얘기죠 이거 내가 짠 코리가 화면에 10건밖에 안 되는데 그 10건을 읽기 위해서 아이를 얼마큼 일으켰는지를 보라는 얘기죠 딱 봤더니 화면에 10건 나오는데

참석자 1 
이 시트 겟이 100만이에요. 컨시트 겟이 메모리에서 지금 데이터 바이오거든요. 
화면은 10개 쭉 하기 위해서 100만 개의 블록을 읽은 거예요. 
이상한 거죠. 그렇죠 굉장히 많은 블록을 읽었지만 그것이 메모리에서 읽었기 때문에 순간적으로 빨리 나오는 거예요. 
그런데 그 데이터가 항상 메모해서 읽어는 법이 어디 있으니까 어떨 때는 지속해서 읽고 쓸 것이고 어떨 때 메모리서 읽을 것이고 그러니까 어떨 때는 빨리 나왔다 어떤 때 늦게 나왔다 그러는 거예요.

참석자 1 
지금 테스트 환경이니까 데이터를 커리를 만드는 과정에서 같은 데이터를 뚫고 뚫고 뚫으면서 데이터가 메모리 올라가니까 수가적으로 빨리 나온 거죠. 
그런데 빨리 나온다고 걔를 딱 나중에 퍼블링을 하고 보니까 실제 운영 환경으로 넘어가서는 5분이 걸리고 10분이 걸리고 그러는 거예요. 
내가 짠 쿼리를 항상 메모해서 읽으라는 법이 어디 있어요. 
그러니까 반드시 이 오토 트레스를 통해서

참석자 1 
아이오 발생량을 확인하시라 그래서 kg 이상의 많은 블러가 있는 것 같으면 db 팀에 또는 트윈 팀에 팀 요청을 하라는 얘기죠 빨리 나왔다가 그냥 바로 퍼플 진행하지 마시고 그래서 이거는 개발자 수준에서는 반드시 확인하셔야 되는 정보다라고 제가 늘 강조를 하곤 합니다. 
그래서 옵션을 어떻게 주느냐에 따라서 실행 통계만 볼 수도 있고

참석자 1 
또 실행 계획만 볼 수도 있고 그 옵션에 따라서 이렇게 결과가 달라지는 걸 볼 수 있습니다. 
내가 보고 싶은 것만 시설 선택해서 볼 수가 있는 거죠.

참석자 1 
질문 있으실까요. 질문 을 해주시고 네 이 실행 통계에 대한 그런 내용들이 내용은 그 뒤에서 설명 할 거예요. 
우선은 이제 방법만 알려드리는 거고 그러면 지금 sk 플러스가 안 되시는 분들이 계시지 않습니까 그럼 그런 분들은 커리 박스 열어보시고 커리 박스에서 똑같은 정보를 확인할 수 있으니까 우선은 이제 커리 박스 통해서 해결하시면 되겠죠.

참석자 1 
실행 결과야 그냥 실행에만 나오는 거고 그죠 실행 기능 어떻게 하겠네요. 
오토 트레이스에서 보여지는 게 크게 세 가지 않습니까 실행 결과 실행계 실행 통계잖아요. 
그죠 실행 결과는 그 보면 알 수 있는 거고 실행 기간 어떻게 확인해요. 
컴퓨트러 2 누르시면 되잖아요. 그죠 컴퓨터 이 누르시면 그러면 실행 통은 어떻게 확인하느냐 여기 보시면

참석자 1 
여기 위에 아이콘이 있는데 잘 안 보여요 어떤 아이콘이냐면 잘 찾아보시면 여기

참석자 1 
아래쪽에 있구나 세션 통계라고 있습니다. 
세션 통계 우선은 요 탭 중에서 밑에 실행 및 세션 통계로 가세요. 
실행 및 세션 통계 아래쪽에 탭 그제 탭 중에 실행 및 세션 통계로 가시고 그 상태에서 위쪽에 보시면 패션 통계라고 요거 요거 있어요. 
요거 여기 플러그 마크 있는 거
참석자 1 
이걸 어떻게 보여드려야 될까
참석자 1 
이걸로 확대해서 보여드리면 요놈 요놈 요놈 요거 요거 되셨어요. 
네 그거를 딱 눌러요 눌러놓고 얘를 실행을 합니다. 
그럼 오른쪽에 보이죠. 그렇죠
참석자 1 
요놈입니다. 요거 요거 활성화시키신 다음에 실행하시면 돼요

참석자 1 
우선 하단에 실행 및 세션 통계 탭을 누르시고 창으로 넘어가셔서 안 드신 분 안 드시는 분 없어요. 
그럼 거기에 보시면 디비 블록 컨스터트 게시 몇 개로 나와요 실로 나오죠 그죠 7 그래서 이 쿼리를 수행하는데 7개 블록을 읽었는데 그 7개 블록을 메모리에서 읽었다는 얘기예요. 
그 밑에 보면 피지 컬리드는 몇 석 나옵니까

참석자 1 
영 디스크에서는 있지 않았다는 얘기예요. 
왜냐하면 여기 있는 분이 다 훨신 했기 때문에 누군가 최초에 실행하는 과정에서 메모리가 올라왔을 것이고 데이터 캐시죠 데이터 뒤로 몇 포켓이 올라왔을 것이고 그다음 분부터는 아마 누군가는 피지컬리디가 나온 분도 계실 겁니다. 
아니면 제가 아까 실행했기 때문에 안 나올 수도 있고

참석자 1 
한번 잠깐만요 한번 해볼까요. 제가 저는 권한이 있으니까 제가 플러시 해볼게요 아이터 시스템 플러시 버버 게시를 비우는 명령입니다. 
지금 수정하시면 안 돼요 제가 버버 게시를 비웠어요. 
버퍼 게시 비웠고 여러분 이거 스퀀점 emp 한번 동시에 한번 딱 실행해 보세요. 
그러면 누군가는 퀴즈 퀄리티가 나옵니다.

참석자 1 
제일 첫 번째 시작하신 분이겠죠. 피스컬 리드가 1보다 크게 나오신 분 명보다 크게 나오신 분

참석자 1 
여기도 꽤 나오셨어요. 지 지 몇 나오셨어요. 
1 또 6이 나오셨어요. 스코2인비 하셨습니까 그래요 피지컬리가 6이 나왔어요. 
여기도 나오시고 스코츠 이도하셨어요. 
그럼 진짜 말 그대로 두 분이 동시에 실행하셨나 보네요. 
동시 실행해서 하나는 여기도 있고 6개는 여기도 있고

참석자 1 
나머지 분들 다 여어 나오셨죠. 그죠 이 두 분이 먼저 시작하시는 바람에 이 두 분이 은 두 분이 먼저 읽으시는 바람에 메모리에 올라간 데이터를 그다음부터 읽으시는 거예요. 
그러니까 전부 컨스터트 개수로 나오죠 그렇죠 이해되십니까 그래서 여기 있는 항목들에 대해서도 다 하나하나 다시 설명을 드렸는데 제일 중요하게 봐야 될 것은 컨스턴트 개트과 피지컬 리드예요. 
특히 피지컬 리드 보들은 컨스트 개드 보셔야 돼요 컨스턴트 개드

참석자 1 
논리적인 인형 논리적인 인형 그 쿼리를 수행하는데 논리적으로 몇 플락을 읽었느냐를 표현하는 거거든요. 
코스트가 주로 보시는 겁니다. 일단 왼쪽에 숫자가 블록스 예 왼쪽에 숫자 블록 스로 왼쪽에 숫자 오른쪽 숫자 아니고요 교재 기준으로 교재 기준으로 그러네요. 
교재는 왼쪽에
참석자 1 
왼쪽에 숫자가 불렀습니다. 뒤에 나와요 안 들으셔도 돼요. 
뒤에 sk 트레이스랑 같이 비교해서 설명드릴 거거든요. 
여러 가지 항목도 있지만 제일 중요하게 여기서 보시는 것이 컨스턴스 갭이에요. 
컨스턴스 스케 플레이스에서 아직 안 드신 분 계시지만 어쨌든 커리에이 박스에서라도 보는 방법을 입으셨으니까 앞으로 그렇게 활용하시면 되겠고요

참석자 1 
컬들마다 다 달라요. 예를 들면 제가 주로 사용하는 오렌지에서는 오렌지에서는 특히 오렌지 쓰시는 거 보면 여기 익스트레트 스테티스라고 했어요. 
액션 밑에 이 스테이트 스테틱스 단축 키로는 컨트롤 시프트 에스 누르면 돼요 얼마나 씻습니까 컨트롤 시프트 에스 딱 누르면 이렇게 나와요

참석자 1 
개발자분들이 기본적으로 보셔야 될 게 컨트롤 2 눌러서 실행력 한번 확인하시고 컨트롤 시프트 s 눌러서 아이유 발생량 확인하고 이건 기본적으로 하셔야 된다는 얘기예요. 
내가 짠 커리가 도대체 아이어를 얼마큼 발생시키느냐

참석자 1 
또 토드 토드대로 또 메뉴가 다르고요 다 달라요 제가 컴퓨터마다 다 열어서 확인해 드릴 수 없으니까 여러분들이 사용하시는 코리에 술에 맞게끔 여러분들이 활용을 하시면 되겠습니다.

참석자 1 
혹시 sk 게이트 쓰시는 분 계세요. 
다행히 없으시네요. 있으시면 여러분도 해보여드려야 되는데 없으시니까 넘어가겠습니다. 
주로 어떤 거 쓰십니까 여러분 오렌지 쓰세요. 
오렌지는 컨트롤 1대 스 제일 쉽습니다.

참석자 1 
보시는 것처럼 오토 트레를 통해서 에스켓의 수행 인량을 확인할 수가 있는데 이놈의 단점은 뭐냐면 전체 인력만 볼 수 있다는 거예요. 
전체 인력 이 쿼리를 수행하는 과정에서 전체적으로 얼마큼의 블록을 읽었느냐 보니까 별별 집하면 10건인데 아이오가 100만 개가 발생했어 도대체 어떤 부분에서 100만 개가 발생했는지까지는 알 수가 없다는 얘기죠

참석자 1 
좀 더 드리라고 해서 더 자세히 볼 수 있는 방법이 없다. 
그럴 때 우리가 쓰는 것이 바로 레시피 트레스입니다. 
또 여기 컷을 짜서 짜고 경영 수업이 10번인데 딱 보니까 컨스턴스 캐시 2밖에 안돼요 그죠 좀 더 볼 게 있습니까 그에서 14번 출력하는데 아이오 2개밖에 발생 안 했어요. 
더 볼 거 없는 거예요. 그냥 튜닝 끝 그 두 블락 있는 거니까 더 튜닝 할 필요 없다는 얘기죠

참석자 1 
그런데 딱 보니까 결과 집하면 14건인데 아이오가 100만 개 나왔어요. 
그럼 거기도 문제가 있는 거겠죠. 왜 그렇지 이제 이제 y로 들어가야죠 y 왜그렇치라고 들어갔을 때 이제 우리가 봐야 되는 것이 에스크 트레이스입니다. 
에스큐 프레이스도 어려울 건 없어요. 
레스케를 수행하기 전에 앞에서 명령 하나 주면 됩니다. 
알트 세션트 레스큐 트레이스 트로
참석자 1 
에스케팅 한 다음에 폴스가 이렇게 바꿔주면 되는 거예요. 
그러면 스케 트레스가 수집이 됩니다. 
근데 문제는 그 sp 클래스가 어디에 수집이 되냐면 서버에 수집이 돼요. 
bbms 서버에 그럼 어때요 우리 개발자분들이 접근이 될까요. 
안 될까요. 안 되겠죠. 그죠 db 분들만 접근이 됩니다. 
db 분들 요즘에는
참석자 1 
예전 같으면 이제 개발자는 접근권을 안 좋고 신호한테는 접근권을 줬거든요. 
요즘에는 보안이 워낙 강화돼가지고 신어들한테도 잘 안 열어줘요. 
그 파일을 열려고 하면 텔넷으로 접속을 한다거나 에프티크로 접속해서 가져와야 되거든요. 
트랜스 파일을 근데 접근 자체를 못하게 하기 때문에 한계가 있습니다. 
그래서 그 한계를 어떻게 극복하는지 좀 더 설명드리기로 하고 어쨌든 그 트레스 파일이 서버에 남고 그 트레스 파일을 찾는 방법입니다.

참석자 1 
예전에 이렇게 복잡한 쿼리를 이용을 했었는데 지금은 요 명령 하나 날리면 돼요 일레븐 이후부터는 브이스 달라 다이어그 인포라는 뷰를 통해서 트레스 파일 위치를 알 수 있고 구체적인 파일 명까지 이렇게 찾아낼 수가 있습니다. 
그럼 서버 쪽에 어떤 디렉토리에 어떤 파일로 트레이스 파일이 만들어졌는지를 살 수가 있는 거예요. 
이해되시죠
참석자 1 
먼저 앞서서 이 영향을 먼저 수행을 해주고 그다음에 이 허리를 날리게 되면 그 트레이스 팔이 어디에 만들어졌는지를 확인할 수 있다.

참석자 1 
그래서 여러분들이 서버에 접근할 권한이 있어요. 
텔레도 접속을 하시면 텔더도 접속해서 그 트레이스 폴더로 찾아갑니다. 
디렉토리로 cd 디렉토리로 가고 vi 에디터를 이용해서 트리스카를 열어요. 
열면 크리스칼이 이렇게 나와요 암호화된 것처럼 나오죠 그죠 저 같은 사람은 이거 딱 보고도 저는 해석을 다 합니다. 
여러분들은 이것만 봐서는 해석이 안 되겠죠. 
그래서
참석자 1 
이 원시 트레스 파일을 포미팅해 주는 입틸리티가 있는데 그게 바로 티케이 피아 로프예요. 
티케이 피아로 pk q어요거를 딱 치면 이렇게 새 법들이 쭉 나와요 사용법들이 굉장히 옵션들이 많죠. 
그죠 많은 옵션들이 있는데 다 아실 필요도 없고 일반적으로는 이 정도 옵션 주면 됩니다. 
tkprf
참석자 1 
파일명 그다음에 결과 파일명 확장제는 아무렇게나 하셔도 돼요. 
저는 주로 이제 pif를 쓰는데 텍스트 하셔도 되고 확장제 안 주셔도 되고 아테나 여러분 마음대로 드시면 됩니다. 
그래서 원시 8명 드시고 결과 8명 드시고 나머지 옵션들은 그 끝에 필요에 따라 쓰면 되는데 기본적으로 쓰셔야 되는 옵션은 시스 에너예요. 
시스 에어 이 시스 에어는 뭐냐하면
참석자 1 
아까도 제가 시작부터 에서 옵티마즈를 설명드렸습니다만 우리가 커리를 수용하게 되면 우선 그 커리를 최적화를 한다 그랬죠 옵티마즈가 옵티마즈가 최적화하는 과정에서 파싱하는 과정에서 파싱하는 과정에서도 많은 커리를 시행해 볼 거 아니야 테이블 정보 칼럼 정보 인덱스 정보 이런 걸 참조해 볼 것이고 또 최적화하는 과정에서

참석자 1 
또 통계 정보들 조회해 봐야 될 거 아니에요. 
디셔널에 저장된 그죠 하신 말 중에서 없는 탭을 참조하지는 않았는지 없는 칼럼을 참조하지는 않았는지 권한이 없는 탭을 참조하지 않는 이런 것들 시멘트 체크 스테체크 한다고 했으니까 그 과정에서 기셔널를 조회해 볼 것이고 세부 정보 칼럼 정보 이런 것도 조해 볼 것이고 또 최적화 과정으로 넘어가서 디셔으로 통보 정보를 확인해야 될 거 아니에요. 
그죠 통문 정보는 디셔너로 저장돼 있으니까

참석자 1 
그러니까 내가 작성한 커리를 최적화하는 과정에서 내부적으로 시스템이 옵티마이저가 수행하는 커리들이 있다는 얘기예요. 
트레이스를 수집을 하게 되면 그런 커리들도 다 같이 나와요 그런데 그 커리들은 내가 분석할 대상이 아니지 않습니까 그죠 궁금해서 찾아볼 수 있겠죠. 
오라클이 오티마제가 최적화하는 거 해서 어떤 커리들을 날려보는지 궁금해서 볼 수 있겠습니다만

참석자 1 
본들 뭐 하겠습니까 그거 실행할 수 있는 것도 아니고 그래서 그런 내부 역할들은 제외하겠다. 
그 옵션이 바로 시스 에러예요. 시스 에어 그 커리들이 막 뛰어 있으면 오히려 분석에 방해만 됩니다. 
무시히 많은 커리들이 보이거든요. 궁금해서 한번 볼 수 있어요. 
한번 보세요. 얼마나 많은 쿼리들이 날아가는지 일반적으로 그 코리를 제어하기 위해서 cc no라는 옵션을 줍니다. 
그래서 tk 피어를 이렇게 딱 주게 되면

참석자 1 
결국 레포트 전 pr프랑 파이 만들어지겠죠. 
레포트 점 pr프를 viaf를 열어봅니다. 
열어보면 이렇게 예쁘게 포맷이 돼 있어요. 
위쪽에 콜 정보 콜에 대한 통계 정보가 나오죠 아래쪽에는 플랜에 대한 정보가 나와요 그래서 저는 이걸 이제 콜 스팸 플랜 셋이라고 불러서 얘기합니다. 
그래서 앞으로 제가 콜 스텝트 얘기하면 이거 얘기하는 거고 콜레스텝 기하면 얘 얘기하는 거예요. 
스텝 치스틱스가 발아하기 되게 어려워요. 
그렇죠 한번 해보세요. 스텝 치스틱스
참석자 1 
강의할 때마다 이것 때문에 길이 예는 없습니다. 
제가 플렌 스테틱틱스 콜 스테틱스 그래서 제가 줄여서 콜 스탠 플렌스다 이렇게 얘기하니까 이렇게 이해하겠어요. 
그래서 이 위에 있는 것은 말 그대로 콜 스텝 레스트 실행하는 과정에서 크게 세 단계를 거치거든요. 
카싱하는 단계 실행하는 단계 그다음에 dml일 때는 실행으로 끝나지만 셀렉트일 때는

참석자 1 
데이터를 캐치를 해야 되지 않습니까 그래서 캐치 단계 이렇게 3가지 단계로 진행됩니다. 
그래서 각 단계별로 단계별로 몇 번씩 실행됐고 cp를 얼마큼 사용했고 소요 시간이 얼마큼 됐고 디스카이오 발생량 메모리 아오 처리 건수 이런 것들이 각 단계별로 일목 요연하게 딱 정리가 돼서 보여지고 있죠 그죠 저걸 통해서 우리가

참석자 1 
수행 가족을 분석해 볼 수가 있고 그 아래쪽에 보면 실행 계획이 나옵니다. 
실행계획 근데 앞서서 받은 시행 계획과 얘는 달라요 앞서서 받은 시행 계획들은 예상 실행 계획이고 예상이다. 
보니까 정확하지가 않고 반면 얘는 실제 실행 계기입니다. 
실제 실행 계획이고 실제 지금 처리장을 보여주고 있어요. 
여기 보시면
참석자 1 
인덱스 스캔 단계에서의 cr pr pw 타입이 나오죠 그렇죠 이거 cr이 메모리 아이오고 pr이 피지컬 리드 pw가 피지컬 라이트예요. 
얘는 커리가 간단하니까 단 두 줄밖에 안 되지만 얘가 커리가 막 부인도 있고 서브클도 있고 하면 훨씬 더 복잡하지 않습니까 그 복잡한 쿼리들에 대해서 각 단계별로 단계별로 cr pr tw 차이는 각각 보여줍니다.

참석자 1 
각 단계별로 그리고 왼쪽에 보시면 처리 건수도 나오죠 각 처리 단계별로 메모리하요 디스카요 처리 건수 시간이 다 보여지는 거예요. 
저걸 통해서 전체 처리 과정 중에 어디에 주로 아이가 집중되는지를 찾아낼 수가 있는 거죠. 
전체 아이오가 100만 개인데 그 100만 개 중에 어디에 어느 단계에서 그 100만 개의 상당수가 집중돼 있는지를 이 트레이드 분석을 통해서 딱 찾을 수가 있는 거예요.

참석자 1 
무슨 말인지 아시겠어요. 그런 훈련을 여러분이 이제 다음 주부터 계속해 나가실 거예요. 
프레스 분석을 같이 해 나가시면서 그래서 아까부터 계속 궁금해하시는 그 부분입니다. 
그래서 트위스에서 보는 정보들에 대한 설명들이 쭉 돼 있죠

참석자 1 
그래서 콜에 대한 부분은 아까 이제 설명드렸습니다. 
파스 엑스 패치 각 단계별로 단계별 통계를 보여준다 카운트는 말 그대로 패스예요. 
팔싱을 몇 번 했는지 실행을 몇 번 했는지 캐치는 몇 번 했는지 카운트를 보여주고 있는 거고요 카운트

참석자 1 
그다음에 cpu랑 일렉스가 있는데 cpu 타임 일렉스 타임 둘 다 시간입니다 시간 시간은 시간이 있는데 어떤 차이가 있느냐

참석자 1 
지금 저쪽에 계신 분들하고 저 끝에 계신 분들이 안 보일 것 같아서 제가 지금 좀 고민이 되는데 어떻게 해야 될까요. 
제가 아이패들 준비해왔으면 아이패드 해가지고 비춰서 해드리면 좋을 텐데

참석자 1 
데이터가 이만큼의 데이터가 있어요. 그러면 아까도 얘기했다시피 이 데이터를 한 번에 다 읽어오는 게 아니라 그랬죠 그렇죠 처음에 이만큼 읽어서 데이터를 전송을 해요. 
보이세요. 그다음에 이제 클라이언트가 10개를 보내서 리턴을 했으면 또 그다음에 10개를 더 갖고 하라고 콜을 하는 겁니다. 
그러면 10개를 또 들어와서 10개를 읽고 또 보내요

참석자 1 
그러면 이제 클래스도 10개를 받아서 퇴치 패치하다가 다 소진하면 또 다시 10개를 요청하죠. 
이거 하나하나가 다 첫 번째 퇴치콜 두 번째 패치콜 세 번째 패치골이 되는 거예요. 
무슨 얘기지 아시겠죠. 그죠 db에 들어와서 이만큼의 데이터를 읽고 전송하고 이만큼 데이터를 읽고 전송하고 이만큼 거 전송하는 거죠. 
그러면 이제 패치콜이 딱 들어왔을 때 들어왔을 때

참석자 1 
프로세스가 cpu를 할당을 받고 일을 시작합니다. 
일을 시작하는데 데이터를 쭉 읽어내려가면서 cp가 계속 일을 할 텐데 cpu를 계속 치고 일을 하면 좋은데 그렇지가 못해요. 
중간중간에 여러 가지 이유로 대비를 해야 되는 상황이 발생합니다. 
락이 발생할 수도 있고 날이 문제에서 대기해야 될 수도 있고 또는 메모리에서 경합이 발생할 수도 있고 여러 가지 이유로

참석자 1 
경합이 발생한다거나 어떤 지연이 발생할 수 있는 요소들이 생기면 cpu를 반박을 했다가 잠깐 대기했다가 또 깨어나고 이걸 계속 반복합니다. 
가장 대표적인 cpu를 반납해야 대한 대표적인 게 뭐냐 하면 아이오 콜리예요. 
아이오 메모리에서 데이터를 찾아봤는데 메모리 없어요. 
그러면 시스템에다가 아이오 콜을 합니다. 
오스에다가 또는 아이오 서브 시스템에다가 아이오 콜을 해요. 
콜 하고 프로세스가 cpu를 반납을 해요.

참석자 1 
안나라고 잠깐 얘기를 해요. 잠을 잡니다. 
잠을 잤다가 다시 깨어나서 ct를 다시 해고 또다시 일을 시작하는 거예요. 
그래서 여러 가지 이유로 프로세스가 cpu를 반납하고 잠을 자는데 가장 대표적인 10중 8구의 원인은 뭐냐 바로 아이오크라는 얘기예요. 
메모리에서 데이터를 찾아봤는데 없을 때 없을 때 내가 읽고자 하는 블록을 아이오 서브 시스템에다가 또는 os에다가 요청을 하는 겁니다.

참석자 1 
이 블락을 좀 메모리에 올려달라고 코를 하는 거예요. 
함수를 호출하는 거예요. 함수 호출하고 cpu를 반납하고 잠깐 잠을 자요. 
그리고 깨어납니다. 여러분들 요거 좀 이따가 또는 다음 주에 아이오 파트 다시 설명드릴 거거든요. 
대충만 이해하세요. 그런 식으로 cpu를 잡았다. 
놨다. 잡았다. 놨다를 반복하는 일을 한다는 얘기예요. 
한국 콜이 들어왔을 때 cpu를 쥐고 계속 일을 하는 게 아니고

참석자 1 
잡았다. 놨다. 잡았다. 놨다. 잡아놨다를 반복한다는 얘기죠 그러면 이제 뭘 얘기하고 싶은 거냐면 여기 보면 cpu 타임이 있고 일리스 타임이 있지 않습니까 일렉스 타임은 들어와서 나간다고 했는데 나간 시간에서 들어온 시간을 빼면 일렉스 타임이 나오는 거예요. 
그죠 몇 분 몇 초에 들어와서 몇 분 몇 시에 나갔다. 
그러면 나간 시간에서 들어온 시간 빼면 경과 시간이 나오지 않습니까 그래서 이 경과 시간

참석자 1 
이 경과 시간 이 경과 시간을 더하는 게 일레스 타임이에요. 
그러니까 디비에 들어와서 일하고 나갈 시간 그걸 구한 거죠. 
그 db에 머문 시간 db에 머물렀던 시간을 더 하는 게 이스 타임입니다. 
cpu 타임은 실제로 cp를 쥐고 일한 시간 무슨 일인지 아시겠죠. 
cp를 다 다 다 다 왔다 반복한다 그랬지 않습니까 정유했던 그 시간만을 더하는 것이 cp 타임이에요. 
그러면
참석자 1 
논리적으로 시키 타임이 일래스타임보다 클 수 있을까요. 
없을까요. 없어요. 없죠. 그죠 논리적으로 당연히 일레스 타임이 더 커야 됩니다. 
근데 여러분들이 간혹 트레스 분석하다가 거꾸로 cpt이 크게 나오는 경우가 있어요. 
그렇더라도 당황하지 마시고 그럴 수 있다라고 생각하고 넘어가세요. 
왜 그럴 수 있냐면 일레스 타임은 나간 시간에서 들어온 시간을 뺀 거예요. 
그러니까 비교적 정확합니다. cp 타임은

참석자 1 
잡았다 왔다 잡았다. 했다 하는 것을 그래도 모니터링하면서 이게 값을 더 한 거거든요. 
그렇기 때문에 정확하지가 않아요. 그리고 반올림 온차가 있습니다. 
내부적으로 타이머가 타이머가 있는데 타이머의 어떤 단위가 있을 거 아니에요. 
그죠 그 단위가 있기 때문에 그것을 반올림을 합니다. 
그렇기 때문에 그 과정에서 실제보다 더

참석자 1 
잡았다. 놨다. 반복하다 보면 그 반올림에 의해서 값이 실제보다 더 부풀려지는 그런 현상이 생길 수 있어요. 
그렇기 때문에 혹시 cp 타임의 합이 리스트 함보다 크더라도 그냥 그럴 수 있구나라고 넘어가시지 그걸 왜 가끔 그걸 막 질문하시는 분이 계시거든요. 
그럴 수 있다라고 그냥 넘어가세요. 너무 깊이 들어가실 필요 없습니다. 
무슨 얘기인지 아시겠죠. 그죠 그런 의미예요. 
cp 타임의 엘리스 타임은
참석자 1 
여기서 하나 더 말씀드릴 것은 일레스타일과 사용자 체감 성능은 다른 겁니다. 
이런 시간이 소요 시간이지 않습니까 소요 시간 말 그대로 소요 시간인데 이 소요 시간이 사용자가 느끼는 체감 성능하고 다른 거예요. 
왜 다르느냐 이 헤스타임은 순수하게 db에 머문 시간의 합의거든요. 
근데 사용자가 느끼는 시간은 db에 머문 시간만 있는 게 아니죠.

참석자 1 
들어왔다 나왔다 들어왔다 나왔다 하는 구간에서 뭘 거칩니까 네트워크를 격리하죠. 
그죠 네트워크를 격리해요. 그다음에 네트워크 격리하고 데이터를 전송하고 나면 ap 서버가 그 데이터를 받아서 또 뭔가 연산을 해요. 
그죠 연산을 하죠. 예를 들면 증권사 같은 경우는 데이터 읽은 데이터를 가지고 거래소에 한번 콜 해요. 
그럼 거래소에 갔다. 오기도 하고 그렇죠 이는 대표 가지고 거래소에 가서 누가 3수 호출하기도 하고

참석자 1 
연산들을 한다는 얘기야 그래서 연산 시간이 더해지는 거고 또 싱킹 타임 하는 거 여러분 들어보셨어요. 
싱킹 타임 우리가 조회를 할 때 빈 테이블 조회를 했습니다. 
그러면 이 데이터를 이렇게 보죠. 그러면 이렇게 보면서 생각을 해요. 
아까 보시다시피 100권 나온 거지 않습니까 여기 데이터 이렇게 보면서 막 분석을 해요. 
머릿속으로 싱킹을 하는 거죠. 그러다가

참석자 1 
추가적으로 10건 더 있고 10건 더 있고 건 더 10건씩 갖고 온 거지 않습니까 그렇죠 클라이언트 쪽에서 데이터를 이렇게 보면서 뭔가 분석하는 시간 치킨 타임이라고 얘기를 하는데 그 시간 그것이 다 보여지는 거예요. 
사람들의 체감 성능이라고 하는 거죠. 
말하자면 이 일레스 타임은 순수하게 비비에 머문 시간만 나타내고 있다. 
그러니까 여기 일레스 타임이 3초 그러니까 빠르다

참석자 1 
그게 아닐 수 있다는 얘기예요. 진짜 저는 네트워크 구간을 경유하면서 진짜 사자가 느끼는 거는 무슨 소리야 내가 볼 때는 항상 10초씩 걸리는데 근데 트레스 상하면 3초밖에 안 걸리거든요. 
db에서는 3초밖에 일을 안 해요. 그러니까 느린 코리가 아닙니다. 
그런데 사용자는 느리다 느리다고 호소를 하는 거예요. 
또 다른 원인이 있다는 얘기죠 bb 구간이 아닌 네트워크 구간

참석자 1 
또는 ap 서버 구간에서 뭔가 병목이 있을 수 있다는 얘기입니다. 
근데 비비에서는 딱 그렇게 1초밖에 안 걸리는 거죠. 
db에서는 문제없습니다. 이렇게 얘기가 되는 것이고 다른 데서 원인을 찾아보셔야 됩니다. 
이렇게 분석할 수 있어야 되는 그래서 그의 타임은 db에서 머문 시간이다라는 것이고 그다음에 디스크는 말 그대로 디스크에서 입은 블라스트예요. 
그다음에 컷이랑 칼럼트가 나오는데
참석자 1 
이거 설명하려고 하면 둘 다 메모리에서 이를 불렀습니다. 
둘 다 근데 커리는 로고 커트는 뭐냐 이거 설명하려고 하면 이것만 가지고도 한 2시간 이상 얘기해야 돼요 그래서 이 두 개의 차이점을 가장 잘 설명한 책을 소개해드리면 모라크 성공 고도 얼려법 1번이에요. 
그래서 보시는 분들 아시겠지만 책 1건에 1장과 2장에 걸쳐서 이 내용을 설명하고 있습니다.

참석자 1 
일자 변경을 잡으셔야 돼요 거기 보시면 컨스턴트 겟은 무엇이고 커런트 겟은 무엇인지에 대한 설명이 나옵니다. 
이거 설명하려고 하면 롤백이 뭔지도 설명해야 되고 굉장히 많은 언급 언구에 대해서 얘기해야 되고 굉장히 많은 내용을 얘기해야 돼서 이 시간에 설명드릴 수는 없을 것 같고 나중에 그것까지 들어오시면 제가 설명드릴 수 있을 것 같고 간단히만 말씀드리면

참석자 1 
오라클은 데이터를 읽을 때 두 가지 모드를 사용해요. 
두 가지 다른 디비는 커트 모드밖에 사용하지 않습니다. 
그래서 오라클은 컨스턴트 모드와 크롬트먼트 2가지 모드를 사용할 데이터가 있는데 기본적으로 셀렉트는 항상 컨스턴트 모드를 입어요. 
셀렉트는 그다음에 dml일 때는 두 가지 모드를 다 사용하는데 어떻게 하냐면 내가 갱신해야 될 또는 지어 삭제해야 될 대상 레코드를 식별할 때는

참석자 1 
컨스턴트 모드를 읽어요. 컨스턴트 모드로 그 조건들을 만족하는 대상인지 아닌지를 컨스턴트 모드를 읽고 실제 데이터를 변경하려는 단계에서는 커런트 모트를 한 번 더 읽어요. 
그렇게 말하면 세렉 뛸 때는 항상 커리만 나와요 뒤ml일 때는 두 개가 다 나와요 저 안타까운 게 있는데 이 정도밖에 설명 못 드릴 것 같습니다. 
이 두 개의 차이점에 대해서는
참석자 1 
질문 네 질문해 보세요. 혹시 데이트를 들고 읽어도 트 포데 때는 2개가 다 나오죠 포데이트 때는 포이트 때는 호테이 뛸 때는 컨스턴트 모드로 쫙 읽어서 먼저 락을 다 걸어버려요. 
락을 다 걸고 시작합니다. 전체 대상에 그거 다 읽고 락을 걸 때는 이 컨스턴트 모드라고 하는 것은 뭐냐면 복사본을 만들어 입는 거예요. 
복사본을
참석자 1 
오라클 데이터 입을 때 원더 플라 그대로 있지 않고 복사본을 만들 수 있는 메카니즘을 갖고 있거든요. 
그것을 컨스턴트 게이라고 얘기하는 거야 근데 셀렉트 코어 업데이트는 낙을 거는 거거든요. 
그래 되는 데이터에다가 그런데 복사본을 만들어서 거기다 락을 걸면 무슨 의미가 있겠습니까 원본에다 낙을 걸어야 되겠죠. 
그렇죠 원본 블락에다가 그러니까 커스터트 모드를 읽어서 원번 블록에다가 낙을 다 걸어야 되요 그러니까 당연히 커리트 무단 나오잖아

참석자 1 
dml일 때도 마찬가지예요. dml일 때 여러분들 dml를 독사분을 만들어서 거기다 값을 업데이트할 수 없잖아요. 
그죠 내가 업데이트해야 될 대상인지를 식별할 때는 커스턴트 모드 읽더라도 갱신을 할 때는 원본 플라이에 가서 업데이트를 해야 되는 거잖아요. 
그죠 복사하고 만들면 거기다 업데이트 하면 안 되지 않습니까 그러니까 dml 때는 컬렉터 노드가 반드시 수반이 된다라는 얘기예요. 
죽었다. 깨나도 원더 블록을 읽어야 되니까 원덤 블록에다 변경해야 되는 거니까

참석자 1 
다만 조회할 때는 복사본을 만들어 읽는 게 가능하다는 얘기죠 왜 복사본을 만들어 읽는지에 대해서는 이걸 설명하려고 하면 mvcc 모델이라고 하는 것을 설명을 해야 돼요 mvcc 이걸 가장 잘 설명한 책이 올라가 상보다 원리법 1번이거든요. 
1장 2장에 걸쳐서 이걸 설명하고 있으니까 여러분들 한번 보신 분들은 기억하실 거예요.

참석자 1 
멀티 버전 텀크러시 컨트롤 멀티 버전 한 블록에 대한 다중 버전을 만들어서 동시성 제어를 한다는 의미예요. 
멀티 버전 한 블락에 대해서 시점별로 시간별로 다양한 버전의 블록을 만들어서 개를 이용해서 동일성 제어를 한다라는 그런 뜻이거든요. 
그런 메카니즘이에요. 그래서
참석자 1 
이것을 이는 원래 dbms 이론에 나오는 어떤 그런 모델인데 이 mbc 모델을 제일 먼저 구현하는 게 오라시고 지금 마른 ddms도 이 버전으로 이 모델로 가고 있어요. 
참고로 ms 시퀀 서버도 최근 화전에서 이 모델을 지원하기 시작했고 디폴트는 아닙니다만 이 모델을 지원하기 시작했어요. 
포스트 그의 sk 이지 않습니까 포스트 그의 sk는 이 모델로 작동을 해요.

참석자 1 
tv로 당연히 이 모델을 작성하고 있어요. 
그래서 장점이 많은 모델입니다. 그래서 대부분 dms들이 이 모델로 지금 가고 있어요. 
그런데 그렇지 못한 dbms들이 있다라는 얘기죠 그래서 그런 db들은 항상 커런트 모드로만 읽어요. 
커런트모드로만
참석자 1 
그래서 일관성이 좋지 못한 그런 문제들이 있다는 얘기죠 결과 집값이 정확히 안 나오는 그런 경우가 가능하고 있어요. 
그러다 보니까 이제 디비스가 대부분 이 모델로 가고 있는 것이고 아무튼 이거에 대해서는 좀 아쉽지만 이 정도로 하고 마칠게요 이거 설명하려고 하면 진짜 오늘 이것만 해도 시간 부족해요. 
그래서 결론적으로 말씀드리면 두 가지 모두가 존재한다 셀레필 때는 쿼리만 나오고 dml일 때는 둘 다 나온다. 
그리고 이 둘의 합이
참석자 1 
논리적인 인량이다라는 얘기예요. 쿼리를 수행할 때 보세요.

참석자 1 
스몰 테이블이 있는데 얘들 카운트해요. 
카운트할 때 트레이스 볼까요. 몇 개 불라 읽었어요. 
커스트트 게이 253개입니다. 피지 컬리드는 145죠 그죠

참석자 1 
그런데 피시컬 리드는 4번 바뀌어요. 
그죠 아까 보시다시피 두 분은 피지컬에서 나왔는데 나머지 분은 안 나왔지 않습니까 피지컬리는 운이 좋으면 나올 수도 있고 안 나올 수도 있고 거꾸로겠죠. 
운이 좋으면 안 나오는 게 좋은 거니까 그렇죠 하지만

참석자 1 
컨스턴트 겟은 항상 일정해요. 보세요. 
변해요. 안 변해요. 150m이잖아요. 
항상 계속 그죠 10분만 참수해도 항상 150일이에요. 
즉 이 결과 이 6만 8천 688 43이나 값을 얻어내기 위해서 필연적으로 읽어야 되는 논리적인 아이오 개수 블락 개수입니다.

참석자 1 
저 151개의 블락을 필연적으로 읽을 수밖에 없는 거예요. 
저 값은 변하지 않는다는 얘기죠 언제 변할까요. 
데이터가 추가되거나 데이터가 삭제되거나 데이터가 추가되거나 삭제되지 않는 한은 저것이 변하지 않아요. 
저 결괏값을 얻기 위해서 필연적으로 읽어야만 하는 논리적인 인량인 거예요. 
논리적인 블록 아이가 될 수 인 거죠. 
있는지 알 수 있을까요. 그죠
참석자 1 
그래서 이 코리와 코론트의 합심이 바로 그 논리적인 인량의 합이라는 거예요. 
절대 변하지 않는 반면에 그 위에 있는 디스크는 매번 그때그때 다를 수 있다라는 것이고 그리고 로스는 말 그대로 차이 컨스죠 바로 설명 다 드렸습니다. 
그가 여기 있는 항목들에 대해서 설명을 다 드렸어요.

참석자 1 
그래서 여기 나오는 쿼리 크럼트는 전체적인 논리적인 인력을 보여주는 것이고 요 아래쪽에 보시면 씨알이라고 있어요. 
씨알 이 씨알은 각 단계별 논리성이 일하는 거예요. 
씨알은 단계별로 그러면 아까도 계속 그 질문하셨는데 오토 트레이스랑 아까 앞서 보신 오토 트레이스랑 에스큐 트레이스 서로 비교 분석해 보면

참석자 1 
이 오른쪽 밑에 있는 놈은 오토 스트레스입니다. 
오토 스트레스의 실행 성제고 이 위쪽에 있는 놈은 에스퀼트레스입니다. 
둘을 서로 비교해보면 위쪽에 있는 커리와 아래쪽에 있는 컨스터트겟이 같은 항목이에요. 
같은 항목 아까 여기 뭐라고 돼 있습니까 여기 보시면 쿼리는 뭐냐 컨스턴트 모드 입은 블록수라고 돼 있죠 이 쿼리가 바로

참석자 1 
컨리스턴트 모델 이고 블라스요 그러면 거기 이제 보시면 워터 트레이스 보면 컨스턴트 겟이라고 표현돼 있잖아요. 
여기가 컨스턴트 모델은 이 블록스라는 표현을 여기서도 하고 있는 거예요. 
그다음에 커런트는 이 블라켓과 같은 항목입니다. 
이름은 다른데 이름은 다른데 결국 같은 거예요. 
그다음에 여기 에스키 트레이스에서 디스크가

참석자 1 
모터트레스의 피지컬리드랑 같은 항목입니다. 
그다음에 여기 처리 파수 맨 밑에 있는 처리 버스랑 같은 항목 있고요 그다음에 에시컬 트레이스에 보면 패치 콜이 나왔죠 패치 콜 해치 콜은 오토 크레스의 스킬 렛 라프티 투 프롬 클라이언트 클라이언트와 서버 간에

참석자 1 
몇 번 라운드 투입을 했느냐라는 거잖아요. 
의미적으로 그렇죠 두 번의 라운드 투입을 한 겁니다. 
패치콜을 두 번 하는 거죠. 같은 항목입니다. 
패치콜 이해되시죠 이제 질문해 보세요. 
아까 질문 주신 다 설명드렸어요. 이제 나머지는 더 공부하십시오 나중에 지금 이거 다 설명드리려면 리드가 뭔지 아시는 분 리드가

참석자 1 
3분의 1도 안 되지 않습니까 그럼 또 리뷰를 설명해야 되거든요. 
이거 아키텍처 설명할 수가 없으니 이거는 에스케팅을 지금 하려고 하는 거니까 이거는 클라이언트를 통해서 던져진 바이크스 클라이언트가 이제 sk를 실행했으면 스킬이 나갈 거 아니에요. 
클라이언트에게 서버에 그 발투스를 의미하는 거고 거꾸로 네 이게 클라이언트에게 던져진 발투스네요. 
그죠 밑에 거는 클라이언트로부터 넘어온 발투스죠 그죠

참석자 1 
그다음에 이제 이거는 나중에 우리가 소트팅 할 때 나올 건데 소트를 할 때 일단 메모리에서 해보고 메모리가 꽉 차면 디스크를 이용하는 거거든요. 
그걸 보여주는 거예요. 매몰 소트했냐 기스 소트했느냐 아까 우리가 pga 설명한 걸 간단히 설명드렸잖아요 소트할 때는 pga의 소프트 에어를 이용한다 그래서 메모리를 이제 소트를 하는 건데 메모리이기 때문에 부족할 수 있죠 공간이 그러면 이제 많은 데이터를 소트할 때는 디스크를 이용하게 되거든요. 
캠프 테이블 스테레스를
참석자 1 
그걸 이제 고분해주는 거예요. 그러면 그냥 차을 것 같고 다들 명입니다. 
리스 사이즈 트레버는 이건 뭘까요. 프레스콜 너무 해요. 
아까 오기 살짝 봤는데 사실
참석자 1 
그리고 아까 crpr 다음에 pw는 피지컬 라이트

참석자 1 
얘기 나온 김에 알파 시스템 플러시 셰어드 풀 시드 풀을 비워볼게요 비우고 나서 그러면 이제 sk가 사라졌겠죠. 
사람 때 얘를 한번 오트트을 볼게요 딱 보면 니컷 심코 몇 개 나와요 90 나오죠 그죠 근데 한 번 더 실행해보면 사라져요. 
리크시드 콜이 그죠 다시 한번 섀드풀 비워볼까요.

참석자 1 
그러면 얘가 또 나옵니다. 뭔지 느낌이 오실까요. 
리크시크리 뭔지 뭘까요. 그렇죠 카싱이죠. 
니크시브라는 게 재기적이라는 뜻이잖아요. 
보세요. 저는 이 에시케를 수행했는데 이 에시케를 수행했더니 이 레시피를 파싱하는 과정에서 내부적으로 내부적으로 내부적으로 수행하는 커리들 옵티마 자고 난리 커리들이겠죠. 
그죠 레시피 파서 옵티마이저 난리 커리들

참석자 1 
걔들이 리커시브 콜이에요. 그것들이 여기 더해진 거예요. 
리커시브 콜레스가 나온 거고 보면 여기 컨스턴트 개도 지금 2505 나오죠 여기 아이오의 계 sql 8시간 관련해 찾아서 수행한 아이오가 포함된 겁니다. 
한 번 더 수행해 보면 150일로 줄어들죠 그죠 이제 계속 150일이에요. 
150일인데 다시 한 번 플러시를 해보면

참석자 1 
리커시브 콜이 나오면서 다시 컨스틱이 250으로 늘어나요. 
그죠 제기적인 콜을 통해서 발생한 아이오도 같이 포함이 됐다는 얘기죠 한 번 더 실행해 보면 재적 콜이 없어지면서 150일로 줄어들고 이제 그때부터 항상 150이 이해되십니까 질문 있으신 분 없으시면 잠깐 쉬겠습니다. 
지금 4시죠 4시인데 4시 15분에 시작할까요. 
15분에
