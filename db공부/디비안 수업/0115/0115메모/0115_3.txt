참석자 1 
이제 아이온 프로작 원성과 그것을 위한 우리 개발자들의 역할이 무엇인지 자료를 살펴보고 본격적으로 인덱스로 넘어가도록 하겠습니다. 
여태까지는 아키텍처를 설명하는 장면 어쩔 수 없이 아키텍처 센터를 과감하게 생략을 했지만 그럼에도 불구하고 어쩔 수 없이 초반에는 악기를 설명을 할 수밖에 없습니다. 
적인
참석자 1 
바이오와 저장 멘타이 핵심 멘트 이런 것들을 알아야지 우리가 인디스의 활용 원리도 또 조연의 활용 원리도 이해할 수가 있는 빠르게 하도록 하겠습니다.

참석자 1 
우리가 당연히 메모리 아이오 결국 성능은 디스크 아이오에 의해서 좌우된다고 했으니까 모든 데이터를 다 메모리에 올려 쓸 수 없을까 그런 생각을 하게 되겠죠. 
실제로 그런 기미가 있죠. 메인 메모리 이라고 배우지습니까 에미플이 있습니다. 
우리나라에서 제일 대표적인 업체는 어디있죠

참석자 1 
그래서 우리나라 업체도 있고 외국의 갱년기 업체들도 있습니다. 
메인 매물은 말 그대로 잘 데이터 가 쪽에 얼룩을 치는 거기 때문에 굉장히 빨라요 우리가 쓰는 물보다 10배에서 500배 정도 더 빠르다 모든 기를 다 매미를 쓰면 좋

참석자 1 
성능의 장점이 있는데 다른 단점들이 있습니다. 
지금 시간이 오래 걸리고 장애 복구에도 일반적인 기예를 잘 쓰지 않고 데이터 안정성보다는 빠른 트랜잭션 처리가 요구되는 그렇게 특별히 없는 편입니다. 
예를 들면 통신사에서 한 달 동안에 고객들의 발음을 하려고 할 때 엄청 많잖아요. 
팀적 고객들이 몇 천 명도 되 그 30명이 넘는 고객 데이터를

참석자 1 
가운데 다 다 이렇게 들어와서 가공을 하려고 하면 이게 한 달이 넘어갈 수도 있거든 가 를 쓰거든요. 
그래서 이런 레드 들을 활용을 해서 한 달 걸린 작업을 일주일 5일 이렇게 하는데 그 업무에서

참석자 1 
그래서 이제 메인 메모리가 아니더라도 우리가 일반적인 알디비에서도 메모리 자원을 효율적으로 사용하기 위해서 내부적으로 배달료 알고리즘이라는 것을 사용을 해요. 
그가 여기에 예 이 설명할 때 방법들은 컨베이어벨트를 많이 썼었거든요.

참석자 1 
데이터가 이렇게 흉벨 벨트에 올라와요 이렇게 흉벨 벨트에 의해서 흘러 내려가겠죠. 
내려가다가 그래서 살이 안 되면 떨어져 내려가는 거예요. 
이제 쭉 흘러 내려가다가 내가 다시 한 번 사용되면 앞으로 다시 하는 거죠. 
흘러 내려가고 사용되면 앞으로 당이 되면 안으로 가고 당이 안 되면 언젠가 이렇게 서서 내려가는 이런 식으로 블록 그리고 자연스럽게 왼쪽에 있는 블럭들은

참석자 1 
자주 사용하는 블럭들이 되겠죠. 자주 사용하는 블럭들이고 오른쪽에 있는 블럭들은 덜 자주 사용되는 플러드 이쪽을 mru 엔드 이쪽을 lru 엔드라고 얘기합니다. 
보스트 리스트 클릭 유스트 최근에 사드 블록 이고 이거는 리스트 리스트 리 리스트 마음이 안 좋지만

참석자 1 
찾아보시면 다 한테 나오니까 정확한 법을 설명하시면 되겠습니다. 
이런 식으로 관리를 하고 참고로 프로스캔 할 때는요 이 맨 끝 쪽으로 올라갑니다. 
그 쪽으로 엘레레드 쪽으로 왜 그럴까요. 
아니 어떤 사용자가 백마 같은 거는 1억 원짜리 크기 풀스캔을 했어요.

참석자 1 
걔들이 만약에 앞쪽으로 올라가면 그 mr 연적지 올라가게 되면 나머지 애들을 다 밀어내버릴 거 아니에요. 
그러면 레모에 자주 사용하는 엑세스 밀러 로드 블러플까지 다 밀어내는 그런 나쁜 효과를 생기기 때문에 그 효과를 최소화하기 위해서 풀 스캔 할 때는 항상 이쪽 끝으로 에러 엔드 끝쪽으로 올려버려요. 
그러면 올라오자마자 바로 떨어져 내려가겠죠.

참석자 1 
그리고 인덱스를 통해서 입을 때는 과거에는 맨 앞으로 올라갔었어요. 
맨 앞으로 그런데 참 두건강하죠. 인덱스에서 인덱스를 통해서 입는다고 그래서 그 블랙이 항상 자주 쓰는 블랙은 아닌데 한 번 일으켰다고 해서 그것이 왜 나쁘게 올라가기 좀 불합리하다 그래서 최근에는 중간으로 올라갑니다. 
중간 중간으로 올라가서 그때 평가를 받는 거예요. 
자주 쓰이면 거꾸로 mr 쪽으로 거슬러 올라갈 것이고 발생 되지 않으면

참석자 1 
애널리 쪽으로 밀려 내려가는 기체를 갖게 되겠죠. 
얘가 제가 예전에는 이제 에라이 아 이런 식구 쿠에게 설명드렸는데 작년인가 눈이 다 제가 이제 어떤 걸 발견했냐면 제가 옷장에 옷을 넣을 때 항상 오른쪽에 끼워놓는 거를 있더라고요 입었던 옷을 벗어서 맛있죠 벗어서

참석자 1 
맨 오른쪽에 끼어나요. 쫙 밀고 오른쪽에 나 또 버스 입었다가 벗을 때는 쫙 밀고 맨 오른쪽에 끼어나요. 
그렇게 하면 어떻게 될까요. 제가 자주 쓰는 와슈처들은 항상 오른쪽에 위치하겠죠. 
그렇죠 잘 안 있는 와슈처들은 맨 왼쪽으로 밀려 가는 그런 것 mr 베라 알고리즘을 이렇게 이해하시면 저희 lr 알고리즘은 단지마다 조금씩 달라요 그런 방식

참석자 1 
터치 카운트를 물량마다 있는 횟수를 계속 모니터를 해서 터치 카운트를 정부에 자동해서 관리하는 그런 기능도 있고 다 다릅니다. 
근데 그런 것까지 깊이 알아서 뭐하시겠어요. 
우리 여러분들 인증을 아크팩처도 적당한 수준으로 들어가셔야 되지 너무 깊게 들어가시면 피곤합니다. 
알아두만 골라도 상관 아닙니다. 그냥 제가 말씀드린 것처럼 이렇게 중점적인 수준에서

참석자 1 
이해하시면 돼요 왜 저런 것이 필요한 것인가 그 필요성을 이해하는 수준에서 적절히 공부하시면 돼요 너무 깊이 파헤치고 올 수 있는 신선이 좋지 않습니다.

참석자 1 
그리고 메모리는 유한한 자원이에요. 유한한 자원 비용적인 한계도 있고 기술적인 한계 일단 비싸죠 디스크보다 비싸기 때문에 모든 데이터를 연결 할 수가 없고 기술적인 한계도 있습니다. 
우리가 삼성전자라서 메모리를 충분히 싸게 구입할 수 있다고 하더라고 하더라도 기본적으로 현재 근육 수준에서 메모리로 활용할 수 있는 사이즈는 이미 정해져 있다는 거지 있기는 하지만 지금 몇 달까지 가능할까요.

참석자 1 
현재 지금 세라마이드 급 단위의 데이터 패싱을 하시고 있다고 보시면 되겠고요

참석자 1 
아무튼 이런 원리를 바탕으로 우리가 디스카이오를 최소화하고 게시 실효성을 제거하려는 노력 그것이 데이터 중 가하는 열세다라고 볼 수 있는

참석자 1 
그리고 지금은 대부분 우리가 센스 브리지를 써요. 
네트워크로 연결된 스토리를 쓴다는 얘기잖아요. 
그렇기 때문에 네트워크 속도도 아이오스크에 영향을 줍니다. 
그리고 여러분들이 우리 대형 시스템들은 대부분 rc 구조로 이를 관리하고 있거든요. 
구성을 하고 있거든요. 아시는 뭐냐면 원래는 인스턴스 하나당 하나예요. 
데이터베이스 하나 인스턴스 하나가 데이터베이스 하나인데 지금은 인스턴스가 여러 개입니다.

참석자 1 
일반적으로는 싱글 로드에서는 메모리 찾아보고 없으면 디스크를 받는데 아리씨 환경에서는 메모리 찾아보고 없으면 옆에 노드에 가서 들어가요 내가 이걸로 블록 갖고 있니 그러면서 있으면 그걸 갖다가 다 나도 없고 글로벌 하게도 없으면 그때 이렇게 디스크를 받아 읽는 거예요. 
그 과정에서
참석자 1 
서로 메모리상에서 데이터를 주고받으면서 아리스 모들끼리 메모리스를 주고받으면서 아이 하는 그런 메카니즘 그렇기 때문에 또 네트워크 속도가 아이도 상당히 영향을 주는 거죠. 
결국 이쪽 입장에서 보면 네모에서 읽은 것처럼 인식이 되지만 사실상은 저쪽 노드에 갔다. 
온 거예요. 논리적인 아이오지만
참석자 1 
물지는 아니지만 네트워크를 경유해서 갔다. 
오기 때문에 내 로컬에 있는 데이터를 바로 찾을 때보다는 아무 성능이 떨어지겠죠. 
그래서 튜닝이 잘 안 된 시스템에다가 rc를 구입하면 성능이 더 떨어져요. 
rc를 구입하는 목적이 여러 가지 있거든요. 
고가용성을 위해서 하고 빨리 까 성능을 위해서 다 근데 성능이 원래 떨어질 수 있다는 얘기야 수정이 잘 안 돼 있으니까

참석자 1 
안 돼 있으면 얘는 메모리 뒤져보고 없으면 디스크가 왔을 텐데 이제는 메모리 뒤져보고 옆쪽에 갔더니 옆쪽에도 여성이 없어요. 
팀이 안 돼 있어서 물성이 안 좋은 거예요. 
그러면 그쪽에 한 단계를 적었으니까 조명이 더 떨어질 수 있겠죠. 
그다음에 이제 파이스템 캐시 우리가 오라크림 입장에서는 디스크 아이오처럼 인식이 되는데 사실은 파이 시스템에도 내부적으로 캐시를 갖고 있거든요. 
캐시를 아까 말씀드린 이 댄스토리지에도

참석자 1 
그런 것처럼 일반적인 파이스템으로 다 os 단에서도 캐시를 갖고 있거든요. 
그렇기 때문에 오라클이 볼 때는 디스카이로 측정이 되는데 카이색 메모리에서 입게 되는 거죠. 
그렇기 때문에 여러분들이 이상한 결과를 볼 수 있을 거예요. 
분명히 감사님이 디스카가 성능이 많이 좌우된다고 했고

참석자 1 
디스크가 초당 100 500 이거 했는데 딱 해보면 또 빨리 나와요 거짓말이네 이렇게 빨리 나오는데 무슨 디스크예요. 
근데 그거는 왜 그러냐면 그 데이터가 오라클 입장에서는 디스크는 이었지만 사실 그 디스크가 스토리 땅에서 캐시에서 각각 블로그 변환했다라는 그거 믿고 여러분들이 빠르고 수 있게 해주시면 안 돼요 그것도 여러 번 읽어서 다시 올라가서 그렇게 된 거예요.

참석자 1 
이렇게 여러 가지 요소들에 의해서 아이오 속도가 영향을 받는다라는 사실 기억하시고 그러면 우리가 성능을 향상시키는 근본적인 해법은 무엇이냐 버퍼 캐시 탐사의 비용을 줄이기 위해서 cpu를 증설하는 방법도 있을 것입니다. 
cp가 더 빨라지면 데이터를 캐시에 찾는 속도가 더 빨라지겠죠. 
불락 경합을 해소하기 위해서 메모리를 증설합니다. 
그것도 도움이 돼요. 메모리가 사이즈가 커지면 데이터가 그만큼 더 많이

참석자 1 
합쳐지고 또 더 많이 캐싱이 되기 때문에 경험을 줄이는 데도 도움이 되겠죠. 
히트도 좋아지고 또 디스크를 바이오 스쿨을 더 빠르게 하기 위해서 디스크를 더 빠른 곳으로 교체할 수도 있고 실제로 요즘에 우리 하드 디스크를 ssd로 많이 전환하지 않습니까 올 플래시고 실제로 이렇게 하면 속도가 빨라지는 건 사실이에요.

참석자 1 
그다음에 네트워크 속도를 더 빠른 것을 사용할 수 있을 것이고 말 것처럼 네트워크 속도가 스카이의 성능에 영향을 이런 것들도 분명히 허리 성능에 도움을 줍니다. 
하지만 근본적인 해법은 아니죠. 근본적인 비효율 문제는 그대로 놔둔 상태에서 하드웨어 증가를 통해서 성능을 높이는 그런 방법들이요 그럼 일시적으로는 성능이 좋아진 것 같지만

참석자 1 
또 데이터가 막 쌓이면 다시 느려져요. 
그럼 또 증설하고 네 근본적인 세포는 sk t 달라집니다. 
스팅을 통해서 각 쿼리들이 읽어야 되는 논리적인 인량 자체를 근본적으로 줄여버리는 거예요. 
100만 골라 읽은 거를 천 개로 줄이고 10만 개 읽은 것을 만 개로 줄이

참석자 1 
근육 량 자체 줄여버리면 그 배수만큼 성능이 좋아지고 법 실효성도 높아진다라는 얘기죠 비용은 어떤 게 더 많이 들까요. 
하드웨어 증설하는 방법이랑 에스큐팅을 하는 거랑

참석자 1 
내가 할 줄 알아서 내가 직접 하면 수입률이 낮은 건데 보통 못하지 않습니까 그러면 이제 외부의 컨설턴트의 도움을 받아요. 
그럼 하드웨어 증설 비용보다 더 할 수도 있습니다. 
이 티너들의 단가가 되게 좋고 좋지가 않거든요. 
그리고 하드웨어 증설은 도입을 하게 되면 내 자산이잖아요. 
경고적으로 내 것이 되는 거고 근데 트니는 어때요 수 했더니 빨라졌어 근데 시간이 지나면서

참석자 1 
테이블에 칼럼이 추가되기도 하고 인디스의 칼럼이 추가되기도 하고 여러 가지 모델 구조가 변화가 생깁니다. 
또 업무가 변경이 돼서 코리문이 바뀌어요. 
코리문이 기존에는 a b c 세 칼럼만 참조했는데 이제는 d 칼럼을 읽게 되는 순간 갑자기 인덱스 성능이 확 늘어지고 그러니까 관리자들은 투정은 또 시간이 많이 걸리지 않습니까 수정을 들어와서 짧게는 한 달 두 달 석 달 여러 달 투임을 한다면 시스템 증설은 예산 잡고

참석자 1 
업체 불러서 꽂으면 되니까 시간도 많이 안 걸리고 관리자들이 좋던 그 방법을 선호해요. 
시체 말로 이제 돈으로 써달라는 거죠. 
제가 그래서 문이 많이 봤어요. 많이 봤는데 결국 그렇게 하다가 안 되니까 저희를 도르는 건가 실제로 재작년에 벌써 재작년이네요. 
재작년 cj가 cj 올리브 형이 3개월 단위로

참석자 1 
원력 세일이라는 걸 해요. 여자분들 많이 아시죠 그죠 3개월마다 원력 세일을 하는데 이게 운영이 잘 안 되는 거예요. 
매번 원료대 할 때마다 cpu 탑 10을 쳐요. 
그 그때마다 cpo 증설하고 메모리 증설하고 아무리 해도 나아지지 않는 거죠. 
그래서 저희가 이제 급하게 요청을 받고 재작년

참석자 1 
3월 올릭스를 앞두고 2월달에 저희를 불렀어요. 
제가 들어갔어요. 그래서 지금 분단을 하고 있었는데 벌써 cj 올리브영을 지원하는 cj 시스템은 지금 실제 시스템들도 그렇게 계세요. 
없으시죠 이미 그때도 이미 cpu 증설을 하려고 계획을 다 잡고 그걸 추진하고 있었어요. 
쉽게 조사를 해요. 저희가 진단해 보니까 어인이 어디 있었는지 아세요. 
네모리 경합이 있었어요. 네모리
참석자 1 
캐시 버퍼 샤인 매치 어떤 특정 커리 하나가 커리가 딱 있는데 서브 커리가 이그시트나 이그트 서브 커리가 한 30몇 개가 있는 거예요. 
허리가 딱 돌면 나비 이그시트 체크를 서류 몇 개만 합니다. 
하루 몇 번 어마하게 많은 데이터가 있는 거예요. 
임금 그러면서 그 과정에서
참석자 1 
이것이 이제 많은 바라기 데이터를 골고루 읽으면 사실 문제가 안 되는데 이벤트 때다. 
보니까 특정 데이터를 집중적으로 읽는 거예요. 
세일 할 테니까 동시에 다발적으로 동시 만상들에 접속하잖아요. 
이벤트에 참여하려고 내가 그거 할인율을 적용받으려고 동시다발적으로 막 수백 수천 명이 확 달라붙은 상황에서 특정 커리 하나가 순간적으로 많지 않은 데이터를 굉장히 많이 얘기하고

참석자 1 
다양하게 있었던 거죠. 그래서 메모리 경합이 막 증가를 해서 신규 사업 확률이 백을 치는 그런 상황이 됐어요. 
그런 상황에서 cp를 뽑으면 굳이 해결될까요. 
안 될까요. 더 느려지죠 그렇죠 기존에 10명이 경합하던 거를 cto를 10개를 더 뽑아서 20명이 경험을 하게 만들었어요. 
그러면 더 심해진다는 얘기야 경합이
참석자 1 
제가 이거는 cpu 당신들이 하려고 하는 것처럼 cpu 증설을 하게 되면 상황을 더 악화시키는 거다. 
저희가 튀닝을 했어요. 말리는 안 했습니다. 
그 커리 포함해서 리 그런 패턴 그런 패턴을 커리가 굉장히 많았어요. 
많았는데 그중에서 제일 많이 수행되는 한 3개 정도 튀닝을 했어요. 
그리고 나서 3월달에 딱 했는데
참석자 1 
그전에 12월까지는 100을 치고 하면 그러던 것이 뚝 떨어져서 20% 30% 다들 놀랐어요. 
그때 사람들이 오는 세일을 일주일 동안 하거든요. 
일주일 동안 하는데 맨 마지막 날 이제 일주일 내내 너무 이제 평온하게 행사가 잘 됐고 맨 마지막 날 이제 밤 12시에 마지막 이벤트를 하는데 아무 문제없이

참석자 1 
풀러하게 딱 이 장면을 보여주고 끝났어요. 
사람들이 막 치면서 끝났어요. 어떤 분은 제가 제 여기 와가지고 처음. 
봤대요 여러분 부상이 이렇게 나쁘게 얘기하는 거는 처음. 
봤대요 한 달 찌닝 해가지고 한 달 찌닝 하면서 커리도 많이 안 했어요. 
한 서너 개 했어요. 선이 한 걸로 시스템이 살아난 거예요. 
그다음부터는 3월 6월 9월 제 작년부터는 안 들었더라고요

참석자 1 
제가 재작년에 했거든요. 제가 찍었는데 이 고장이 이게 올라가지 않으니까 작년에 제가 몇

참석자 1 
근데 제가 이제 3개월 단위에 한 번씩 계속 계속 모니터링 했거든요. 
근데 조금 조금씩 올라왔더라고요 저는 왜냐하면 새로운 서비스들이 계속 개발이 되니까 세스 개발에 대해서 또 악성 에스피 에는 비오에스크이 하나씩 더 추가되면서 눈은 높아지는 언젠가 분란이 바로 그거예요. 
긍정적인 해법이라는 것이 그로 말씀드린 것처럼

참석자 1 
패시를 늘리고 시트를 증설하고 기본이 잘못한 거지만 근본적인 해법은 아니다. 
그 팀을 통해서 논리적인 유량을 줄여야 된다 여기 2명의 학생이 있는데 이 학생은 시험 발쪽을 막기 위해서 창구을 100번을 봤습니다. 
시험은 항상 100점을 만져야 돼요 sk은 무조건 100점을 해야 됩니다. 
결과가 틀리면 안 되잖아요. 그 결과 에 무조건 10점을 만져야 되는데이쪽 학생은 참고서를 100번을 읽고 100점을 만져고 이쪽 학생은 잘 정리된 초고

참석자 1 
서버리 좋은 공부방은 아니죠. 그렇죠 선배로부터 대대로 내 거는 좋은 잘 정리된 조건을 받아서 한 번에 써 보고 적을 많았어요. 
누가 더 효율적으로 구매했냐는 거 입증이 되겠죠. 
이 학생처럼 허리를 주게 된다. 그래서 개발자들의 역할을 정리를 해 보면

참석자 1 
필요한 채소 분란만 있도록 콜리 작성하셔야 돼요 제가 튜닝을 처음. 
공부하면서 제일 먼저 들었던 게 바로 이 팀이었고 그전에는 정말 장생은 스터리를 짜잖아요. 
그 결과만 맞게 나왔는데 이 팀을 배우고 나니까 이제 거기서 그걸 공유하고 단락을 최소화해라 그래서 그때부터 제가 같은 맥구드를 반복해서 읽지 않겠다. 
그런 증면
참석자 1 
그다음에 필요한 최소 블러가 있도록 하겠다. 
이 두 가지를 딱 머릿속에 딱 기억하면서 풀을 짜면 벌써 자세가 달라지는 실행 계획을 보게 되고 아이오를 체크하게 되죠. 
결과적으로 화면에는 10번밖에 안 보이는데 아이오가 그런 게 발생하네 뭔가 문제가 있나 하면서 분석을 하기 시작하는 그 차이라고 저는 생각을 해요. 
이 두 개의 문장 저것을 알고 파리를 대하느냐

참석자 1 
그것을 모르고 결결식파만 맞으면 된다고 생각하고 접근하느냐 그 차이라고 생각을 합니다. 
그래서 저런 원리에 입각해서 우리가 최소 일량을 요구하는 형태로 논리적인 집합을 잘 정리하고 효율적인 처리가 가능하도록 서류를 작성하는 것이 무엇보다 중요하다 그래서 오늘 내내 제가 강조 드린 거죠. 
사례를 하나 보죠. 왼쪽에 보시면
참석자 1 
허리 문이 하나 있어요. 허리 문이 아주 일반적인 퀄리예요. 
패지 처리 리죠 기마다 좀 패딩 하는 방식이 다른데 이게 오라클에서의 패딩 처리 방법이 안쪽에서 커리어를 수행을 했고 등록 일시 역순 질문이랑 코드 어센딩 보호 어센딩을 종료를 합니다. 
종료를 하고 로놈 조건으로 30건을 출해요. 
그 30건에 대해서 번호를 부여합니다. 
로놈으로 그럼 1 2 3부터 30까지 번호가 부여되겠죠.

참석자 1 
그 번호 기준으로 20일부터 30까지 즉 3페이지 출력하는 코리에요. 
3페이지 1 페이지에서는 여기 여기 로덤이 10이 될 것이고 얘는 1부터 10 될 것이고 2 페이지에는 여기 로덤이 20이 되고 11부터 20 3 페이지에서는 지금 보시는 것처럼 3페이지에는 40 30일부터 40 이렇게 되겠죠. 
이런 패턴을 보통 페이징 처리를 합니다.

참석자 1 
안에서는 게시판 회원 게시판 이어 질문 이가 조인을 하고 있고 댓글 베스트 세는 스칼라 서브 커리도 있고 펌션을 이용해서 아이콘 질문 형도 던져주면 그 아이콘에 해당하는 url 위치를 리턴해주는 그런 이 코리를 분석을 하셔서 이 코리가 갖고 있는 비효율적인 요소를 한번 찾아보세요.

참석자 1 
다시 말씀드리지만 요 동문장 동일한 내포를 반복해 있지 않겠다. 
필요한 투수 블락만 있겠다. 이 관점에서 허리를 들여다보기 시작하는 순간 전에 안 보이던 문제점들이 보이기 시작해요. 
그리고 그 문제점을 발견하는 순간 그럼 이렇게 하면 되겠다라는 솔루션이 자연스럽게 나오는 거죠. 
자연스럽게 누가 가르쳐주지 않아 한번 찾아보세요.

참석자 1 
커리투닝을 한 번도 안 해본 분들께 좀 질문을 드려볼게요 고주환 님 어디 계세요. 
네 차우셨나요. 노원 에다가 아스타이크 세트간 제거하고 그 밑에서 안 하겠습니다 가능합니다 가능해요.

참석자 1 
그런데 그거는 아주 최악입니다. 나중에 저희가 마지막 날 서면 될 텐데 절대 하지 말아야 돼요 말씀하신 대로 하더라도 결과가 보장이 됩니다 고생이 돼요. 
지금 여기 무슨 얘기냐면 이거 로덤 조건을 주지 않더라도 로 조건 로덤 30 조건을 주지 않더라도 이걸 주지 않더라도 보세요. 
데이터 읽었고 지금 30건을 취해서 번호를 부여했지 않습니까 번호 부여하지 않고 30건을 취하지 않고 그냥 번호를 부여해도 돼요. 
그 번호 기준으로 20 30
참석자 1 
그죠 그럼 결과는 똑같잖아요. 결과는 똑같으니까 이 로는 조건 없어도 되는데 넣은 거네 이렇게 생각할 수 있는데 그럼 안 됩니다. 
그렇게 하는 순간 성능이 훨씬 더 나빠지는 나중에 우리가 배울 내용 중에 하나인데 사실 하면 안 되는 아침 패턴 중에 하나입니다. 
또 다른 분 누가 있을까요. 또 김관욱 님 어디 계세요. 
네 네
참석자 1 
어떤 부분이 교육적인 부분 이십니까 내부 처리를 계속 반복되니까 네 여러 번 쓸 때 사용하는 그를 해서 내부 코리가 감복성이니까 여러 번 여러 번 쓰는 잘 기억이 안 나는데

참석자 1 
코리가 여러분한테 한번 이렇게 발디면스요 네 발디면서 썼어 신발 된다 그것도 도움이 되겠죠. 
근데 다행히 수익비가 높지는 않은 처리입니다. 
수익비가 높지 않으면 그건 큰 알 수 있겠죠. 
또 김만재 님은 잘 모르겠어요. 보시겠어요.

참석자 1 
박신진 님은 스칼라 코리를 라이프로 빼면 스칼라소브 커리를 블라인드로 빼서

참석자 1 
그것도 30분 시간 하는데 그렇게 완료해서 파운트 완료를 해서

참석자 1 
이 콜의 가장 큰 문제점을 제가 설명을 해드려버리면 이 게시판 테이블에서 특정 게시판 유용 코드 예를 들면 뉴스라는 게시판 유형 코드를 입력을 한 거예요. 
뉴스 뉴스가 굉장히 많을 거 아니에요. 
지난 10년 동안 20년 동안 얼마나 많은 뉴스가 쌓인 이 아무튼 그중에서 이 게시판 이용 코드에 해당하는 뉴스에 해당하는 게시판이 예를 들면 10만 건이다라고 생각해볼게요 그러면 그 10만 개를 읽어서

참석자 1 
회원과 조인을 하죠. 몇 번 10만 번 조인하죠. 
네 게시판 유형과 10만 번 조인하죠. 
네 또 질문 유형과 10만 번 조인을 해요. 
그리고 이 댓글 기수에는 스칼라 서브 코리를 10만 번 수행을 해요. 
그다음에 이 펌션 펌션 이 질문형 코드 입력하면 아이콘을 리턴하는 펌션 이 안에 들어가 보면 또 다른 서브 코리가 또 있을 거예요. 
펌션 안에 들어가면 보통 코리가 또 들어있거든요.

참석자 1 
그 쿼리가 또 수행이 됩니다. 10만 번 이렇게 열심히 교인도 막 10만 번 1만 번 10만 번 하고 댓글 개수도 10만 번 세고 펑션도 10만 번 실행하고 했는데 정렬 하고는 그중에서 30개를 추출했어요. 
그 30개에 대해서 번호를 부여하고 그것도 모자라서 그중에서 10개를 마지막으로 최종적으로 출력을 해요. 
화면에는 탈락 10개 이고도 출력이 되는데 그 과정에서

참석자 1 
몇십만 번의 조인을 했고 몇십만 번의 스크라 서포크를 수행을 했고 몇십만 번의 펌션을 호출을 했다는 얘기죠 이것이 문제점이에요. 
문제점 알았어요. 어떻게 하면 될까요. 
잘자 조건을 예 그것도 좋은 방법 중에 하나입니다. 
조건들을 넣어서 그렇게까지 데이터를 잃지 않도록 그러니까

참석자 1 
예를 들면 등록 일시이니까 등록 일시 등록은 최근 대서 한번 보도록 근데 그러면 어쨌든 집값의 정의가 달라지는 거죠. 
기존에는 뷰 페이지를 계속 누르면 어쨌든 저 뒤에 10년 치 데이터도 볼 수 있는데 조건들을 추가하게 되면 실체 전 데이터 못 보는 거죠. 
체력화만 보는 거죠. 좋은 방법이긴 해요. 
하지만 어쨌든 커리의 결과 지표가 달라지는 거기 때문에 그럼 트윙은 현업이랑

참석자 1 
만나서 얘기를 해봐야 되겠죠. 그 한 이 뉴스는 보통 일주일치만 조회하던데 일주일치 조회 이렇게 걸면 되지 않느냐 그러면 거기 맞아요. 
사실은 보통 오늘은 어제밖에 안 봐요 솔직히 하시죠 그럴 수도 있지만 무슨 소리냐 우리는 가끔 쫙 뒤에 라스트 페이지도 가끔 들여다본다 그럼 불가능한 거죠.

참석자 1 
또 다른 방법 뭐가 있을까요.
참석자 1 
이게 트윙 된 커입니다. 우선은 댓글 개수 세는 스칼라 소 커리를 맨 상단으로 올려요. 
그다음에 펑션 아이콘 펌션도 맨 바깥쪽으로 빼요 그러면 저 펌션과 저 댓글 스크라 서크를 몇 번 시행될까요. 
10번 실행됐어 갈까요. 아까는 10만 번씩 실행했었는데 이제는 10번으로 줄어들어요. 
그죠 화면에 실력 때는 맨 최종적인 10건에 대해서만 스클라스 프레이를 세고

참석자 1 
댓글 개수를 세고 포션을 호출하고 그다음에 안에서는 조이면 게시판 기준으로 회원과 유인하고 게시판 유인가 중 가 질문 중 각각 10만 번씩 했는데 여기 보시면 게시판 테이브를 먼저 읽어서 10만 건을 취해요. 
10만 건을 취하고 정렬을 하고 경멸하는 기준으로 30건을 추출합니다. 
그 30건에 대해서 번호를 부여하고 그다음에 그 30건에 대해서 30건 중에서 번호를 부여하고

참석자 1 
번호 기준으로 20일부터 30까지라는 조건 그러면 10건이 최종적으로 선택이 되겠죠. 
그 10건에 대해서 회원과 조인하고 그 10건에 대해서 게시판 이용가 조인하고 그 10건에 대해서 질문 연가 조인을 하는 거예요. 
그러면 30만 번 조회하는 것이 30분으로 줄어들죠 일량이 비교가 안 되는 거예요. 
그죠 몇십만 배의 1량 차이가 나는 겁니다. 
결과 제품은 어때요 똑같죠. 결과 제품은 똑같지만 1량은 완전히 다른

참석자 1 
커리를 작게 짜주셔야 된다는 얘기요 여기까지

참석자 1 
요즘에는 프레임업을 많이 쓰다 보니까 우리 개발자들은 보통 이 맨 안쪽에 있는 이 프리만 작성해요. 
그러면 이제 프레임웍에서 이 위쪽 아래쪽 패딩을 위한 부분은 자동으로 그래서 이런 식의 비율적인 프레임 더 많이 지금 보여지고 있는데 그렇다고 그 프레임을 쓰지 말라는 얘기는 아닙니다.

참석자 1 
만약에 이 안쪽에서 조회되는 쿼리가 저는 굉장히 많다라고 지금 가정한 거지 않습니까 10만 건 1만 건 이게 화면에 10건만 보여주니까 이제 이런 얘기를 하는 건데 만약에 이 안에서 도는 거리가 10건 미만이거나 또는 20건 30건밖에 안 된다고 하면 굳이 이렇게 안 해도 돼요. 
이렇게 안 해도 되고 쓰셔도 됩니다. 
큰 문제 없습니다. 그 일반적으로는 주의 조건이 사실 그렇고요 대부분 몇 건 없기 때문에

참석자 1 
프레임업 기능을 잘 활용해서 효율적으로 코딩하시면 돼요 근데 다만 그렇지 않고 데이터가 많은 경우 그는 데이터가 몇십 만 건 되고 몇백만 건 되는데도 불구하고 이 왼쪽에 특권처럼 프레임업 기능을 이용하게 되면 굉장히 비율적인 문제를 야기한다는 얘기입니다. 
그런 경우에는 프레임업 기능을 이용하지 말고 직접 이렇게

참석자 1 
페이징을 구현해 주셔야 된다는 얘기예요. 
대부 프레임으로 다 그것을 지원합니다. 
프레임 구멍의 기능을 이용할 수도 있고 직접 확인할 수 있도록 지원하기 때문에 그런 경우에 한해서 우주처럼 이렇게 토딩을 해 주면 된다는

참석자 1 
또 다른 사람 한번 볼까요. 왼쪽에 에스케이 하나 있는데 이 에스케를 보시고 이 에스케의 문제점과 추인 강안을 한번 찾아보세요. 
제가 계속 강조드리는데 문제점을 먼저 찾으셔야 돼요 그러면 문제점을 찾으려고 하는데 막 밥부터 얘기하세요. 
그 패턴 위주로 공부했거든요. 문제점이 뭔지를 먼저 집행하시고 그걸 바탕으로 팀이 말 하셔야 돼요 문제점이 뭔지를 정확히 아는 게 우선이에요.

참석자 1 
시간이 많지 않으니까 이걸 다 분석할 수 없고 힌트는 맨 위쪽에 한 줄만 보세요. 
아래쪽을 다 볼 필요 없고 네 맨 윗줄에 한 줄만 보세요. 
디코드가 뭔지 아십니까 디코드 워라크 안 쓰신 분들은 잘 볼 수 있는데 케이스 문이라고 똑같이 보시면 돼요 첫 번째와 두 번째 인자가 같으면 세 번째 값 바르면 네 번째 값을 인상하다 그런 게

참석자 1 
첫 번째 인자랑 두 번째 인자를 비교해서 같으면 세 번째 인자를 반환하고 바르면 네 번째 인자를 반환하라 그런

참석자 1 
어떤 문제점이 있습니까
참석자 1 
재밌어 카운트 할때 아스카 카운트 할 때 아스카 입니다. 
그것도 이제 개발자분들이 잘못 알고 있는 상식 왠지 아스타를 쓰면 모든 클라운드 다 입을 것 같아요. 
그죠 근데 그렇지 않아요. 그래서 보통 아스타 아스 이를 쓰시죠 그 이제 만

참석자 1 
sk 초보자들도 그걸 보면서 여기서 왜 일을 쓰는 거죠. 
질문을 합니다. 그 일을 쓰는 분은 나를 투자한다고 일을 쓰는 거예요. 
그런데 시중에 전혀 도움이 안 됩니다. 
해보시면 알아요. 성차이가 전혀 없어요. 
일을 쓰나 아스타 쓰나 왠지 아스타스는 모든 클러 다 이것 같은데 그렇지 않죠.

참석자 1 
그런 식의 그렇다고 이을 쓴다고 성분이 더 나빠지는 건 아니니까 그대로 쓰셔도 되긴 하는데 잘못 알고 있는 형식들이 많아요. 
그렇다더라 해보면 별 차이가 없는 이 콜을 작성한 개발자 저작자죠 저작자의 의도를 한번 볼까요. 
저 작자가 이 카운트
참석자 1 
즉 이 아래쪽에 두 테이블 주입을 하고 이런 필수 조건을 갖고 있는데 이 조건을 만족하는 데이터 건수에 관심이 있어요. 
없어요. 건수에 선수에는 관심이 없죠. 
그죠 즉 이 조건을 만족하는 데이터가 카운트가 0이면 0이면 즉 데이터가 없으면 nl 리턴하고 0이 아니면 즉 데이터가 있으면 와이를 리하고 싶은 거예요. 
데이터 존재 여부만큼 궁금한 거죠. 그런데 카운트를 쓰니까

참석자 1 
옵티마이저는 카운트를 셉니다. 전체 데이터를 다 카운트를 해요. 
그리고 나서 그 값이 0이냐 1이냐 이냐 3이냐 100이냐 1천이냐에 따라서 엔드는 와이를 정하는 거예요. 
효율적이죠. 그죠 어떻게 하면 될까요. 
맨 아래 틀에다가 앤드 로너 로컬 일 또는 밴드 로너 1보다 작고 나갔다. 
이렇게 해 주시면 되죠 그럼 오라클은 이제 다른 비비는 그런 게 없지만 오라클은 로넘을 쓰게 되면

참석자 1 
그 조건을 만족하는 건수를 만나면 바로 멈추거든요. 
도는 이보다 적거나 왔다. 즉 데이터를 한 건을 딱 만드는 순간 더 이상 데이터를 안 읽어요. 
그래서 멈춰버리는 거예요. 그러면 여기 카트 함수에서는 항상 영 아니면 이를 일타하겠죠. 
2 이상의 값은 일타나지 않습니다. 데이터를 찾으면 바로 멈추도록 그렇게 그래서 앤드 로너 1보다 다가놨다. 
이퀄 1 해도 되고
참석자 1 
잡고 나갔다. 일을 하셔도 돼요. 그런데 습관적으로 잡고 나갔다고 하세요. 
이거 과거의 잔재인데 거기에 좀 버그가 있었습니다. 
리코 일을 했을 때 나가 싫은 게 좀 꼬이는 그런 버거도 있어서 팀원들이 그때부터 이제 로원을 쓸 때는 이보다 다 나왔다 이렇게 쓰는 음식이 생겼습니다. 
물론 그 버그는 최근에는 해결된 걸로 알고 있는데 그렇다고 하더라도 구동 콜로 하는 것이 안전하지 않을까 싶습니다.

참석자 1 
특히 발리건을 쓸 때 그런 도자기가 나왔다 안 썼어요. 
더블 발리 로 넛 잡고 나갔다. 발리건을 이렇게 썼어 안전을 기하기 위해서 그 한번 봤고 우측에 있는 코리도 한번 보겠어

참석자 1 
수위에 있는 커리도 비슷해요. 여러분들 커리는 서브 커리가 있을 수 있잖아요. 
서리 서브 커리는 기본적으로 메인 커리의 종속적이고 계층적인 관계를 갖고 있는 종속적이고 계층적이라는 얘기는 메이커리에 종속돼 있다는 얘기예요. 
무슨 얘기냐면 메이커리가 예를 들면 amp 빌즈 여기보다 크다는 조건에 의해서

참석자 1 
메이커의 결과처럼 10만 건이면 그 10만 건에서 건건이 서브 커리를 10만 건 실행하는 그런 구조로 실행이 됩니다.

참석자 1 
계층적이고 종속적이기 때문에 그런 거예요. 
독립적으로 실행할 수 없다는 얘기죠 서프터리를 물론 나중에 이제 여러분들이 커리 변환 컨트를 공부해 보시고 나면 커리 변환을 통해서 서브 커리가 별도로 수행될 수 있는 그런 방법도 제공이 되긴 해요. 
그런 기비가 있기도 하고 없기도 하고 또 그런 기능이 있다고 하더라도 작성하기도 하고 작성하지 않고 그래서 여러분들 일단은 설면을 배우기 전까지는

참석자 1 
서브커링은 기본적으로 메이커의 종속적이다. 
그렇기 때문에 메이커의 건수만큼 반복적으로 서프코링을 수행하면서 필터링을 한다 이렇게 이해하시면 되겠습니다. 
그러면 여기 ap 빌즈는 여기보다 크다는 조건에 해당하는 데 일단 10만 권이다. 
그러면 이 서프코리가 10만 번 실행돼요 10만 번 실행되면서 좋은 조건 그리고 와이알 엠맨 이 조건을 가지고 필터링을 하죠.

참석자 1 
카운트를 세는 거예요. 카운트를 세서 건수가 0인지 아닌지를 확인을 하고 있는 거죠. 
그럼 정말 카운트를 세요. 왜 말 안 이 조건을 만족하는 데이터 건수를 매번 한 효율적이죠. 
그죠 어떻게 하면 될까요. 마찬가지로 소크레 안에다 앤드 론으로 쓰셔도 돼요. 
앤드 로너 일본에서 났다. 그러면 풀거를 만나면 바로 일을 리턴하고

참석자 1 
없으면 0을 다 그래서 그 값에 따라서 트로포스가 있어야 되겠죠. 
그런 방법도 있지만 굳이 이렇게 하실 필요 없어요. 
어떻게 하시면 돼요 그쵸 나디그스트 그죠 이게 0이어야 투어가 되는 거니까 그 없어야 투가 되는 거니까 이그지스트가 아니라 나 디그스트를 쓸 수 있는 나 비글 시트를 쓰시게 되면 이글시시트나 나 이글 시트는 그 연산자 특성상 존재 여부를 확인하는 연산자이기 때문에 데이터를 한 번이라도 만나면 바로 빠져나가요

참석자 1 
가상 현상을 하죠. 그래서 낮 이미지 때 쓰시면 되고 그때 여기 카운터에는 카운트 쓰시면 안 되고요 일 또는 아스타 이런 거 쓰

참석자 1 
카드 쓰시면 결과 이 개발자분은 이주 리스트 라디피트 존재 자체를 몰랐거나 알았더라도 우리 연산자의 그런 특징이 있다는 걸 몰랐을 수도 있겠죠. 
그죠 그걸 이렇게 좋은 부분을 지원하면

참석자 1 
이런 사례들이 제가 억지로 이렇게 교육 환경을 만들어낸 사례들이 아니고 실제로 제가 다 현장 다니면서 수입한 사례들입니다. 
왼쪽에 있는 사회는 교육 학술 전원 스테이스 그러면 이제 표준화도 안 돼 있죠 그죠 테이블 클라면 표준화가 안 돼 있어 유저 아이디 시스템 아이디 gh 권한 아이 권한 권한 거 예전에 우리가 칼럼을 이렇게 많이 썼잖아요. 
한글 발음 그냥 그대로라고
참석자 1 
조직 그레이드 이어 hd 포스 이런 그 밑에 보면 단위 조직 시 단위 업무 시 요즘에 이런 시스템이 거의 표준을 다 하기 때문에 크레이브랑 칼럼형을 다 표준 하 아주 오래전 사례라고 보면 표준하지 않은 오른쪽 거리는 오른쪽은 이거 cj 계열사예요. 
cj 테이블 레이하고 지금은 페이 잡고 있는 시 케이블 레스 제가 할 때

참석자 1 
예 말씀해 보세요.
참석자 1 
보여들만 나가이 스로 갈 수는 없잖아요. 
프론드도 같이 해야 되겠죠. 예 어떻게 하면 되는 얼로

참석자 1 
그렇게 하는 게 가능한데 허리가 더 복잡해지잖아요. 
그냥 밑에다가 앤드 런놈 이렇고 갔다. 
갔다 하면 되는데 굳이 얘를 세 주얼 해가지고 나비 비스트를 해가지고 가면 더 복잡하지 않나요. 
가급적이면 더 심플하게 가동성 있게 코를 만드는 우측은 원래부터 거리가 그렇게 생겼으니까 보다 나 있으면 되는데 왼쪽은 원래 부리가 저기 저 저거 보리 질러 타스 프럼지얼

참석자 1 
물론 지형 때문에 일부는 세라스도 다시 거였는데 이제 아이언까지 증가시켜가면서 거 변환해 가면 성능은 왜 똑같다고 볼 수 있어요. 
세블러 기 있는 것 때문에 성능이 이렇게 관이 나빠지는 다 얘기를 하지 않고 그것도 또 다른 질문

참석자 1 
다 들어 인 땡땡 땡땡이 그래서 랭기지마다 다른데 물음표를 쓰는 데도 있고 땡땡 1 땡땡 엑스 땡땡 y 이렇게 한 아이 이게 답변이 다양하게 들어갈 수 있다. 
또 다른 질문
참석자 1 
이 커리는 어때요 이 코리 이 코리 이 프로그램인데 이 프로그램이 뉴

참석자 1 
불필요한 데이터를 읽고 있지는 않은지 관점에서 보시면 되는 거예요.

참석자 1 
굳이 입지 않은 렌트카를 입는 거
참석자 1 
지금 보시면 가 정산에 대해서 법인 부서 부분 체결 입찰 지정 코드 등등 조건을 가지고 카운트를 합니다. 
그리고 나서 그 카운터가 0보다 큰지를 확인을 해요. 
0보다 크면 똑같은 조건으로 데이터를 삭제하고 있습니다. 
삭제하기 전에 카운트를 굳이 할 필요가 있을까요. 
카운트를 하고 여기다 큰지 확인하고 지울 필요가 있을까요. 
그냥 지우면 되잖아요.
참석자 1 
그냥 지었을 때 조건들을 만족한 데이터가 있으면 데이터가 지어질 것이고 없으면 지어지 않을 것이고

참석자 1 
이제 우리들 머릿속에는 딜리트는 은지 부담이 큰 작업일 거라는 생각이 들어요. 
저도 이제 그랬거든요. 이제 핵심 본 거죠. 
아무래도 셀렉트가 더 가벼우니까 가벼운 셀렉트를 한번 날려서 코스를 세워 병보다 클 때만 들리트를 날리게끔 하겠다는 거죠. 
그러니까 그게 뭐 필요하냐는 거죠. 어차피 딜리트 날리면 데이터를 조회를 먼저 하거든요. 
조회해서 삭제할 대상이 있는지를 확인하고 있으면 지우가 없으면 안 지우는 거예요.

참석자 1 
저렇게 짜게 되면 이 데이터를 두 번 있는 거지 않습니까

참석자 1 
혹시 로고를 남기려고 그러지 않았을까요. 
선수 딜리트 하 컨스가 몇 건인지를 미리 확인하고 삭제한 다음에 지어진 컨스를 더불어 남기겠다. 
그 핑계가 안 되는 게 딜리트를 딱 하고 나면 어떤 특정 함수를 호출하게 되면 방금 지체에 삭제된 레코드를 반응하게 해주는 함수들이 다 있어요. 
그걸 쓰면 되겠죠. 오히려 이렇게 해서 코리 하게 되면 어떤 문제가 있냐면

참석자 1 
셀렉트를 하고 딜리트를 합니다. 근데 중간에 다른 어떤 트렉션에서 중간에 데이터를 추가를 했어요. 
추가를 그럼 여기서는 100만 건이었는데 1만 건이었는데 중간에 1천 건이 추가됐어요. 
그리고 삭제를 합니다. 그러면 그 추가된 데이터도 같이 삭제가 돼 버려요. 
그럼 앞에서는 100만 권이 읽었는데 실제 삭제된 데이터는 10만 천 건이 되는 거죠.

참석자 1 
로우 데이터가 오히려 불확실한 정확하지 않은 값을 녹으로 남기게 되는 거예요. 
성능도 중요하지만 얘네들이 정확성 측면에서 일관성 측면에서 고려를 하셔야 돼요 지난에 제가 멀티 버전 컴퍼러시 컨트롤 줄여서 mvcc라는 모델을 설명드렸죠. 
그게 필요한 이유가 바로 그것 때문에 필요한 거 데이터 정확성 커리를 한 쿼리 안에서도 일관성이 깨질 수가 있어요. 
그래서 오라클은 mbc 제 모델을 보던 거고

참석자 1 
커리 안에서도 데이터가 달라질 수 있는데 심지어 데이터를 두 개의 커리로 나눠서 조회하게 되면 앞에서 수행한 커리랑 뒤에서 수행한 커리랑 그러니까 같은이라는 보장이 없습니다. 
왜냐면 db는 나 혼자 쓰는 db가 아니잖아요. 
스탠 버로 db가 아니잖습니까 많은 다수의 사용자들이 동시에 에피스 하기 때문에 허리와 허리 사이에 중간에 있었던 업데이트 비트가 발생한다는 얘기입니다. 
그렇기 때문에 허리를 두 번 날리지만 기본적으로

참석자 1 
그리고 두 커리의 결과 셋이 달라질 수 있다는 가정을 갖고 여러분들이 코딩을 하셔야 해요. 
그것을 방지하기 위한 다양한 공식성 제한 기법들을 활용을 해 주셔야 합니다. 
그런 걸 잘 몰라요 그렇죠 그냥 마치 스탠더러 디비에서 코딩하듯이 예를 들면 엑세스라든지 엑세스 디비 디베이트 플러스라든지 과거에 쓰던 그런 디베이트 환경에서나 어울릴 법한 그런 특성이 쓴다.

참석자 1 
안 된다 그래서 이 경우에는 그런 정확성 이식도 있을 수 있고 성능 측면에서도 카운트를 굳이 이해할 필요가 없다는 얘기죠

참석자 1 
시간이 조금 있는데 슬레이 2개밖에 안 되지만 금 설명을 내리겠습니다 시켰는데 40분에 이어서 하고 바로 이어서 이렇게 넘어가도록 하겠습니다.

참석자 1 
모르겠어
