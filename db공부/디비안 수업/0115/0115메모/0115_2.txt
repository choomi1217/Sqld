참석자 1 
드시다가 어렵다. 그러면 줄을 맞고 잠깐 깐 하세요. 
나중에 수업 끝나고 교육 명이 어렵다. 
이런 얘기하지 마시고 이거는 원래 교육 내용 없던 건데 원래 그것까지는 설명을 해야 될 내용이 마지막 질문이 나왔으니까 이제 설명을 드리는 거니까 어르신 분들 잠깐 들이 맞고 계셔도 될 것 같습니다.

참석자 1 
여기 이제 서버 프로세스가 이렇게 있어요. 
서버 프로세스가 있는데 이 서버 프로세스가 우리를 대신해서 모든 일을 다 해주는 거예요. 
허리를 패싱하고 스타싱한 커리를 최적화해서 실행하면서 하는 모든 일련의 과정들을 이 서브 프로세스 다 오늘 대신해서 되는 겁니다. 
어떤 블록을 딱 허리를 수행하는 거 과정에서 읽으려고 딱 보니까 내가 입으려 한 블록을 피시로 찾아보겠죠. 
피시를 찾아보니까 그 블록이 없어요.
참석자 1 
없으면 새로운 블록 새로운 블록을 찾아서 얘를 로딩을 해야 될 거 아니에요. 
그렇죠 로딩을 하려고 하니까 공간이 꽉 차서 없어요. 
이미 캐시가 다 한 상태예요. 그럼 새로운 블록을 올리려고 하면 기존에 캐시가 있던 블록들을 일부를 밀어내야 되겠죠. 
그죠
참석자 1 
밀어놓을 때 블락을 그냥 그냥 버려버리면 안 되거든요. 
예를 들면 어떤 블락이 이렇게 있는데 얘가 업데이트가 일어났어요. 
이 원본 블록은 여기 있는 원본은 여기 있는데 이 블록을 메모리에 올려놓고 업데이트를 친 거예요. 
근데 아직 공기화가 안 돼 있죠 공기화가 여기 있는 값과 여기에 있는 값이 서로 다를 수 있다는 얘기입니다. 
예를 들면 여기에는 a라는 값이 저장이 돼 있는데

참석자 1 
여기는 비란 값이 전환이 돼 있다는 얘기죠 그러면 그냥 플러싱 해버리면 안 되잖아요. 
그죠 동결을 시켜놓고 플러싱을 해야 되겠죠. 
그래서 이 동기화되지 않은 글라스트를 동기화시켜주는 역할을 하는 게 비비 라이터예요. 
비비 라이터 얘를 동기화시켜준다라는 거죠. 
그 그래서 얘가 이 블록을 올리려고 보니까 공간이 없어서

참석자 1 
디비 라이트 한 때 야 지금 내가 공간을 캐릭터의 공간이 필요한데 공간이 꽉 찼네 공간 좀 비워달라고 시그널을 보내는 거예요. 
사업 프로세스가 소가 프로 시그널을 보내놓고 잠을 잔다라는 얘기죠 그런데 이 디기 라이터가 얘를 그냥 비우면 안 돼요

참석자 1 
dv 바고 게 수도 있지만 이 옆에 보면은 뭐가 있냐면

참석자 1 
리브 로브 캐시가 있어요. 리드 로브 오퍼 리드 로브 그걸 얘기하기 전에 잠깐만요 이걸 먼저 일어나

참석자 1 
우리가 이 메모리에서 메모리에서 데이터를 업데이트 한다는 얘기죠 업데이트 하는데 이 메모리는 언제든지 날아갈 수가 있어요. 
그죠 정전에 의해서 그럴 수도 있고 시스템 내부적 벽에 의해서 럴 수도 있고 이 손실될 수 있다라는 얘기죠 그렇기 때문에 내부적으로 뭘 두냐면 로그 파일을 줘요. 
리드 로그 파일 윈 로그 파일
참석자 1 
그래서 이 프로세스가 여기 메모리에서 값을 변경할 때는 항상 로그를 먼저 남깁니다. 
로그를 로그를 남겨놓고 그리고 그게 하는 거예요. 
그러면 메모리 번포 기체가 날아간다고 하더라도 로그를 이용해서 언제든지 재생할 수 있으니까 데이터를 살려낼 수 있다는 얘기죠 데이터의 연속성이 보장이 된다. 
우리가 db를 얘기할 때 트랙션의 4대 속성 뭐죠 a씨 아이디 오토메 시티 그

참석자 1 
원자성이 해야 되고 c 컨시턴씨 일관성이 있어야 되고 인테그리티 아이 또는 이제 정합성을 얘기하는 거죠. 
마지막에 이 기업 일렉트지 않습니까 영속성이 보장이 돼야 된다는 얘기죠 트랜지션이 성공을 했으면 그 데이터는 영구적으로 보장이 돼야 된다는 얘기예요. 
그것을 가능하게 하는 것이 리드 로그예요. 
메모리가 유출되더라도 얘가 아직 디스크에 반영이 안 됐지만

참석자 1 
이렇게 반영이 안 됐지만 얘가 있기 때문에 안심하고 우리가 메모리를 잡고 할 수 있다라는 얘기죠 근데 리드 로그 파일은 얘가 또 빠야 되지 않습니까 그럼 여기서 내부에서 변경할 때 계속 로그를 남긴다는 얘기는 겨우 디스카이에 가세하는 거예요. 
그래서 성능을 빠르게 하기 위해서 또 뭘 주냐면 포켓 시드니다. 
무슨 뜻이냐 리브 로브 버퍼
참석자 1 
그 캐시를 두는 거야 그래서 이 파일에 기록하기 전에 먼저 메모리에다가 남겨요. 
메모리에 그래서 어떤 메페이냐면 여러분들 특히 stl p 공부하시는 분들 꼭 기억하셔야 될 개념 중에 하나가 뭐냐면 light ar head 로깅 이게 무슨 말입니까 항상 로그를 먼저 기록해야 된다 로그

참석자 1 
그래서 여기다가 값을 변경하기 전에 여기서 값을 변경하려고 하면 로그를 먼저 기록하는 거예요. 
로그를 기록해놓고 그리고 나서 변경하는 거예요. 
그리고 나서 아까 말씀드린 것처럼 서브 프로세스가 중간이 필요하실 때 디라이트한테 공간을 빌려달라고 한다 그랬죠 그렇죠 그러면 이 데이터를

참석자 1 
동기화되지 않은 비동기 더티 블록이라고 얘기하죠. 
더티 블록 더티 블록 동기화되지 않은 블록을 더티 블록들을 비워주는 겁니다. 
워줄 때 그 때 얘를 그냥 비우는 게 아니고 먼저 이쪽 로그를 얘와 관련된 로그를 먼저 기록을 해야 돼요 그래서 이 로고를 기우는 역할을 누가 하느냐 로그 라이터가 있어 로그 라이터가 그럼 결국 정리하면 어떻게 되는 거냐면

참석자 1 
이 서브 프레시스가 디비 라이트에게 10만 점을 확보해달라 그러면 알았어 그럼 얘는 어떻게 하냐면 내가 지금 동기화하려고 하는 버퍼 블라들 더티 블라클이죠. 
더티 블라클에 대한 요구를 기록해 다오라고 디비 라이터에게 코를 하는 겁니다. 
그러면 서브 폴 스시는 디비 라이터에게 코라고 슬립을 하죠. 
디비라이터도 마찬가지로 로그 라이터에게 로그를 비워 코라고 얘는 또 슬립을 해요. 
로그 라이터가
참석자 1 
여기 있는 로고들을 디스크에 기록을 해요. 
기록을 다 끝내면 다 했어 실어 주는 거예요. 
그럼 그때 비로소 얘가 이 더티블런트를 디스크에다 기록을 합니다. 
그렇게 해서 메모리와 디스크를 동기화시켜주는 거예요. 
동기화가 됐으면 동기화된 블록들은 언제든지 플러싱 해도 되죠. 
그죠 동기가 됐으니까 그러면
참석자 1 
동결을 해주고 동결하고 비워주면 얘가 빈 블록들을 빈 공간에다가 새로운 블록을 적재를 하게 되는 거예요.

참석자 1 
그래서 이 라이트 와이드 로깅 뭐냐면 캐시에서 데이터를 기록할 때도 항상 로그가 바뀐다 그다음에 그 pc 데이터를 디스크에 기록할 때도 항상 로그가 먼저다 항상 로그를 먼저 기록해야 된다는 얘기예요. 
이게 표현한 것이 라이트 어헤드 로그인이라는 개념이고 그다음에 이 로봇은 보통 10mg 정도밖에 안 되는 작은 사이드예요.

참석자 1 
그렇기 때문에 데이터를 수천만 건을 막 업데이트 있어트 하게 되면 계속 보완할 수가 없습니다. 
로고를 수시로 기억을 해요. 수시로 수시로 파리에 다 기억을 합니다. 
기록을 합니다. 하지만 적어도 적어도 코믹한 시점에 기억을 해내는 거예요. 
공간이 찰 때마다 수시로 기록을 하는데 공간을 찾는데 기록을 하는데 공간이 차지 않더라도 적어도 커 시점에는 기록을 해야 됩니다.

참석자 1 
이 프로세스가 업데이트를 다 끝내고 컴퓨터를 딱 했어요. 
컴퓨터 했는데 로그도 메모리에 남아 있고 변경된 데이터도 메뉴에 남아 있고 정립이 되면 데이터가 유실이 되지 않습니까 설계한 코밑에서 여기서 프레션을 마쳤는데 그 데이터가 20개 시는 가능성이 있다는 얘기죠 그렇기 때문에 펌을 딱 하는 순간은 무조건 로그를 기록해야 돼요

참석자 1 
변경한 블록은 나중에 디스크에 반영한다고 하더라도 이거만이라도 적어도 빨리 기록해 두게 되면 혹시라도 얘가 날아갔을 때 크레이 됐을 때 탈리 할 수가 있다는 얘기죠 그 개념을 우리가 뭐라고 그러니까 아시는 분 로고 콜스 합니다. 
적어도 커미시점에서 로그를 방대하다는 얘기

참석자 1 
로고 폴스의 컵이 이 두 개념을 꼭 기억하세요. 
라이트 와이드 로이 로고 폴스의 컵이
참석자 1 
이렇게 그러면은 일부 파일에 게 등록을 하게 될 때 가 인정을 하게 될 텐데 네 이쪽에 들어가는 아이 기다리고 있죠 얘가 뭐라고 그랬습니까 공간 확보해다 요구했더니 얘가 알아서 해놓고는 로그라이트한테 먼저 신호를 보내고

참석자 1 
내가 써라고 신호가 와서 공방을 비우고 그러면 그 전에는 깨어날 수 있지 않습니까 아까 말한 것처럼 뭔가 선행 작업이 완료 돼야지 우리가 이제 잠을 자는 여러 가지 이유가 있다고 했는데

참석자 1 
두 번째가 하는 거예요. 다른 프로세스에 의한 수정 작업이 완료되기를 기다릴 때 그 프로세스가 상호 작용이라는 게 지금이 바로 프로세스가 상호 작용이잖아요.

참석자 1 
여기까지 다 이해가 되시는 분들 계실 거고 아무튼

참석자 1 
질문
참석자 1 
어떤 건가 이거 이거 원 이건 디스크죠 디스크 데이터 파일을 의미하는 거고 우리가 보통 기술을 원만 표현하잖아요. 
물론 그 안에는 이제 여러 가지 데이터를 가지고 눌려져 있을 것이고 그 안에 특정 블록들을 얘기할수

참석자 1 
페이지 하고 넘어가겠습니다. 들어가면
참석자 1 
질문을 쉬는 시간 말고 수업 시간에 있으시면 제가 딱 듣고 다른 분들에게도 도움이 될 만한 내용이면 같이 해드리고 만약에 다른 분들에게는 그게 안 되는 개인적인 질문이다. 
그러면 제가 쉬는 시간에 답변드리겠습니다 하고 10분이 답변드다 이 설명을 제가 두 번 했어요. 
쉬는 시간에도 하고 또 시간에도 하고 제가 모시는 몸이 마트가는 걸 다 수업 시간에 계속 강의하고 수 시간에 계속 강의를 해야 되니까 지금은

참석자 1 
싱글 블라아이어 멀티 블라라는 개념을 설명드렸고요 그다음에 여기가 또 기억해야 될 개념이 논리적 아이오와 물리적 아이오

참석자 1 
물리적 아이오는 말 그대로 물리적으로 디스크에서 있는 아이오를 얘기하는 거고요 물리적 블록 아이오는 일반적으로 버퍼 캐시에서 있는 메모리에서 읽는 군락을 의미해요. 
근데 사실은 정확히 일치하는 개념은 아니에요. 
논리적 블록 아이오라고 하는 것은 제가 지난주에 말씀드린 것 같은데 특정 커리를 수행하는 데 있어서 일반적으로 읽어야만 하는 블록을 논리적 블록 아이오라고

참석자 1 
말씀드린 것처럼 데이터 인서트 업데이트 빌트가 발생하지 않으면 똑같은 쿼리를 10번 10번 한 번 만 번 수행하더라도 항상 똑같은 양의 블락을 이렇게 돼 있어요. 
논리적으로 그 블락은 플랜도 있게 돼 있다는 얘기죠 그것이 논리적 블록 아이의 개념이에요. 
근데 우리가 왜 버포켓에서 읽는 논리적일까 일반적으로 책 읽을 때는 그렇게 설명할 수 없어요. 
메모에서 읽는 게 논리적 아니거다 왜 버포켓의 읽는 게 논리적일까요.

참석자 1 
일반적으로 법법 계시를 먼저 드셔보고 없으면 디스크를 가니까 가니까 결과적으로는 논리적 아이오가 포켓이 이게 블라 아이랑 일치하게 되는 것이죠. 
그런데 항상 일치하지는 않아요. 일치하지 않을 수 있는데 어떤 경우냐면 다이렉트 패스 아이가 작동하는 경우에 그렇습니다. 
다이렉트 패스 아이 다이렉트 패스 아이라고 하는 것은 네 머리를 경유하지 않고 디스크를 직접 읽어 입는 경우를 얘기하는

참석자 1 
그런 멘탈이 있습니다. 저 대량의 데이터를 처리할 때 게 나을 그러면 논리적인 아이는 어떻게 되느냐 메모리 아이로 더하기 다리투스 아이가 되는 거죠. 
모리 아이 레버랜드 이런 나이와 다이렉트하게 이 나이를 더한 것이 논리적인 인정이 되는 것인데 일반적으로

참석자 1 
바이오텍스 아이가 작성하지 않는다라고 가정하면 메모리 아이로 정도 보이죠. 
아이가 그
참석자 1 
그래서 여러분들이 논리적으로 아이라고 메모리 알아 이게 이해도 크게 무방합니다. 
하지만 내부적으로 다이텍스 아이라는 것이 존재하기 때문에 창이 제 아이다. 
이런 것을 이해하시면 좋을 것 같습니다. 
우리가 전통적으로 아이오 효율을 측정하기 위해서 사용하는 성능 지수가 있는데 버퍼 켓시 히트이에요. 
히 히트율 공시에 보시면
참석자 1 
총 읽은 블락수 분에 캐시에서 곧바로 찾는 블락이에요. 
총 읽은 블락수가 논리적 와이어죠 논리적 와이어 리 리적 와이어 군에 케이지에서 이거 불렀소 하면 논리적 안에서 물리적 바이를 빼면 그것이 바로 케이시 이거 불락이 되겠죠. 
이제 완료가 되는 것이고 공수를 이렇게 만들고 보시는 것이죠. 
그래서 우리가 트레이스 기준으로 이 트레스를 제시하면서 피트를 구해봐라

참석자 1 
어떻게 구해야 돼요 콜이랑 커런트의 합수 물류 요리죠 그게 둘을 합해서 그것을 구분해 주고 고위에서는 어떻게 돼요. 
이 둘에서 디스카를 뺀 거죠. 그게 캐시에서 입은 거가 되겠습니다. 
이렇게 트를 구하면 되겠습니다.
참석자 1 
이건 산수잖아요. 그죠
참석자 1 
위가 다 영인데 일로 돼 있는데 위가 다 0이다. 
어디가 이 여기는 아니다 운명이 형 나와 있는데 케이가 이

참석자 1 
위가 0.5 0.5 이렇게
참석자 1 
그러니까 디스크 커리 컬트 항목이 위가 1이 나온다고요 위에 3명을 넣는데 탈만

참석자 1 
위에는 다 여기인데 토털만 이게 나온다고요 그런 경우는 없는데 이 더해져서 이게 토털이 나오는 거

참석자 1 
있겠죠.
참석자 1 
노리를 불가하잖아요. 위에 것을 권했을 때 피터인데 위에는 여기 있는 주체가 이보다 그게 나온다.

참석자 1 
이 신출 공식 자체를 이해하는 게 중요한 게 아니고 여기서 우리가 뭘 알 수 있냐 는 공식을 통해서

참석자 1 
이 논리적 아이오는 항상 일정합니다. 
그죠 성능은 성능은 디스카가 결정한다고 했어요. 
성능은 그런데 우리가 그 성능을 결정한 디스카이는 우리가 통제할 수가 없다라는 얘기죠 우리가 디스카를 주고 늘리게 할 수가 있습니까 못해요. 
외생 변수다라는 얘기죠 통제 불가능한 외생 변수는 반면에 논리적 와이어는 우리가 줄일 수가 있어요.

참석자 1 
허리를 변환한다든지 아니면 인덱스를 추가한다든지 하천을 도입한다든지 여러 가지 방법들을 이용해서 논리적인 영향을 줄 수 있다는 얘기예요. 
기존에 100만 개 돌라 알려하는 것을 10개 100개로 줄 수 있다는 얘기죠 디스카는 그때그때 달라요 실점 상황에 따라서 해가 높았다. 
나았다 하는 거니까 우리가 어쩔 수 없는 건데 논리적 인력은 줄 수가 있겠죠.

참석자 1 
그래서 논리적 발생량은 항상 일정하지만 sql 팀을 통해서 줄일 수 있는 통제 가능한 재생 변산 논리적 완료다 결국은 논리적 아이유를 줄임으로써 논리적 아이유를 줄게 만드는 것이 그 데스크 트링이에요. 
이해되십니까 성능은 물리적 아이오가 저하지만 그것은 우리가 통제할 수 없다. 
그렇기 때문에 논리적 아이오를 줄여줘서 물리적 아이오가 따라 줄게끔 만드는 게 특이다.

참석자 1 
히트율이 보통 90%라고 했을 때 50%라고 할때 계산했을 때 히트율이 보통 평면이 50%다 그러면 허리를 100만 개를 블록 있는 커리를 짜면 50만 개를 디스크도 있는 거잖아요. 
그죠 근데 논리적으로 100만 개 읽던 거를 논리적으로 1만 개를 줄여버리면 줄여버리면 포까이 50% 적용했을 때 5천 개만 디스크를 읽으면 된다는 의미예요.

참석자 1 
그럼 50만 개의 디스카이오가 5천 개로 줄어들면 성이 빨라지는 거지

참석자 1 
그래서 우리가 성능 측정할 때 시간으로 하지 않는다고 그랬어요. 
그렇죠 시간으로 측정해서 이렇게 보여주는 키워드는 가짜라고 했습니다. 
당장 빨라 보이는데 나중에 하면 그 효과가 안 나오는 거죠. 
마찬가지로 디스크 아이오 기준으로 이렇게 하는 채널도 가짜예요. 
처음에 자기가 코리를 딱 돌렸더니 10초가 걸렸고 디스크가 10만 개 발생했어 그래서 다리 돌렸더니 얘가 메모리에 올라가서 100개로

참석자 1 
10만 개가 100개로 줄었죠. 그게 투입됐다고 이거 완전 가짜죠 사짜죠 물리적 아이오는 격이 다르거든요. 
거기 서 할 수 없기 때문에 항상 논리적 아이오 진으로 성능을 측정을 해야 된다 그렇게 하면 좋겠고요

참석자 1 
시간이 많이 갔으니까 좀 요약을 해보면 그 빠른 데이터 베이스 구현을 하려고 하면 데이터 분석을 왜 드릴까 이 때문에 빠른 데이터 베이스를 구현하려고 하면 잠을 줄여야 된다 프로세스가 잠을 자는 횟수를 줄여야 된다 레코드가 하나 있을 때마다 뻔뻔히 잠을 자면 빠른 세트 하듯이 그냥 일반하겠죠. 
그죠 인덱스를 통해서 예를 들면 100만 개를 읽어요.

참석자 1 
그 이비스에서 100만 개 읽으면 건건이 랜덤 마이어 할 거 아니에요. 
그죠 랜덤 마열를 할 거고 밴드 마이를 하는데 그 상당함수가 메모리에서 읽으면 다행인데 그 상당함수가 거의 싱글 볼라 가열을 한다 메모리에서 못 찾는다는 얘기예요. 
100만 개를 스캔하는 동안에 테이블이 100만 번 가는데 건건이 싱글 블러 아이오 즉 아이오컨이 100만 번 발생한다 100만 개는 아니겠지만 그중에 90만 개가 싱글 블러 아이 발생한다

참석자 1 
뻔뻔히 잠을 자는 거예요. 내 것도 하나 읽을 때마다 관광객이 입어야 되는데 내 것도 하나마다 하나마다 잠을 잤다. 
깼다 잠을 잤다. 깨다 반복하니까 할 수가 없는 것이죠. 
그죠 그래서 엔셀트 랜덤마인 전이라는 말을 바로 여기서 하는 거예요. 
포스로 잠을 자고 자니까 잠을 줄여야 된다 우리가 서울 빼고 가려고 하면 잠을 줄여야 되는 것처럼 좋은 소음을 내려고 하면 잠을 줄여야 돼요 잠을 줄이는 방법이

참석자 1 
캐시 틀을 높이는 거죠. 내가 읽고자 하는 커리들이 대부분 다 메모리에 있을 수 있게 가급적이면 캐시에서 대부분 블러를 살 수 있게끔 하셔야 되는 거예요. 
근데 캐시는 유연한 공간이지 않습니까 유관이 유연하기 때문에 결국 어떻게 해야 되느냐 커 일량 자체를 줄여야죠 커 일량 자체를 줄이면 캐시 듀이 높아집니다. 
모든 커리들이 다 다 100만 개씩 읽어요. 
그럼 메모리에서 올랐다. 내렸다를 계속 반복해야겠죠. 
그렇죠 여분 커리 하나 넣을 때마다 100만 개를 읽어드려야 되니까

참석자 1 
새로운 걸 올리기 위해서 많은 분들을 밀어낼 것이고 또 밀어냄으로 인해서 다른 거리는 또 늘어지고 메모리도 못 찾으니까 그렇게 모든 거를 100만 개씩 알려는 것을 만기로 줄여버리면 힌트이 높아질 수밖에 없겠죠. 
그죠 그러면서 전반적으로 부하가 줄어들고 성능이 빨라지면 되는 거야 하 일량 자체를 줄여야 된다

참석자 1 
논리적인 이상 논리적인 이상 같이 해서 피스를 높여야 된다

참석자 1 
지금까지 아이오 몇 가지 좀 살펴봤고 이번에는 버터 케지 몇 가지 살펴볼 겁니다. 
지금까지는 아이오를 디스크에서 데이터를 어떻게 읽는지를 설명드렸고 그것이 리기 때문에 버퍼 캐시를 쓴다고 했는데 버퍼 캐시에는 그럼 데이터를 어떻게 읽어드리냐 우리가 겉볶이 씨를 보통 표현할 때 다독한 모양으로 보통 표현을 해요. 
그냥 사실은 이 어뢰입니다. 어
참석자 1 
기다란 어레이인데 얘를 우리 그 케인에다가 담으려고 하면 중간이 부족하니까 이렇게 접고 접어서 바둑판으로 그리는 거예요. 
일렬로 되는 어레이라고 생각하 바호판이 됐든 인재로 되나 어리가 됐든 이런 자료 보에서 내가 특정 블록을 읽어 봤는데 그 블록을 어떻게 찾아서 읽을 것인가 그런 고민 해보신 적 없지 않으세요. 
메모리에서 데이터를 어떻게 찾아야 될지

참석자 1 
저는 이제 그게 들으면서 많은 연구를 했고 연구를 해왔다 보니까 되게 놀라운 인사이트가 있더라고요 얘기하는 그걸 발견하는 순간 굉장히 많은 디센트가 생겼어요. 
디비에 대한 여러분들 이제 저는 컴봉을 전공하지 않았거든요. 
전 아 나중에 이제 뒤늦게 제가 이 프로그램 공부하면서 나중에 자료 구조와 알고리즘 이런 책을 사서

참석자 1 
공부를 했거든요. 여러분들은 대부분 다 풍문과 출신이시죠 아마 저보다 더 잘 아실 건데 우리가 자료 구조 알고리즘 공부하다 보면 뭘 배웠냐면 해시 구조라는 거예요. 
해시 구조 해시 알고리즘 거요. 시 알고 자료 구조 알고리즘의 책을 보니까 해시를 주로 주조로로 설명하더라고요 우리가 요즘에는 주소를 보통 스마트폰으로 pc로 관리하지만 예전에는 이 제가 어드레스도 집집마다 이런 주소록이 하나씩

참석자 1 
새로 이제 주소를 제출하면 정보를 입수하면 주소록에다 기록을 하죠. 
기억은 기억시에다가 이런 기시에다 성시별로 시비로 나눠서

참석자 1 
그래서 여기서 말하는 솜씨가 해시 체인이에요. 
패시 체인 하나의 리스트가 되는 거죠. 
기억실을 저장하는 리스트 민씨를 자랑하는 윤씨를 잘하는 그다음에 보면 앞에 이제 성씨가 있는데 이 성씨가 택시 평션입니다. 
데이터를 분배하는 기준 함수가 되는 거예요. 
그래서 입력한 정보를 함수에다 입력을 해요.

참석자 1 
즉 성실을 확인하는 거죠. 성실을 확인하는 그것이 기억시냐 안돼 있으냐에 따라서 데이터를 분비하는 것이죠. 
이것이 이제 해시 구조입니다. 핵심 설명할 때 또 많이 쓰는 게 서브에 셀 함수는 이제 문자를 자르는 함지 않습니까 바를 때 마이너스를 쓰게 되면 뒤쪽에서 잘라요 입력한 값은 뒤쪽 값을 통해서 데이터 경제하는 게 좋아요. 
그 3일 그러면 31이니까 이한 값은
참석자 1 
1체인데다가 이거 두 번째 체인다가 이렇게 해서 58 그러면 끝에 가면 팔이니까 508은 8 지금 현재 이 508이 없는데 만약에 오스8이라 줄었다고 하면 이 값은 인체에 있는 있게 되는 것이죠. 
요 커버 스탈 함수가 곧 시함수가 되는 거예요. 
데이터를 분배하는 시 함수가 되는 거고 각각이 이 체인이 되는

참석자 1 
또 많이 예를 드는 게 모듈로 라우스입니다. 
모듈 스 로 오라는 값이 떴는데 입력한 값을 5로 나눠요 5로 나눠서 나머지가 0이냐 0이냐 있냐 3이냐에 따라서 데이터를 부른다는 거죠. 
그러면 96 그러면 96으로 5로 나누면 나머지가 1이죠. 
96은 이 일 체인에 있게 되는 거죠. 
지금 96이 없는데 구6이 여기에 있다고 그러면 체인을 스캔을 하면 되는 거예요.

참석자 1 
내가 58을 찾겠다. 그러면 이 3번 체인이 되겠죠. 
3번 네 번째 체인 그러면 508 찾아오면 되는 거예요. 
근데 현재 508이 없어요. 그죠 여기 없네 혹시 다른 게 있을까 하고 다른 데 드셔볼 이유가 있을까요. 
없죠. 그렇죠 여기 있으면 있고 포스는 없는 거예요.

참석자 1 
결론적으로 오라클이 오락뿐만 아니라 다른 분들도 마찬가지인데 이 캐시 버퍼 버퍼 캐시를 캐시 구조로 관리를 합니다. 
그래서 실질적인 버퍼 블록들은 내가 오른쪽에 보면 과속판처럼 관리를 합니다. 
어레이라고 했죠. 어레이로 관리를 하는 것이고 얘를 가리키는 포인터를 갖고 있는 헤더 법 패더를 캐시 구조로 관리하는

참석자 1 
그 앞쪽에 보면 함수가 있습니다. 함수 제가 수 있다. 
함수 이 함수에다 입력하는 인자 파라미터가 뭐냐 데이터 db입니다. 
db 여기서 말하는 dba는 데이터 베이스 어드민 트레이트가 아니고 뭘까요. 
데이터 블록 어드레스 데이터 블록 모든 블록들은 자기만의 고유한 주석 값을 갖고 있어요. 
어떤 주석 값이 있죠. 몇 번 파일에 몇 번 블록이다라는 주석 값을 갖고 있는 것이죠.

참석자 1 
그리고 그 값이 어디 저장이 돼 있을까요. 
패시멜로도 저장이 돼 있는 시 멜로요 패시 멜로 보면 아까 보신 것처럼 몇 번 파일에 몇 번 불라 그로부터 연속된 몇 개 그렇게 하면 첫 번째 블록을 찾아서 연속된 몇 개 블록의 구조를 계산해 낼 수가 있잖아요. 
그레스로 블록 풀스킨 할 때는 패시 맵을 통해서 블록 어드레스를 얻어서 그 블록들을 찾아가는 거예요. 
메모리에서
참석자 1 
인덱스 이용할 때 어때요 인덱스 이용할 때는 로와이드까지 포함이 돼 있거든요. 
인덱스 로이드에 보면 앞에 파일 번호 블록 번호 블라 바렛의 몇 번째 레코드 그게 라인이거든요. 
로라인드를 잘라보면 잘라보면 몇 번 내가 지금 입은 그 레코드가 인덱스를 입은 레코드가 테이블 블록에 몇 번째 파일에 몇 번 블록이 있는지를 알 수가 있는 거지

참석자 1 
그래서 그 블록 어드레스를 얻어서 블록 어드레스를 캐싱을 해요. 
캐시 함자를 태워서 체인을 찾죠. 체인을 찾고 거기서 데이터를 찾는 거예요. 
모든 블락을 읽을 때 풀스에서 하든 인디스이 선서 읽던 소에서 읽는 모든 블록을 방금 보신 것처럼 패싱을 통해서 블락을 찾아간다는 얘기죠 메모에서 메모를 찾아보고 없으면 디스크를 받는 거

참석자 1 
복잡합니다. 디스타블러 하나 있는 과정 자체가 굉장히 복잡해요. 
이제 여기서 끝이 아니고 문제는 이 박터켓이라고 하는 것은 공인 메모리에 있어요. 
메모리 공인 머리 그렇기 때문에 항상 직렬화 메카니즘이 필요합니다. 
직렬화 메카니즘 직렬화 메카니즘이라는 건 무엇이냐면 줄색으로 한다는 얘기예요.

참석자 1 
내가 특정 리소스를 딱 입으려고 하는 순간에 동시에 다른 프로세스가 같은 같은 리소스를 딱 입으려고 하면 항상 문제가 생겨요. 
예를 들면 여기 p1 프로세스가 첫 번째 1번 프로세스가 이 체인 300을 시작했어요. 
스키는 에서 얘가 가리키는 포인트로 얘를 찾아가고 얘가 가리키는 포인트로 얘를 찾아가고 여기 찾아서 스캔을 할 텐데

참석자 1 
첫 번째 버퍼에도 읽고 두 번째도 딱 넘어가려고 해요. 
얘가 가리키는 포인트로 딱 넘어가려고 딱 하는데 두 번째 프로세스가 얘를 딱 제거해버려요. 
동시에 그럼 어때요 얘는 얘를 가르쳐서 가려고 하는데 얘가 없어져 버리는 거예요. 
그럼 커럽션이 발생하는 거예요. 커럽션이 에러가 나는 거죠. 
그런 일이 생기면 안 되겠죠. 그렇죠 그걸 막아줘야 되는 것이죠.

참석자 1 
그래서 얘는 공유 메모리이기 때문에 공유 메모리에서 데이터를 기 때문에 항상 그런 직렬한 메카니즘이 필요하다라는 뜻이에요. 
그러면 우리가 요즘에 가장 많이 얘기하는 카드 중에 하나가 뭐예요. 
공유 경제라는 얘기하죠. 공유경제 말 그대로 공유한다라는 얘기인데 주로 뭘 공유합니까 우리가 자동차를 공유하고 집을 공유하죠. 
근데 여러분들 실제로 한번 보세요. 자동차를 공유합니까

참석자 1 
옆집 아줌마랑 나랑 차를 같이 타고 갑니까 그렇지 않잖아요. 
그렇죠 말은 공유지만 사실은 독점인 거예요. 
순서대로 내가 먼저 차를 이용을 하고 순서에 따라 내가 차를 이용하고 내 차를 이용을 다 끝내면 그다음에 예약자인 여주사 아줌마가 그 차를 이용하는 거예요. 
크게 보면 공유는 같지만 짧은 순간으로 딱 치고 들어가 보면 공유가 아니고 독점한다는 얘기죠 배타적으로 집도 마찬가지고요

참석자 1 
그래서 우리가 공유 메모리인데 공유 메모리라고 하더라도 진짜 데이터를 실제로 공유하면 안 돼요 여러 프로세스들이 데이터를 같이 공유하면서 막 서로 상호 작용하고 있지만 특정 순간으로 탁 치고 들어가서 볼 때는 한 프로세스만이 데이터를 읽어야 된다는 이 그것을 가능하게 해주는 직렬한 메카니즘이 필요하다는 얘기고 지금 설명드리는 데 있어서는 그 역할을 해주는 게

참석자 1 
캐시 버퍼치의 매치라고 하는 락 메타인식입니다. 
락 매치 매치가 결국 락이에요. 우리가 일반적으로 사용하는 락은 로락이죠. 
로락 로락인데 여기서 말하는 락은 매치는 인터널 락입니다. 
읽어보면 sga 상의 공유 리소스에 대한 엑세스를 직렬화하기 위한 일종의 라면 편집이다.

참석자 1 
일반적인 락은 사용자가 업데이트를 치고 컴퓨터 로백 할 때까지 그냥 계속 유지가 되지만 이 매치라고 하는 거는 인터넷 라이기 때문에 아주 순간적으로 짧게 딱 잡았다. 
놓는 거예요. 순간적으로 살았다는
참석자 1 
여기 보시면 이 레치를 기다리는 이 레치 하나가 여러 개의 체인을 관리하거든요. 
1 대 1이 아니에요. 체인 하나가 배치 하나가 보통 32개 체인을 관리해요. 
여기 보시면 이제 그림 2개만 가량 좀 보여져 있는데 보통 이것도 이제 파라미터로 관리가 가능하거든요. 
파라미터 가능한데 보통 리프터 두면 하나의 레치가 보통 32개의 체이를 관리

참석자 1 
그리고 그 32개 체이에는 무수히 많은 버퍼 블록들이 패싱이 돼 있어요. 
그런데 여기 보시면 3개의 프로세스가 지금 이 레치를 기다리고 있는 거예요. 
그러면 첫 번째 프로세서가 들어와서 데이터를 스캔을 하면서 데이터를 찾는 동안에 나머지 디스 프로세스는 기다려야 된다는 얘기예요. 
첫 번째 프로세스가 일을 다 마치고 락을 배치를 풀고 나갈 때까지 남은 그 프로세스를 대기해야 된다는 거

참석자 1 
그런 목적으로 사용한 것이 캐시 버퍼 체인 리치다 그래서 매번 심의 과정을 핵심 과정을 통해 데이터 일뿐만 아니라 그 과정에서 내부적으로 해시체인 탐색 과정에 경합까지 발생할 수 있다는 얘기죠 경합까지 발생하니까

참석자 1 
여기 보시면 이제 레시 하나를 놓고 두 개의 프로세스를 경합하는 하나 보여드리면 됩니다. 
왼쪽에 있는 1번 프로세스가 이미 레치를 쥐고 있는 거예요. 
그러면 매치를 주고 cq를 통해서 뭔가 일을 막 하겠죠. 
일을 하고 오른쪽의 프로세스는 딱 보니까 늦었어요. 
매치를 a가 먼저 지고 있으니까 얘는 기다려야만 합니다. 
그럼 기다리는 동안 계속 cpu를 쭉 계속 쥐고 있으면 cpu 장을 계속 사용하겠죠. 
그렇죠 얘는 계속
참석자 1 
풀렸나 풀렸나를 계속 확인하거든요. 그 확인한 동안 계속 티스파를 쓰는 거예요. 
풀렸나 풀렸나 풀릴 때까지 기다려야 되니까 계속 그러고 있으면은 cp를 굉장히 낭비하겠죠. 
그렇죠 그래서 디폴트로 2천 번 확인하도록 세팅이 돼 있습니다. 
2천 번을 확인하고 그래서 안 풀리면 일단 포기 일단 포기하고 잠을 잡니다. 
즉 1표를 반납을 하고
참석자 1 
잠을 자는 거죠. 잠을 자다가 다시 깨어나요. 
그러다가 또 필라 필라다는 걸 확인하는 거예요. 
일반적으로는 레치는 아주 순간적으로 짧게 잡히는 건데 아주 동시에 동시에 액세스가 많이 발생하면 쉽게 풀리지 않을 수 있어요. 
한 자원을 동시에 막 천 개가 동시에 읽으려고 하면 그이 생길 수 있다는 거죠. 
플라나 플라나 플라나 확인하다 안 풀리면 반락하고 플라나 플라 발 안 풀리면 반락하고

참석자 1 
그때 나타난 데이베트가 뭐다 매치 프리 데이베트예요. 
매치 프리 매치가 프리해지기를 기다리는 데이베트다라는 잠을 자는 거예요.

참석자 1 
그리고 내면의 경합이 심하게 발생할 때 여러분들이 실제 모니터링을 해보면 해시 버퍼 체 매치에 대한 데이벤트가 확 올라가 있어요. 
캐시 버퍼 체의 매치 주로 언제 나오냐면 개발자분들이 커리를 잘 못 자서 카트 곡을 만나 조형물을 빠뜨린 거죠. 
100만 개당 10만 개짜리 테이블 조형하는 조형물을 빠뜨렸어 그럼 100만 곱하기 10만 원 몇입니까 10만인가요 하여튼 1천만 개 불러야 읽어야 되거든요.

참석자 1 
그럼 그 프로세스가 1천만 개 분을 계속 요청을 해요. 
계속 그러면 여기 있는 수많은 체인에다가 막 계속 요청했죠. 
이쪽 이쪽 사방 돌아다녀서 막 천만 개를 계속 요청을 해요. 
그럼 메모리에서 이 프로세스 하나가 그냥 많은 매체를 조명하게 된다는 얘기죠 그러면 그동안에 다른 애들은 계속 기다려야 되는 상황이 계속 재현이 되는 또 얘도

참석자 1 
여기저기 막 쓰시고 들어가는데 걔들이 항상 비수는 방법이 없잖아요. 
그죠 여러 프로세스에서 계속 정리가 되니까 계속 매치를 기다리는 그런 상황이 진행이 되는 거 한번 해보세요. 
여기 시스템 가서 캐시 버치 매치를 한번 보고 싶다. 
그럼 카트 한 번 만드세요. 100만 권짜리 테이블 1만 권 테이블 2개 조회해가지고 딱 돌려보세요. 
그럼 저기서 막 사일레이 올립니다. da pc에서 db들이 보통 이제

참석자 1 
모니터링을 뭐라고 했지 않습니까 들어보면 이런 이벤트가 막 발생하면 사이드 보일 수 있도록 세팅해놓으면 준비해 주는 게 좀 있어요.

참석자 1 
또 뭘 얘기하고 싶으냐면 메모리를 통한 아이오일지라도 동시 트랜젝션에 의한 경험이 심한 상황에서는 기대에 못 미치는 성능을 나타내게 될 수 있다. 
제가 지금까지 계속 바이오는 성능이다. 
디스카이오다라고 말씀드렸는데 디스카이오 성능을 말씀드렸는데 메모리 아이오라고 하더라도 절대량이 많아지면 많아지면 메모리 상에서 경합을 유발해서 심각상 부화를 유발할 수 있다라는 얘기죠

참석자 1 
여기서 끝이 아니에요. 보세요. 1번 프로세스가 이 프로세스가 이 레시를 주고 들어갔어요. 
들어갔어요. 들어가서 포인트로 딱 찾아가서 이 블록을 찾고 읽어 들어가요 이 팔 트로가 있죠. 
이거 들어가서 데이터를 읽을 수도 있지만 또 업데이트 할 수도 있고 그러면 그 어깨트를 다 끝내는 동안에 얘는 어떻게 돼요. 
계속 기다려야 되죠 그죠
참석자 1 
서로 다른 블락을 입으려고 하는데 다른 분락을 입으려고 하는데 얘는 계속 기다려야 돼요 그럼 경성이 떨어지겠죠. 
그래서 내가 찾고자 하는 블록을 찾았으면 내치를 계속 치고 있으면 안 돼요 빨리 놔둬야 돼요 그럼 놔둬야 됩니다. 
문제는 내가 블록을 찾았어요. 레츠를 풀었어요. 
그랬더니 두 번째 풀어서 진입을 했는데 진입을 해서 다른 블락을 읽으면 아무 상관이 없는데 얘도

참석자 1 
하필이면 같은 분락을 입으려고 기다리고 있었던 거예요. 
그래서 첫 번째가 딱 들어와서 찾았다고 얘를 풀었더니 풀고 이쪽으로 갔는데 얘가 딱 들어와서 또 같은 분을 찾아서 또 같은 블락을 쓰고 진행합니다. 
그러면 같은 블록을 2개 프로세스가 또 있는 하나의 또 생기죠 그죠 이런이 생기면 안 된다는 얘기죠 그런 현상을 막아주기 위해서 어떻게 하느냐 내가 필요한 블락을 찾았어요. 
찾았으면
참석자 1 
레치를 풀어줘야 되는데 바로 푸는 게 아니고 이 버퍼 헤더 자체에다가 락을 걸어요. 
락을 걸고 내치를 풀어줍니다. 그러면 그 순간에 다른 프로세스들은 다른 블록들은 자유롭게 입을 수 있는데 버퍼하게 걸른 블록은 한 번 더 대기를 하게 되는 거예요. 
버퍼라게 클립 때까지 이해되십니까 잠금장치를 이중으로 해둔 거예요.

참석자 1 
여기 여기도 지금 아까 장장 두 개가 있었지 아까에 철문이 하나 있고 중간에 유리문이 있어요. 
유리문 유리문 비보다 뭐라고 그랬죠 1112 그럼 식사를 하실 때 너도 식사를 갈 거니까 혹시라도 오셨을 때 장기 있으면 이대 열고 들어오시면 돼요 잠금 장치를 이중으로 하고 있는 것처럼 직면화 정치를 이중으로 둔 거예요. 
그래야 고인 데이터를 보호할 수가 있으니까

참석자 1 
이해되시죠 질문 질문밖에 없나요. 그냥 해도 돼요. 
프로 여러 블로그를 읽으려는 한 프로젝트가 동시에 많은 시를 공유할 수 동시에는 못하죠. 
하나씩 하나씩 하나씩 블록은 환불 할 수 있는 거니까 항상 환불 할 수 있는 거니까 그 블록을 속한 체인

참석자 1 
체인에만 매치를 했어
참석자 1 
결론적으로 저 현상을 해결할 수 있는 가 결론적으로 저걸 어떻게 해결해야 될까요. 
잘못 배운 비지에들은 어떻게 하냐면 매치 자체를 없애려고 노력해요. 
그래서 아까 이런 매치 개수 아까 제가 이제 하나당 보통 32개 관련돼 있지 않습니까 얘를 조절할 수가 있어요. 
파라 밑으로
참석자 1 
그래서 메모리를 증설한다든지 막 이런 식으로 접근하시는데 잘못 배운 겁니다. 
그렇게 해결하고 하시면 안 돼요 어떻게 해결해야 됩니까 허리를 트해야 돼요 허리를 트윙해서 100만 개 아이던 것을 10만 개로 줄여주면 정확도 10분의 1이 줄어들 거야 만 개로 줄어들면 100분의 1이 줄어들 것이고 아까 얘기한 것처럼 보통 이 현성이 많이 나오는 게

참석자 1 
하천 법이거든요. 그 잘못 잔 거예요. 
조용품 만들어주면 되죠 개인도 정판을 걸어주면 그 소가 돼요. 
그 sk 팀을 정확히 모르는 비계분들이 버프하게 뭔지 캐시 포션 이렇게 공부해 보니까 이런 메모리 경험이 일어나고 있구나 그걸 해결하기 위해서 파라미터를 해결하려고 하시는데 이거는 답이 아닙니다. 
여태까지 아까 8월부터 제 책에 보면 파라미터 다시 쌓여 있거든요. 
뭐라고 설문 조사해 보면
참석자 1 
제가 말씀드린 터 외에도 몇 가지 더 있는데 그것도 다 설명하고 있는데 여태까지 그가 선택 선택한 적 한 번도 없어요. 
제가 20년을 배팅하면서 인량을 줄여주면 되는 거예요. 
논리적인 인상을 자연스럽게 매물이 줄어들게 되는

참석자 1 
머리 까졌어요. 안 알렸다 는데 아니에요. 
예예 아까 말씀하신 허리 틀린 거예요. 
왜 서 bw에서는 신이 번호를 쓸 수 있고 해낼 수가 있어요. 
그럴 경우에 그런 이벤트를 dw에서는 이런 게 잘 안 발생하죠. 
기본적으로 이런 일이 발생하려고 그러면 차가 많아야 발생하는 거죠. 
메모리 경합이 생기려고 하면 dw에서는 저런 게 잘 생기지 않아

참석자 1 
이걸 주로 이제 프시템 위주로 하고 애들은 근데 디더뷰가 매팅이 안 돼 이 프 기본적으로는 기반이

참석자 1 
100만 권짜리 천만 권짜리 주인을 하는데 nn 조인을 해요. 
무슨 마이어가 그 시인으로 해주면 아이가 확 졸거든요. 
투명 가능하죠. 얼마 그래 튜닝하는 폰트가 다를 뿐이지 결국 bw도 수은 똑같이 아이오 드리는 거야 혹시 매치나 버퍼하게 타임아웃 같은 그런 생애주기 개념이 혹시 있을까요.

참석자 1 
한순간에 몰리면은 쫙 줄을 서게 될 텐데 뭐 이렇게 그 일정 이상 걸리는 애들은 그냥 아예 종료시켜버린다든가 그런 건 없어요. 
일반적인 로락은 그런 게 있거든요. 타입을 걸어서 3초 동안 기다리다가 포기해라 이런 게 있을 수 있는데 얘들은 그런 건 없어 기다려야 돼요 제가 있다면 법가락은

참석자 1 
휴방식이기 때문에 순서대로 받아요. 휴방식이기 때문에 진입한 순서대로 살짝을 받고 버프락은 매치는 큐멘타님이 아니에요. 
그렇기 때문에 순서가 없어요. 먼저 들어온 형이 나중에 잠을 갈 수도 있고 나중에 들어오는 형이 먼저 갈 수도 있고 계속 아까 얘기한 것처럼 풀려나 풀려나 풀려나를 확인한다고 그랬지 않습니까 풀려나 풀렸나 확인하다가 먼저 건덩이 지고 가는 거죠. 
네 감사합니다.
참석자 1 
여러분들 하나만 더 말씀드리면 이해를 돕기 위해서 여러분들 듀얼 테이블 엄청 많이 쓰시죠 마이스크 쓰시는 분들 모실 텐데 오라클 쓰시는 분들 듀얼 테블 아시잖아요. 
그죠 엄청 맛있어요. 근데 듀얼 테이블도 테이블이거든요.

참석자 1 
듀오 t를 보시면 실행 계획 보시면 어때요 페니 레세스 풀 시스 시스 밑에 듀얼 테이블이 있는 거예요. 
그 테이블을 있는 프로젝트나 시는 게 나오고 얘는 하나의 레코드의 하나의 칼럼을 가진 그런 테이블입니다. 
보시다시피 덤이라는 칼럼을 가져요. 레코드 하나밖에 없어요. 
그 얘를 읽으려고 하면 실제로 아이가 발생해요. 
몇 개 읽었어요.
참석자 1 
3개 읽었어요. 매번 읽을 때마다 3개 블록을 읽는다는 얘기예요. 
실제 블록은 하나겠지만 걔를 읽기 위해서 아까 얘기한 것처럼 풀 스캔이니까 버퍼에 들고 읽어야 되잖아요. 
그런 것까지 더해져서 이제 3개 블록이 있는 거예요. 
그러면 여기 메모리 구조상에서 듀얼 테이블도 하나의 테이블이고 하나의 블록이니까 자기만의 주소가 있겠죠. 
주소 주소 보여드릴까요. 얘가 주소가 어딘지

참석자 1 
이네스 로 아이디 로 아이디 블락 정법 그로 아이디

참석자 1 
그 하나의 레코드가 있다고 그랬는데 그놈의 레코드 라이 이렇게 돼 있어요. 
그래서 레코드 아이를 파싱해서 블록번호를 찾아보니까 1사 1 라는 블록 번호를 가르쳐주고 있습니다. 
블록번호가 있다는 얘 값은 엑스고요 특정 블록이라는 얘기예요. 
그 블록 번호를 패싱을 해서 해싱을 해서 찾아가는 거예요.

참석자 1 
그러면 그 범위가 어디 있겠어요. 이 내용이 어딘가 하나 있을 거 아니에요. 
그죠 예를 들면 예를 들면 얘가 이 이 테이블 듀얼 테이블 블록이에요. 
예를 들면 그럼 어떤 선생이 생길까요. 
여러분들 그렇게 말만 나이 하네요. 셀렉트 시시테이프 프로 듀얼 셀렉트

참석자 1 
사실은 어플리케이션 단에서 함수가 있으면 그 함수를 쓰면 되는데도 귀찮으니까 내가 익숙한 거 쓰려고 dbms 함수를 써요. 
뭔가 값을 변환할 때 예를 들면 잡으면 잡아 함수 써도 되는데 디비에다 던져요. 
디비 함수를 써서 그때 듀얼 쓰죠 그렇죠 그다음에 뭐 디비 컨션이 살았다. 
죽거나 확인하려고 계속 또 나지 않습니까 무지 많은

참석자 1 
프로세스를 계속 비열 체브 읽어요. 요 블락 계속 읽으려고 하는 거죠. 
그러면 어떻게 돼요. 이 비열 체블이 있는 요 블락 요 블락 체인 여기는 항상 내 체에 걸려 있겠죠. 
그죠 그러면 이 체이는 기대로 혼자 쓰는 게 아니거든요. 
수많은 블록들이 이 체인을 경영해서 데이터를 데이터가 올라갔다. 
떨었다. 올라다 내려갔다. 이었다. 다를 반복하는 거거든요. 
그럼 이 체인에 묶여야 될 수많은 블록들이

참석자 1 
다 같이 영향을 받는 거예요. 캐시범체이 이렇게 계속 계속 나오겠죠. 
이해되십니까 물론 과거에 실제로 그게 문제가 됐었고 그래서 오락들이 팬지부터인가 조금 바뀌었어요. 
제가 아까 보여드린 것처럼 듀얼 템을 읽게 되면 아이오가 발생한다고 그랬지 않습니까 그래서 이 미러 범미 칼럼을 출력하도록 허리를 짜면

참석자 1 
실제로 아이오가 이렇게 그 세이가 발생해요. 
근데 더인 칼럼을 굳이 읽지 않아도 되는 경우에 예 여기 시스 데이트를 써요. 
그럼 어때요 아이오가 발싸지 않죠. 그렇죠 발싸지 않고 여기서 여기다가 소 캐릭터 케이크를 쓴다든지 어떤 수 쓰지 어쨌든 범인 칼럼을 읽어야 되는 일이 없다. 
실제 값을 출력해야 되는 일이 없다고 하면 아니면 여기다 1을 쓸 수도 있고

참석자 1 
아예 발생하지 않는다는 얘기입니다. 실행기가 어떻게 나오냐면 그럴 때

참석자 1 
이렇게 패스트 듀얼이 나는 패스트 듀얼 패스트 듀얼 실제로 데이터를 입지 않고 반만 이다는 그러면 지용템을 막 써도 되겠네요. 
이렇게 얘기할 수 있을 텐데 그렇지 않습니다. 
방금처럼 패스트 계열이 가능한 경우에는 아이도 더 이상 발생하지 않으니까 해시 범퍼 체인 매치는 발생하지 않습니다. 
않지만 결국 제도 커리거든요.
참석자 1 
셀렉트 나스타 프롬 둘도 쿼리예요. 그럼 뭐가 무슨 뭐가 있어요. 
라이브레티시 도가 있겠죠. 커리를 수행하는 다른 아 그러니까 함부로 쓰시면 안 돼요

참석자 1 
듀얼 팀은 어쨌거나 패스트 듀얼이 나와서 어느 정도 경험들이 해소될 수 있는데 또 대표적인 게 뭐가 있을까요. 
코드 테이블 코드 테이블 그럼 제일 많이 쓰는 코드 템 있을까요. 
여러분들 코드 보면 특정 코드 제일 많이 쓰는 코드 그 코드 테이블이 결국은 하나의 블록이 텐데 그 블록이 이거할 수 있다는 얘기죠

참석자 1 
그럼 그 코드 테이블을 모두 많이 쿼리해서 사용하는 그 과정에서 인체는 항상 라이브에 있는 상태일 수밖에 없고 그로 인해서 전반적인 성능에 나쁜 영향을 줄 수 있다는 얘기예요. 
결론적으로 다시 말씀드리지만 일량을 줄여야 된다 불필요한 락을 똑같은 분락을 뚫고 반복하는 그런 행위들을 채소화할 수 있도록 그렇게 수행을 해주셔야 된다라는 얘기가 되겠습니다.

참석자 1 
시간이 되면 이게 직접 시연을 해볼 수 있는데 실제 그 상황을 재현을 해서

참석자 1 
태블뿐만 아니라 인덱스 조건에서 모든 블락은 모든 데이터는 블러사이로 장한다 부상한다 그다음에 데이터 읽을 때 크게 두 가지 방식 시퀀스 레이센스와 레더 레센스가 있다라는 거 기억하시고 결국 디스크에서 데이터 읽는 과정에 쓰는 종목 종목 프로세스가 잠을 자는

참석자 1 
그것 때문에 성이 유지가 되기 때문에 스파이어를 줄여야 된다 이게 랜덤 마이어를 줄여야 된다 그래 그 기은 랜덤 마이어의 전쟁이다. 
그래서 버거기 시각 그래서 필요해지는 것이고요 건법에 대해서 데이터를 찾아보고 없으면 그리스를 간다는 것인데 데이터를 읽을 때 의 두 가지 방식 싱글 블라와요 방식으로 햄 플라스 버릴 수도 있고 멀티 블라요 방식으로 여러 블록을 동시에 끌릴 수도 있다라는 거

참석자 1 
논리적 과유와 물리적 과여의 차이점 논리적 과유는 절대 이양이라고 그랬죠 절대 이양 그래서 결국 성능은 디스 아이오에서 물리적인 디스크에서 좌우되지만 논리적 이용이 많아버리면 많아버리면 메모리에서 탐색하는 비용이 증가하게 되는 메모리는 기분도 빠르지만 논리적인 인양이 많아서 그러면 병합이 생길 가능성이 높아지고 그렇기 때문에 멤버에 약을 섞는 것도 빠르지 않을 수

참석자 1 
결과를 구출할 수 있다는 것이죠. 물자 나만 풀어보고 시를 하도록 하겠습니다. 
지금까지 설명한 데이터 베이스 바이오 원리를 바탕으로 아래 4가지 설명 중에 가장 부적절한 것을 한번 찾아보세요.

참석자 1 
몇 번입니까 네 4번 3번 1번부터 볼까요. 
한 쿼리 내에서 같은 블록을 반복 에섹스 하면 버터 케 시트 높아진다. 
맞습니까 높아지죠 그죠 이게 버터케시트의 맹점이에요. 
버퍼키시티라고 하는 것이 성능을 측정하는 지표 중에 가장 전통적인 중요한 지표 중에 하나인데 힌트를 줘야 된다고 말씀드렸지 않습니까 근데

참석자 1 
문제는 커리가 비효율적으로 작성이 돼서 같은 데이터를 또 있고 또 있고 또 있고 이 같은 거야 그러면 사실 비율인데도 불구하고 비율적인데도 불구하고 히트를 높게 만드는 요인으로 작용하겠죠. 
그죠 그러면 힌트율이 높다고 해서 시 때는 굉장히 효율적인 수준이다. 
이렇게 생각하시면 안 돼요 참고로만 하시

참석자 1 
오히려 비효율적이어서 쉽게 높아질 수 있다라는 측면을 갖고 있기 때문에 이렇게 고정을 위해서 보셔야 되겠고 멀티 블라 아이오는 한 번에 아이오플로 여러 데이터 블록을 읽어 메모리에 적재하는 방식이다. 
이것은 멀티 블록 아이오의 정의 그 자체죠 그렇죠 맞는 말이 되겠고요 테이블을 풀스팅할 때 테이블이 작은 디스텐트로 구성돼 있을수록 더 많은 아이오플이 발생한다 어때요 맞아요. 
틀려요. 리
참석자 1 
투리들 투리 투리 그렇죠 무슨 얘기인지 아시겠죠. 
멀티 블라바요 한다고 했는데 이 스텐트의 경계를 넘지 못한다 그랬어요. 
그죠 그럼 어떻게 됩니까 아까처럼 이스탠트가 한 이스트가 16개 블라이 이루어져 있는데 멀티 플라워 린드 카운트 12개예요. 
그러면 12개 있고 4개 있고 12개 있고 4개 있고 그죠 2센트 가격을 넘지 못하니까

참석자 1 
여기에도 4개 또는 8개가 부족하니까 다른 스테피를 찾아갈 것 같지만 그렇지 않다. 
그랬죠 세트 안에서만 벌이 올라가요 하니까 12개 있고 4개 거 12개 그러니까 어때요 코 많이 발생하겠죠. 
만약에 멀티 블록 아이가 12라고 한다면 스텐트가 단위가 예를 들면 12개라든지 24개라든지 36개라든지 그러면

참석자 1 
딱딱 짝지가 없이 정확히 이루어질 수가 아니고 매번 12개씩 가장 혈중인 상태가 되겠죠. 
아니면 정확히 이렇게 맞지 않더라도 크게 만들어두면 12개 12개 12개 2개 있게 저 끝에 가서 저트리 한 번 12개 2개 12개 있다가 저 끝에 가서 저트리 한 번 큰 이스텐트를 쓸수록 더 코레스가 줄어들겠죠. 
그죠 그래서 우리가 풀스템 위주로 주로 줘야하는 그런 시스템 bw가 되겠죠. 
bw에서는 이 스테트 크기를 크게 하는 것이 유리합니다.

참석자 1 
여러분 아까 제가 보여드린 거 기억하시는지 모르겠는데 이 스탠드가 처음에는 몇 개였었죠. 
덟 개씩이었나 8개씩 켰다가 중간에 18개씩 늘어왔어요. 
이 어느 정도 수준 넘어가면은 1메가씩 그다음에 신관이 점점 늘어가거든요. 
그래서 자동으로 관리하도록 인센트를 할당하게 되면 이분들이 그렇게 측정하면 그런 식으로 돼요. 
처음에 작게 시작해서 점점 커지고 점점 커지고

참석자 1 
그러더니 아예 그냥 10메가짜리 인세트를 하면 줄 수 있다는 얘기예요. 
어차피 큰 테이블이니까 직석블리도 되고 큰 테이블이니까 아예 그냥 유니폼 사이즈로 유니폼 사이즈로 1내가 할당해주면 성능 형성에 도움이 될 수 있다는 쪽에서는 반대로 인덱스를 통해 테이블을 엑세스 할 때 테이블이 큰 미스텐트로 구성돼 있으면 더 좋은 아이폰이 발생합니까 안 그렇죠 그죠 인덱스는 어차피 싱그 블러가 아니에요.

참석자 1 
크든 작든지 간에 콜레스트롤을 주는 데 전혀 효과를 주지 못합니다. 
영향을 주지 못하면 그렇기 때문에 그래서 월트에서는 이 세트에 굳이 크게 신경 안 쓰셔도 돼요. 
주로 원랜성 커리들은 인디스크 데스를 많이 하기 때문에 사이즈 크게 신경 안 쓰셔도 돼요. 
그냥 아까 말씀드린 것처럼 자동 할당되겠죠. 
그럼 처음에는 대시 80씩 68개 8개씩 시80씩

참석자 1 
이렇게 자동으로 이게 컨택이 되면 자동으로 커지니까 그냥 원터리하게 관리하도록 해주시면 좋습니다. 
질문 있으실까요. 네 혹시 그렇게 순차적으로 늘렸을 때 나중에 이제 앞에 있는 거는 익스텐트 사이즈가 작은 거죠. 
그 작죠. 예 그렇게 했을 때 그거를 다시 이렇게 늘린다고 하는 작업이 혹시 그래서 그 늘어나는 그 규칙을 보면 얘가 배수가 되도록 이렇게 해놨어요.

참석자 1 
그러니까 8개짜리가 이렇게 몇 개 보이면 108개가 되지 않습니까 8개짜리가 그렇게 배수가 되도록 해서 프리그먼테이션을 최소한 발생하지 않도록 그렇게 설계해놨습니다. 
우리 내부적으로 걱정하지 않죠. 또 다른 질문 없으시면 네 말씀해 보세요.

참석자 1 
업무상 같은 데이터 보내야 할 일이 많은데 같은 데이터를 여러 코스가 동시에 읽으면 아무래도 경험 가능성이 높아지겠죠. 
표면 멈출 수 없는 거죠. 어쩔 수 없는데 예를 들면 아까 제가 이제 대표적인 코드 팩을 얘기했지 않습니까

참석자 1 
코드 태그를 na전으로 엑스를 하게 되면 계속 같은 블락을 뚫고 뚫고 하게 된단 말이에요. 
근데 얘를 해시로 처리하게 되면 한 번 읽은 놈을 pga를 갖고 와서 pg에서 전이하거든요. 
그러면 공유 명문에서 같은 블록을 뚫고 뚫고 한 현상을 띄울 수가 있겠죠. 
그래서 그것이 문제가 된다고 하면 그런 방식의 트윈을 할 수가 있는 거죠. 
너무 그것을 이제 민감하게 생각할 필요는 없고 업무적으로

참석자 1 
많이 생각하셨는데 많이의 정도의 문제인 거죠. 
정말 캐시 워커 체인 매치 또는 버커락을 복권 경우 발생 시킬 정도 많이 발생하면 거기에 따른 조치를 해야 되는 것이고요 방금 말씀드린 것도 있고 또는 버벌하게 말 말이 때 쓰는 특징 박 중에 하나가 뭐냐면 블록을 쪼개는 거예요. 
한 블락의
참석자 1 
100개가 들어갈 때 경험이 많이 발생하겠어요. 
한 블록 10개가 들어갈 때 많이 발생하겠어요. 
100개 때 많이 발생할 거 아닙니다. 
그러면 한 블록에 10개밖에 못 들어가도록 아까 제가 이제 설명드리려다 파라미터가 있는데 pcd 프리라는 파라미터가 있어요. 
블락의 빈 공간을 많이 남겨놓게 하는 거죠. 
그러면 일반적으로 한 불라 1천 개가 들어가는데 pc 뿌를 90으로 할당하게 되면 100개밖에 못 들어가요 그럼 결합 가능성이 10분위로 줄어들겠죠.

참석자 1 
그런 식의 팀 방법도 있어요. 그래서 자주 쓴다고 그래서 무조건 이걸 오려해서 돌아가시고 우리 시스템은 이 테이블 되게 많이 자주 쓰는데 이거 문제 된다더라 이렇게 할 것이 아니고 먼저 진단을 하셔야 되겠죠. 
실제로 그 자주 사용함으로 인해서 경험이 생기는지 경험이 생긴다고 하면 경합이 발생하는 이유를 따져보시고 거기에 맞게끔

참석자 1 
조인 메소드를 바꾼다든지 블록 사이즈를 조정을 해서 블록 사이즈는 고정이니까 저희가 인구가 많이 보도록 측정을 해서 데이터가 흩어지도록 관찰시킬 수 것이고 방법들이 몇 가지 있습니다. 
또 다른 질문 없으시면 식사하시고 질문 있으시면 이따가 식사하고 와서 또 하시죠 다 12시 11시 30분입니다. 
12시
참석자 1 
함께 오고 있네요. 12시 40분에 뵙겠습니다. 
수고하셨습니다.
