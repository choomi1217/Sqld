참석자 1 
이렇게 바뀌었어요. 그래서 이제는 복구에도 문제가 없었는지 이제 걱정이 돼서 질문을 올린 것 같아요.

참석자 1 
이건 질문이 올라오면 뭐라고 답한 게 있어요. 
여러분 실행기에서 뭔가 이제 답을 찾으려고 하는 건데 신 게 모양을 보고 결국 이분이 이제 부하라는 표현을 썼지만 제가 볼 때는 속도를 얘기하는 것 같아요. 
속도가 이제 많이 느려졌고 이 상태에서 배포 해도 문제가 없겠는가 이런 파른 커리를 썼을 때 아니면 베스커리를 썼을 때 이는 것 같습니다.

참석자 1 
그럼 우리가 데이터베이스가 왜 느릴까가 결국 데이터베이스가 느린 이유는 아이오 병목입니다. 
제가 이제 저분께도 답변드린다고 하면 아이오 발생량을 좀 물어보고 싶어요. 
실행 계획만 본 것이 아니고 처리를 수행하기 전에 아이오, 수행하고 나서의 아이오, 다음에 맥스콜 160대 아이오 아이오가 얼마나 자세한 체크를 해보시라

참석자 1 
금이 늘었다면은 수행 하고는 아이오가 늘어났기 때문에 왜 그럴 거예요. 
제 짐작으로는 여기 보면 그 오더바이 로우넘을 넣고 늦었다는 거 보니까 그냥 처리했을 때는 아마 정렬 작업이 없었던 것 같아요. 
그러니까 전체 데이터 중 일부가 출력되면서 빨리 나왔는데 거기다 오더바이 딱 추가하니까

참석자 1 
전체를 다 정렬을 다 끝내야만이 이 결과를 수립할 수 있지 않습니까 그 과정에서 전체 데이터를 다 읽는 과정에서 많은 상당히 많은 아이오가 발생했겠죠. 
아니 이런 상황에서 나중에 되시겠습니다만 인덱스의 도움을 받으면 아주 빠르게 차번호 처리를 할 수가 있거든요. 
지금은 인덱스에 있는 상황도 아니니까
참석자 1 
그거 따져보면 다 아이오 때문이에요. 
아이오 데이터베이스와 스토리지 사이에 특히나 요즘은 네트워크를 경유한 아이오를 하지 않습니까 시스토리 수가 있으니까 아이오를 아이오하는 과정에서 네트워크도 거치게 되는 것이고 그래서 많은 걸 이 그럼 아이오란 무엇인가 아이오 여러분들이 만약에 후배가 선배님이 아이오가 뭐예요. 
이렇게 질문하면 뭐라고 답변하시겠어요.

참석자 1 
저는 컴공 출신이 아니다보니까 학술적으로 아이오를 얘기드리는 것보다는 데이터베이스 관점에서 제가 느끼는 바를 말씀드리면 저는 아이오는 슬립이다라고 표현을 해요. 
슬립 아이오는 잠을 자는 것이다. 열심히 일을 해야 되는 프로세스가 서버 프로세스가 일을 하지 않고 잠을 자는 것을 아이오라고 얘기를 할 것 같습니다. 
프로세스가 뭔가요 프로세스
참석자 1 
프로세스는 실행 중인 프로그램을 의미하는 겁니다. 
실행 중인 프로그램 이 프로세스는 실행 중인 프로그램인 프로세스는 생명 주기를 가져요. 
처음에 생성이 돼서 레디 상태로 갔다가 이것이 러닝을 갔다가 레디가 계속 반복합니다. 
대기 상태로 갔다가 시행됐다가 대기했다가 시행됐다가 계속 반복합니다. 
나중에 종료되기 전까지 계속 대기와 실행 상태를 계속 반복을 한다는 얘기죠 왜냐하면

참석자 1 
프로세스는 많은데 cpu는 하나밖에 없거든요. 
물론 요즘에 서버는 이제 대부 c2가 쉽게 읽는 경우도 있지만 여러 개 있지만 어쨌든 그것보다 훨씬 더 많은 프로세스들이 떠서 그 cpu 자원을 공유를 합니다. 
그렇기 때문에 내 프로세스 하나가 cpu를 계속 쥐고 뭔가 일을 할 수가 없는 거예요. 
cpu를 잡았다. 놨다. 잡았다. 놨다. 
계속 반복하면서 러닝과 레드 상태를 계속 반복을 합니다.

참석자 1 
제가 정리했다가 os로부터 인트로트가 들어오면 내비로 갔다가 다시 시크를 할 때마다 실행하고 이 상태를 계속 반복을 한다는 얘기죠

참석자 1 
그래서 아무런 이유 없이 레디와 런스트를 반복하는데

참석자 1 
설령 cpu가 프로세스가 여러 개 있지 않다고 하더라도 프로세스가 일을 하는 과정에 어쩔 수 없이 대기를 해야 되는 그런 상황이 발생해요. 
웨이팅이라고 돼 있죠 여러 가지 이유로 cpu 일을 하다가 이 프로트가 들어오지 않았지만 프로세스가 스스로 cpu를 반납을 하고 잠깐 대기 상태로 빠졌다가 다시 일을 하는 그런 대기 상태가 존재한다는 얘기입니다. 
여러 가지 이유가 있는데 그중에 가장 대표적인 것이 아이오예요. 
아이오
참석자 1 
내가 읽어야 될 데이터가 메모리를 찾아보니까 없는 거죠. 
그럼 내가 필요한 블록을 os에다가 또는 아이오 서브 시트에다가 아이오 코를 하고 프로세스는 잠을 자게 됩니다. 
잠을 잤다가 내가 원하는 블록이 디스크로부터 메모리로 올라오면 시그널을 받고 다시 깨어나서 내비 상태를 거쳐서 다시 러닝 형태로 가서 내가 원래 해보자 했던 내가 원래 입고자 했던 블록을 계속 읽게 된다라는 얘기죠

참석자 1 
그리고 아이유라는 것은 아이유가 발생하는 그 순간 프로세스는 잠을 자게 되는 거예요. 
잠을 제가 이제 아이오콜이라는 말을 썼는데 아이오콜은 뭐냐면 결국은 정해진 어떤 정해진 os 함수를 호출하는 거예요. 
os 함수를 호출하고 cpu를 반환하고 잠을 잔다는 것이죠. 
할 수 없이 하는 거죠.
참석자 1 
열심히 일을 해야 될 프로세스가 일 안 하고 잠을 자고 있으니 손이 떨릴 수가 없는 거겠죠. 
저희가 이제 잠시 후에 살펴볼 텐데 디스크 아이오에는 크게 2가지가 있습니다. 
싱글 블락 아이오랑 멀티 블락 아이오 이거 잘 아시는 것처럼 싱글 블락 아이오는 한 블록씩 이루어지는 거예요. 
한 블록 한 블락을 읽기 위해서 아이오 콜을 하는 것이죠. 
멀티 블락 아이오는
참석자 1 
한 번에 한 번에 콜에 여러 개 블록을 요청하는 겁니다 한 번에 8개 16개 또는 118개 블록을 동시에 요청하는 겁니다. 
그래서 싱글 블랙 아이오 기준으로 속도가 어느 정도 되냐면 평균 디스크 아이오가 싱글 블록 아이오 디스크 아이오 할 때 평균 10ml 세컨인데 이것을 우리가 시간으로 여기고 연산를 해보면 초당 초당 100분락입니다.

참석자 1 
한 10ml 세선을 한다는 얘기는 1초 하는 그 짧은 순간에 백플록을 읽어드린다는 게 있고요 좀 큰 캐시를 가진 센스트리지 같은 경우에는 세스토리지는 스토리 자체 메모리를 많이 갖고 있거든요. 
캐시를 그래서 그런 좀 큰 스토리에서는 현금 4~8ml 세 요것은 또 환산해보면 초당 125에서

참석자 1 
250g 정도입니다. 기억하세요. 여러분들 1초 하는 순간에 30%가 이 정도밖에 못 드려요. 
지금은 사실 이거보다 더 빨라요 이게 제가 책을 가 꽤 됐기 때문에 이제 과거 기준이고 제가 마지막으로 했던 sk텔레콤 차세대 프로젝트 이 유키라는 프로젝트 아시는지 모르겠습니다만 혹시 거기 참여하실 개발자분이 계실까요. 
그 프로젝트를 제가 참여했고
참석자 1 
그 프로젝트에서 나중에 sk텔레콤이니까 어마어마하게 큰 장비를 도입을 했겠죠. 
그죠 최고의 장비를 도입을 해서 첫 세대를 했고 거기서 제가 철수하면서 철수하는 시점에 이제 체크를 해보니까 한 1에서 2ml 세터 나오더라고요 1에서 2mm 지금 역선 하면은 초당 500에서 1천 정도에 이른다라는 얘기예요. 
500에서 1천 정도 여러분은 그 정도 감을 갖고 있어요. 
이렇게 실 때마다 다 다르니까
참석자 1 
전체적으로 몇 분 당 100g인지 200g인지 500g인지 모르겠는데 제가 들르면 됩니다. 
그 한 1분 500 볼라 빨라도 1천불라 읽는다 이렇게 생각하시면 될 것 같습니다. 
그렇기 때문에 여러분들이 쿼리를 짜고 나면 반드시 확인을 하셔야 돼요 내가 짠 코리가 블록을 얼마나 읽어드리는지 그를 들어서

참석자 1 
콜레트 성능이 빨리 나와요 반면 빨리 나오는데 아이오를 체크해 보니까 한 10만 블락을 입는 거예요. 
당장은 빨리 나오는데 10면 블록이 있는다 그러면 지금은 내가 테스트 과정에서 그 블록을 계속 읽었으니까 메모리에 올라와서 빨리 읽히는 걸 텐데 이것이 이제 배포가 돼서 고등 환경으로 넘어가면 과연 그 10만 개 블락을 읽으면서 과연 빨리 이을 수 있겠는가

참석자 1 
수많은 사용자들이 수많은 데이터를 읽으면서 커리를 수행하는데 마침 내가 수행한 커리가 그 커리에서 읽은 데이터들이 마침 메모리 캐시에 올라가 있을 가능성은 그게 높지 않다라는 얘기죠 10만 개 중에 만 개만 만약에 디스카이오를 하더라도 몇 초 걸리는 거예요. 
초당 1천 개 읽어요. 그죠 초당 1천 개 그럼 만 개 블러가 읽는다 스키에서 1초가 걸려 있는 거예요.

참석자 1 
10만 개 중에 천 개만 읽어도 10만 개를 다 계속해서 읽으면 100초가 걸리는 거고 당장 내 눈 앞에서 커리가 빨리 나온다 해서 이 커리를 최적화됐다고 생각하지 마시라 니다. 
항상 실행 계획을 확인하시고 아이 발생량을 체크를 하셔야 됩니다. 
게다가 경합이 심하면 대기 시간이 더 증가합니다. 
이 디스크 아이라고 하는 것은 물리적으로

참석자 1 
엑세스 암이 움직이면 세를 통해서 읽는 거지 않습니까 그렇기 때문에 동시에 동시다발적으로 많은 프로세스들이 너도나도 아이오를 발생시키면 성분은 그만 들어 진다는 얘기죠 메모리 알로는 전기적 신호에 불과하기 때문에 사과가 많이 접촉하더라도 같은 플락을 입으려고 대기하지만 않으면 그 성능이 떨어지지는 않거든요. 
그런데 디스크는 그렇지 않다. 들이 전반적으로 교육적으로 해서

참석자 1 
너도나도 아이를 아이오콜를 발생시키면 저는 이제 이 시각 거요. 
여러분들 그거 한번 pc에서 한번 해보세요. 
출전금을 돌려요. 그다음에 여러분들 인도에 보면 조각 모음 있지 않습니까 조각 모험 조각 모험도 돌리고 또 브이스리 스캔도 돌려요. 
한번 해보세요. 그럼 이렇게 비를 갖다 대면 어떻습니까 하디스크가 다 보란 소리가 나죠

참석자 1 
지금 보통 이제 sds를 쓰니까 예전처럼 소음 심지 않지만 디스크를 우리가 일반 디스크 had들이 쓸 경우 다시 이렇게 여기에 보면 여기 뒤를 대보면 색깔 계속 돌아갑니다. 
동시 여기 그러면 평소 청소기 3만 돌리면 한 5분 만에 끝나는 거지 풀백업이랑 조형물 같은 거 같이 돌리게 되면 5분 걸리는 게 10분도 걸리고 15분 걸리고 그럴 수밖에 없다는

참석자 1 
그렇게 해놓고 동시에 있는 거를
참석자 1 
그래서 아이로는 제가 이제 아까 프로세스가 잠을 잔다고 했는데 아이오는 프로세스가 잠을 자는 여러 원인 중에 하나입니다. 
아이유 때문에 잠을 자기도 자지만 그 외에 다양한 원인으로 인해서 잠을 자요. 
자신이 필요한 특정 리소스가 다른 프로세스에 의해서 이미 사용 중인데 대표적인 게 락이죠. 
락이 발생하는 지난주에도 이제 끝나면서 어떤 분이 락에 대해서 질문을 하고 가셨는데

참석자 1 
락에 대한 경험이 있고 또 메모리에서도 경험이 발생할 수도 있다라는 똑같은 블록을 두 개에서 프로세스가 같이 그려가는 또 그 순간에 또 락이 발생을 합니다. 
그 경우에는 프로세스가 잠을 자야 되고요 내가 어떤 일을 하려고 하는데 그 일이 진행되려고 하면 뭔가 선행 작업이 필요한 경우가 있어요. 
어떤 조건이 만족해야 곳이 해될 수 있는 경우죠

참석자 1 
그런 경우입니다. 디스크아이오와 어떻게 말씀드 디스크아이오도 마찬가지고요 그다음에 프로세스 간의 상호작용을 해요. 
디비라이터라는 백그라운드 프로세스가 있죠. 
로그라이터라는 백그라운드 프로세스도 있어요. 
이 두 프로세스가 계속 수시로 서로 주고받은 시그널을 보내면서 먼저 로그라이터가 로그를 기록을 끝내야 버퍼 디비라이터가 버퍼 팩시을 지기 기록을 하거든요. 
그런 메카니즘이 있어요.
참석자 1 
그래서 둘이 서로 계속 시그널을 주고받으면서 그러니까 디미라이터가 버퍼 캐시를 디스크에 플래시를 하려고 하면 먼저 로그를 먼저 기록해야 되거든 로그라이트라는 신호를 보면서 야 로그라이터야 내가 지금 버퍼를 지으려고 하니까 그거에 해당하는 로그 데이터들을 빨리 기록을 해놔 이렇게 요청하는 겁니다. 
그럼 그동안 프로세스 장을 자는 거예요. 
잠을 자다가 로그라이터가 로깅을 다 마치면

참석자 1 
라이터가 깨어나서 자기가 원래 하려고 했던 일들을 계속하게 되는 거죠. 
이런 식으로 서로 신사를 주고받으면서 잠을 자면서 일을 하게 됐어요. 
마지막으로 할 일이 없을 때 잠을 자요. 
할 일이 없을 때 아무것도 할 일이 없을 때 그래서 이렇게 여러 가지 이유로 프로세스가 잠을 자고 그 잠을 잘 때마다 이 오라클 엔지니어들이 로그를 남겨놨어요. 
로그를
참석자 1 
프로세스가 잠을 잘 때마다 기록을 남기도록 한 거죠. 
그래서 그것을 우리가 이제 베기 베스트라고 얘기를 해요. 
배기 베트
참석자 1 
보시는 것처럼 라이베티시에 부하가 존재할 때도 대기 변수가 발생하고 데이터 베이스 톤이 발생할 때도 대기 변수가 발생하고 비스가로 발생할 때도 버퍼피시의 경험이 발생할 때도 여러 가지 이런 다양한 비에서 발생한다 여러분들도 프로그램 할 때 로그 남기지 않습니까 왜 남겨요. 
나중에 프로그램이 정상적으로 작동하지 않을 때 그 원인을 쉽게 찾으려고 하는 거죠. 
마찬가지로 오라크 레지저들도
참석자 1 
뒤에서 정상적으로 작동하지 않고 속도가 느리다 왜 그럴까를 이제 찾아보려고 롱을 나기 시작하고 콘서츠들이 그래서 잠을 잘 때마다 일을 안 하고 잠을 잘 때마다 로그를 남기도록 했고 그것을 이제 이런 이벤트를 부여하는 거죠. 
저렇게 이제 로그를 남긴 게 본인들이 디버인을 위해서 로그를 남겼는데 그것이 성능 관리 방법으로 세팅이 된 거죠. 
성능 관리 방법으로
참석자 1 
그 성능이 왜 내인가를 분석하는 방법론으로 활용이 되기 시작했어요. 
참고로 리스 판스타인 어넬더시스트라는 방법론 디지털스 타임 어네레시스스 응답 시간 분석 디지털스 타임 어네레시스

참석자 1 
여러분 stlp 시험 보시는 분들은 앞으로 이걸 공부하셔야 돼요 왜냐하면 작년 2020년에 개정판이 나왔지 않습니까 개정판의 가장 큰 변화가 이 리스펀스 타임 어드레시스 즉 응답 시간 정선이 하나의 세포로 들어갔어요. 
나중에 이제 문제가 계속적으로 개정판에 맞춰서 출제되고 있지 않기 때문에 아직은 문제 7초 일정이 아직은 낮은 걸로 알고 있는데 없거나 근데 아마

참석자 1 
문제들이 포함이 되지 않을까 싶습니다. 
새로 문제를 출제하면서 그렇기 때문에 대기 벨트에 대해서 좀 공부를 하셔야 됩니다. 
스트레트를 공부하시는 분들은 스크립트가 아니더라도 성능을 효과적으로 분석하려고 하면 베이메이트에 대한 개념을 좀 아셔야 돼요 또 오늘은 제가 이렇게 베이베트 이름 종류만 이게 간단히 나열을 해드렸고 중간중간에

참석자 1 
필요할 때마다 하나씩 하나씩 좀 설명을 드리도록 할 건데요. 
그래서 이거는 그것까지에 해당하는 내용입니다. 
나중에 자료를 공부를 하셔야 되고 참고로만 여러분들이 이런 내용들이 나온다고 그래서 나 초보자인데 너무 어렵다고 생각하지 마시고 아는 만큼 보이는 거예요. 
아는 만큼 이미 이런 내용들을 알고 계신 분도 계시고 어려운 혹시 알고 계신 분 계시고 전혀 모르시는 분도 계시는데 이런 어려운 얘기 나왔다 그래서 스트레스 받지 마시고 그냥 일단 넘어가시면 돼요

참석자 1 
그런가 나중에 따로 공부하시면 될 거니까 나는 만큼 그렇다 생각하시고 부담없이 따라 오시면 되겠습니다. 
어차피 공부는 나중에 책으로 하는 거예요. 
이 강의 이 짧은 시간에 얼마나 많은 걸 여러분들께 정확히 시간이 제약 때문에 어 많이 알려드릴 수가 없습니다. 
그러니까 대략적인 흐름만 이해를 하시고 디테일한 것은 책을 쓰는 분반 수 밖에 없다면 그 이렇게 편안하게 따라주시면 되겠습니다.

참석자 1 
그것을 측정할 수 있는 대기 멘트를 찾아볼 수 있는 그런 교들도 제공하니까 한 번씩 기회를 해보세요. 
제가 현재 말씀드리기를 아이오는 무슨 어떤 단위로 아이오를 한다 블록 단위 아이오를 하는 것이죠. 
근데 우리 요즘에 스마트폰 또 아이패드 같은 거 많이 쓰지 않습니까 스마트폰을 통해서 또는 아이패드를 통해서

참석자 1 
서버에 있는 클라우드에 있는 파일을 열어서 편집을 했어요. 
순명을 했죠. 그걸 근데 그 파일을 편집을 하면서 저장 버튼을 수시로 누르면 10m가 단위로 아이오가 일어나는 거예요. 
그 다음에는 이거 포턴이 나올 수 있겠죠. 
데이터 베이스는 그거보다 훨씬 큰 데이터 파일을 다루지 않습니까 몇 기가짜리 파일을 다루는데 파일 단위로 아이오를 할 수는 없잖아요.

참석자 1 
파일 단위로 아이 할 것인가 세그먼트 단위로 할 것인가 아니면 인스탠트 단위로 할 것인가 그래서 오라클은 블록 단위로 아이어 한다는 말씀 드렸습니다. 
인스텐트는 공간을 확장한 다위 블록은 아이오 다 이렇게 정리를 하시면 되겠습니다. 
블록 그러니까 블록 블록이 뭐지 이게 좀 이렇게 추상적으로 생각이 돼서 제 어려워하시는 분도 계신데 다른 기리는 주로 페이지라는 말을 씁니다. 
페이지
참석자 1 
ms 시컬 서버도 페이지라고 해서 말을 하고 마이스킬도 페이지라고 표현하는 걸로 제가 알고 있는데 오라클은 블록이라고 얘기해요. 
블락은 무엇이냐 제일 쉬운 거는 여러분 엑셀 시트 생각하시면 돼요 엑셀 엑셀 많이 다루시죠 엑셀에 보면 많은 시트들이 있는데 그 엑셀 하나하나가 하나의 블록이다. 
이렇게 생각하시면 쉽습니다. 보시는 것처럼 emp 테이블에 지금 블록이 4개가 있는데 말하자면 엑셀 시트 4개가 있다고 생각하시면 됩니다. 
1번
참석자 1 
데이터가 6건이 있고 빈공간이 건 있고 2번 블라에도 마찬가지로 3번 블라에도 가 4번 블록에 지금 시트는 확정이 됐는데 데이터가 하나도 없는 상태예요. 
이런 블록을 블록에서 이제 빈 공간을 찾아서 데이터를 입력을 하게 되는 것이고 그럼 내가 이제 블록 단위로 와야 한다는 얘기는 뭐냐면 내가 이 사운 테이블에서 788번 사을 부여를 하겠다. 
그러면 이 블록을 읽는 거예요. 788 사이 여기 있지 않습니까 스코이라는 이름을 가진

참석자 1 
788원 사원이 있는데 이 사원 레코드만 쏙 골라 입을 수가 없고 그 레코드가 속한 블락을 통째로 입는다 말하자면 이건 시트를 통째로 입는 거예요. 
이건 시트 엑셀 시트 한 시트에 몇 개나 담을 수 있죠 레코드 무제한인가요 예전에는 6만 몇천 개 이렇게 제한 있었던 걸로 아는데 내 것도 개수가 제한이 없습니다 만 100만 개

참석자 1 
언제 버전까지부터인지 모르겠지만 제가 모르겠는데 예전에는 6만 몇천 개였어요. 
예전에는 대략 그 정도의
참석자 1 
사용 개수에 따라 다르겠지만 보통 한 1천 개 정도 담는다고 보통 일반적으로 그렇게 간다고 생각하시면 돼요 한 분 나가면 한 70~800개에서 1천 개 정도 데이터를 담을 수 있다. 
칼럼 개수만 개수에 따라 달라지겠죠. 
대략의 그런 개념을 가지고 블록을 적어주시면 되겠습니다. 
블락에 대해서 이해가 다 되셨습니까 네 그건 설마 안 들어도 되겠죠.

참석자 1 
이 테이블 사이즈가 커지면 블랙버드가 커진다고요 스가 엄청 많아지면 노스가 많으면 블록에 할당되는 크기보다 더 많아지는 경우가 뭐가 많습니다는 얘기죠 블라은 8k바이트 저건 이제 사이즈예요. 
네 8k바이트 안에 이
참석자 1 
그렇게 마시면 한 블러에서 초가 되는 용량이 초가 되면 다음 플라 수도 있잖아요. 
그러면 이제 엑셀 시트에서도 똑같이 그렇죠 엑셀 시트에다 막 데이터 넣었다가 한 시트가 꽉 차면 그 두 번째 시트에다 입력하면 되고 여기 보면 이 빈 공간들이 여기 있잖아요. 
네 이 빈 공간들을 찾아서 입력을 하는 거죠. 
이런 빈 공간들을 관리하는 목록
참석자 1 
구조가 있어요. 프리 리스트라고 하죠. 
프리 리스트 프리 리스트는 이렇게 완전히 비어 있거나 데이터 입력이 가능한 블락 목록을 관리하는 자료 구조입니다. 
프리 리스트 그래서 프리 리스트를 조회를 해서 입력이 가능한 블록을 찾아서 그 블록에 가서 입력을 하는 거예요. 
얘가 꽉 차면 꽉 차면 이 블록이 그 프리스트에서 제거됩니다. 
더 이상 입력 대상이 아닌 거죠. 그러면 이제 그때부터는 이쪽에 막 입력이 되겠죠.

참석자 1 
꽉 차면 또 이 블록도 프리스트에 제거가 돼요. 
그럼 그때부터는 이쪽 블록이 입력을 하고 이 블랙 록이 되고 모든 블록이 다 차면 그러면 이제 새로운 시트 새로운 블록들을 할당을 해서 그 새로운 블록들을 프리스트에 등록을 합니다. 
그때부터 그 프리스트를 통해서 또 새로운 블락에다 입력을 또 계속 하고 그런 식으로 확장해 나가는 것이죠. 
네 하나는 한 블락에는 한 테이블이 있다고 보는

참석자 1 
한 블록에는 한 테이블이 있다. 아니면 한 테이블은 블록 하나에 둘 한 테이블에 여러 블록이 있죠. 
한 테이블에 수없이 많은 블록이 있겠죠. 
여기만 보더라도 한 테이블에 4개 블록이 있는 거잖아요. 
계속 확장해 나가다 보면 한 테이블에 블락이 몇십만 개 몇백만 개 몇천만 개가 될 수 있는 거죠. 
네 그리고 한 블락 안에
참석자 1 
여러 개의 테이블에 담길 수 있느냐 오라클은 절대 그럴 수 없어요. 
근데 시콜 서버는 또 오게 가능해요. 
제가 이제 약간 긴가민가한데 한 블락 안에 여러 개의 테이블에 담길 수 있는지 한 익스텐트 안에 여러 개 올라가 있는지 좀 확인이 필요한데 제가 나 좀 이따가 확인해 드릴게요 한번만

참석자 1 
블록이 수도 있는데 이거 블록 안에 여러 개 테이블이 같이 공간을 사용할 수 있다는 얘기죠 그거의 한 블록 안에 들어간다고 화면에 보면 환불 확인 하면 들어가죠. 
그런데 못 들어가는 경우가 두 가지가 있습니다. 
혹시 아시는 분 하알 레코드는 한 블락 안에 들어가요 기본적으로 근데 못 들어가는 경우가 2가지가 있습니다. 
뭘까요.
참석자 1 
에로미는 좀 특별한 문제야 에로미는 청크 단위로 얼굴도 이 얘기들 하는 것도 어려우니까 좀 그건 좀 예외를 두셔야 될 것 같아요. 
여기는 워낙에 이제 기본적으로 대용량 데이터가 저장된 공간이기 때문에 좀 다른 구조를 갖고 있어 우리가 오라클이 한 블락이 8k이라고 했는데 하나의 레코드가

참석자 1 
8k가 넘을 수가 있어요. 8페이가 그럼 어때요 환불로 하게 못 담겠죠. 
그죠 그럼 그럴 때는 어쩔 수 없이 두 개 이상의 블록에 걸쳐서 하나의 레코드를 저장할 수밖에 없습니다. 
그래서 우리가 로우 체인이라고 얘기해요. 
로우 체인 로우 체인 로우가 체인이 발생했다. 
하나의 레포트가 한 블록에 저장되지 않고 여러 개의 블록에 걸쳐 저장되어 로우 체인 그건 어쩔 수가 없는 거죠. 
설계를 이렇게 한 거니까
참석자 1 
또 다른 경우는 뭐냐면 내가 여기다 이제 센 여기다 이제 마틴이라는 값을 입력을 했는데 이름으로

참석자 1 
그리고 이제 마틴을 입력했는데 이 마틴이라는 값을 굉장히 긴 의자로 업데이트를 했어요. 
근데 그 블록 안에 지금 보시는 것처럼 밑에 이렇게 빈 공간이 있으면 이 빈 공간을 활용해서 그 값을 업데이트 하면 되는데 빈 공간이 하나도 없이 꽉 찬 상태였어요. 
꽉 찬 상태에서 마틴을 100% 짜리로 길게 업데이트를 시키면 어떻게 될까요. 
내가 습관 분락에 저장할 수가 없잖아요. 
그죠 없잖아요.
참석자 1 
그럼 어떤 방법을 쓸 수 있을까요. 그 레포드를 지워서 공간이 넉넉한 다른 블록을 입력할 수도 있겠죠. 
그렇게 할 수도 있는데 오라크는 어떻게 하냐면 실제로 레코드 옮겨요. 
옮기지만 그 레코드의 로이드는 그대로 남아 있어요. 
그러니까 여기는 로와이드만 남아있고 실제 데이터는 이쪽으로 옮겨갑니다. 
그래서 우리가 로우 마이그레이션이라고 해요. 
로우 마이그레이션 생이죠.
참석자 1 
어떻게 되냐면 우리가 인덱스를 통해서 데이터를 찾을 때 일단은 이쪽으로 찾아가는 겁니다. 
찾아갔다가 가보니까 공터 하나도 없네 그럼 거기서 가르키는 루와이드 해가지고 한 번 더 다른 글러 찾아 들어가요 들어가요 그국은 산의 레코드 입기 위해서 3블록 구블록을 입게 되는 것이죠.

참석자 1 
그러니까 데이터 블록이 8kg인데 데이터 자체가 8km를 넘었을 수 있잖아요. 
근데 한 칼럼에 몇 바이트를 저장할 수 있죠 2천 바이트인가요 4천 바이트인가요 이 버전마다 또 다른데 아마 4천 바이트일 것 같아요. 
그러면 칼럼 하나는 사천 바이트지만 그 테이블에 4천 바이트 칼럼을 예를 들면 대여섯 개 뒀어요.

참석자 1 
5개면 2만이지 않습니까 2만 2만이면 많이 안 넣는구나 더 많이 해서 더 많이 해서 이 마늘 10개짜리 회를 만들면 20만이 되잖아요. 
그죠 그러면 어때요 한 레코드가 한 블록을 넘어서겠죠. 
그러면 기본적으로 그때는 판 물라가 들어갈 수가 없는 구조가 돼버리잖아요. 
그때는 항상 로 체임이 발생해서 항상 두 개 사는 블라이 입을 수밖에 없게 되는 거죠.

참석자 1 
두 번째 경우는 기본적으로 한 블러 안에 들어갈 수 있는 정도의 사이즈였는데 사이즈였는데 업데이트를 통해서 시바이트가 만 바이트로 더 늘어난다 근데 그 블락 안에 보시는 것처럼 빈 공간이 있으면 그 빈 공간을 활용해서 업데이트 하면 되는데 빈 공간이 없이 꽉 찬 상태라고 한다면 방법이 있어야 될 거 아닙니까 그래서 오라는 어떤 방법을 쓰냐면 그 레코드를 여유가 있는 블록으로 옮겨놓고 옮겨놓고

참석자 1 
노아이디는 그대로 남겨도 된다는 얘기예요. 
그래서 인대을 통해서 그 래프를 찾아가서 데이터가 없네 거기에 남겨놓은 노아이디로 찾아가는 거예요. 
두 개 이상의 블록을 또 이게 두 개를 다 묶어서 그냥 론 체인이라고 얘기하기도 하는데 구분을 해서 애초에 블록을 한 백보다 블록을 초과하는 경우는 로우 체인 원래는 한 블록을 들어갔는데 업데이트에 의해서 핵 이주가 발생하는 것을 로우 마이드션이

참석자 1 
하는 거야
참석자 1 
이런 일이 자주 발생해도 좋을 건 없겠죠. 
그죠 네 그래서 로 체인은 가급적이면 그렇게 발생하지 않게끔 설계를 다 하셔야 되는데 설계라고 하는 것은 내가 하겠다고 하는 게 아니고 업무가 그러면 어쩔 수 없이 그렇게 할 수밖에 없는 거니까 아까 얘기하신 시라고 적절히 활용하는 방법도 있을 것이고 설계적인 거니까 넘어가고 로 마이그레이션은 가급적 발생하지 않도록 우리가 해줘야 되겠죠. 
어떤 방법이 있을까요.
참석자 1 
그거 많이 다른 얘기를 좀 가게 되는데

참석자 1 
생각해 보니까 이것과 관련된 내용이 저 뒤쪽에 있어요. 
정확히 이 질문은 아닌데 제가 이제 뭘 얘기하냐고 하면 피시티 유스트 p시티 프리 얘를 말씀드리려고 했거든요. 
그 개념을 알아야 이제 이해가 되는데 그 좌측 쪽에 있습니다. 
그때 좀 말씀 그래서 블라타니 아이 개념을 설명을 드렸고

참석자 1 
다시 말씀드리지만 이스텐트의 개념 공간을 확장한다는 블록 이렇게 쓴다. 
그러면 우리가 이제 보통 많은 분들이 테이블에 대한 이제 블락은 이해를 하시는데 테이블뿐만 아니라 인덱스도 똑같아요. 
여러 인덱스라고 해서 특별한 어떤 저장 방법을 그런 맥카지를 쓰는 게 아니고 인덱스도 똑같이 블록 다니 데이터를 관리합니다. 
다만 그 안에 담겨 있는 내용이 다를 뿐이에요. 
테이블에는 사용자가 입력한 데이터가 들어가는 거고

참석자 1 
인덱스에는 그 데이터를 빨리 찾기 위한 데이터가 들어가 있는 거죠. 
똑같습니다. 똑같아요. 그래서 테이블도 블록 단위로 아요하고 인덱스도 블록 단위로 아유 합니다.

참석자 1 
그리고 지난주에 제가 봤던 내용이죠. 
이 두 spl 통 차이가 있겠는가 봤을 때 아이o 측면에서는 형 차이가 없다. 
왜냐하면 블록 다리 아이 라스타를 쓰는 것은 좋은 코딩 공은 아니다. 
네트워크 세트 많이 발생시키고 포트 공간도 많이 필요하고 하기 때문에 필요한 칼럼만 셀렉 때 정치하는 것이 좋은 편이다. 
하지만 io 측면에서는 차이가 없다라고

참석자 1 
블록 아이오와 기수가 곧 성능이다. 아이오라 성능이다. 
우리 튜너들이 성능을 측정하는 중요한 지표가 아이오고 옵티마이저가 실행 계획을 선택하는 기준도 아이오다라는 얘기죠 아이오의 표준 앱을 세분 다 같습니다. 
그죠 뭐라 그랬습니까 포스트가 뭐라 그랬어요. 
아이오 코레스 크게 두 가지 모델이 있다고 그랬죠 아이오 포스트 모델이 있고

참석자 1 
cp 포스팅 모델이 있는데 과거에 아이오 포스팅 모델에서는 아이오 플레수다 즉 이 콜리를 수행하는 과정에 826건의 아이오 콜이 발생한 것으로 팀 안전은 예상한다 그런 뜻이라고 했고 최근에 cp 포스트 모델은 이제 시스템 통계를 이용을 해서 시간 개념으로 판단을 해요. 
그래서 시스템마다 아이오투가 다 다르다고 했는데 싱글 블록 아이오시프 멀티 블록 아이오투 다 다르다고 했는데

참석자 1 
우리 시스템에서의 싱글 블라 가요 시간과 대비한 시간 단위로 표현하는 거예요. 
여기서 말하는 826이 만약 신규 프생 모델이었다고 하면 우리 시스템에서 826건 싱글 블락 아이오 하는 정도의 시간이 걸린다라고 고기 마전을 예상한다 이렇게 정리할 수 있겠습니다. 
이해되십니까 누가 혹시 물어보면 답변할 수 있겠어요. 
여러분 동정원이 야 여기 실행기에 보시면 826이라는 포스터가 나오는 게 뭐야

참석자 1 
어 저렇게 시행기를 보면 레이지 스캔이 코스트 26번이 제일 먼저 예 지금 이 시작 상황이 얘가 제일 먼저야 인덱스를 읽고 그리고 이제 순서대로 그렇죠 826번 하고 이게 첫번째 826번 이렇게 예 826번

참석자 1 
이 번호는 아니니까 그 그러니까 인덱스를 스캔하는 단계에서 26개를 읽었고 테이블에 가서 800개를 더해서 826개가 되는 거죠. 
이 실행에 확인하는 방법은 이제 앞으로 차츰 차 익숙해질 거니까 제가 지난 주에 말씀드린 것처럼 실행 계획을 해석하는 방법은 없다. 
몇 가지 n에지 같은 경우에 이제 기본적인 룰은 있지만 n에지을 벗어나는가

참석자 1 
다양하게 표현이 되기 때문에 그걸 너무 이렇게 기계적으로 공식적으로 외우려고 하지 마시고 자연스럽게 실행이 이해하시면 되고 이 실행 계획은 윈덱스를 스캔을 하고 인덱스에서 스캔해서 얻은 로아이디를 가지고 테이블 액세스하는 트레이드로 표현하는 거예요. 
인덱스를 스캔을 했고 그 결과로서 와인을 얻었겠죠. 
그 와인으로 테이블 레디스 할 것입니다. 
그 과정을 표현한 실행 계획이에요.
참석자 1 
그러니까 인덱스에서 26개의 아이오플이 발생했던 것이고 테이블까지 찾아가는 과정에 800개의 아이오가 아이오플이 더해질 것으로 예상을 한다는 거죠. 
그간에서는 이해되셨습니까 네 또 질문 아이오 코스팅 모델에서는 싱글 블록 아이오랑 멀티 블록 아이오가 둘 다 이렇게 한 번 했다고 했을 때 1로 표시가 혹시 될까요. 
그
참석자 1 
그게 아이오 코스팅 모델을 버리고 cp 코스팅 모델로 가는 여러 가지 이유 중에 하나예요. 
상식적으로 생각했을 때 한 블록을 읽기 위해서 한 번에 콜을 합니다. 
그 비용하고 118개 블록을 동시에 콜 해서 118개를 동시에 읽어드리는 비용 어떤 게 더 많겠어요. 
더 높겠어요. 실질적인 비용이 당연히 베시파리 있는 게 더 높겠죠. 
그죠 근데 과거에 아오코스트 모델은 실제로 있는 블록 수를 고려하지 않고

참석자 1 
콜이 몇 개 발생하느냐를 가지고 비용을 평가했던 거예요. 
콜이 몇 개 발생하느냐라는 지 벌써 거기서부터 한계점을 드러내는 어떤 잘못된 잘못됐다는 표현보다는 것은 불합리한 그런 계산 방식이 이미 존재하는 거지 않습니까 네 그런 것을 보완하기 위해서 이런 새로운 모델이 나오는 거예요. 
네 감사합니다. 더 깊이 들어가면 우리가 이제

참석자 1 
여러 가지 얘기를 해야 됩니다. 그래서 이 cp고생 모델이 작동하는 내부적인 원리들이 꽤 있거든요. 
그래서 아까 정확하게 지정하셨어요. 예전에는 시크 아이코스 모델 할 때는 그런 식으로 했기 때문에 그런

참석자 1 
그래서 그것을 보정하는 파라미터도 있습니다. 
제가 한번 보여드릴게요
참석자 1 
여기 보시면 이제 중요한 파라미터가 2개가 있는데 옵티마이저 인덱스 패싱이라는 게 있죠. 
얘가 면으로 돼 있습니까 영 이게 무슨 얘기냐면 인덱스를 통해서 엑세스 할 때 그 읽는 데이터가 메모리에 패싱돼 있을 가능성이 얼마큼 돼 있느냐라는 거예요.

참석자 1 
몇 입니까 0이죠. 0이라는 얘기는 0%라는 얘기예요. 
메모리에서 데이터를 찾을 가능성이 없다라고 가정을 하는 거예요. 
즉 내가 커리에서 10만 개 블락을 읽으면 그 10만 개를 모두 디스크에서 읽는다고 가정을 하고 오픈하면 작동 한다라는 얘기입니다. 
굉장히 비현실적이죠. 그렇죠 네 dw라고 하면 이게 맞을 수도 있어요. 
dw라고 하면 그런데 oltp 거에서는 그렇지 않죠.

참석자 1 
그래서 저 코스트의 실질적인 현실적인 값은 월 기준으로 80 90이 돼야 되는 겁니다. 
그 밑에 뭐라고 돼 있냐면 인덱스 코스트 어저스트 옵티마이저 인덱스 코스트 어저스트 100입니다. 
이건 뭘 의미하냐면 인덱스를 통해서 읽는 읽을 때의 아이오 콜 비용과 멀티 블라 가이어 즉 풀스킨 할 때 멀티 블라 가이어거든요. 
풀스킨 할 때의 아이오 콜이
참석자 1 
100% 동일하다 1 대 1로 보는 거예요. 
굉장히 비현실적인 과정이죠. 실제로는 멀티 블라가오 대비 인덱스 포스는 10이나 2심이 적당합니다. 
스테레스 단계죠 맞잖아요. 네 멀티 블라 풀 스캔 할 때는 멀티 블라가요 하니까 풀스캔 할 때 아이오 콜이 한 번에 동시에 16개 읽어드리니까 그때의 비용이 100이라고 한다면

참석자 1 
그것에 대비해서 인디스를 통해서 읽을 때 싱글 블랙 아이오는 10이나 20이 맞다는 얘기예요. 
그런데 얘는 지금 배를 똑같이 보고 있다는 얘기예요. 
그래서 이 수치의 현실적인 세팅은 10이나 20이나 현실적이라는 거죠. 
그래서 말씀하신 그것을 보정해주는 파라미터예요. 
기본적으로 1 대 1로 보기 때문에 1 대 1로 보지 말고 프리스캔보다 더 지금 멀티 빌라 아이보다 더 낮은 비용으로 비용을 평가를 해라 인디 스펀스 읽으면

참석자 1 
그것을 보존해 주는 파라미터 다 그래서 다시 말씀드리지만 얘는 말하자면 dw에 맞춰진 세팅이라는 얘기예요. 
여러분들이 만약 월드비 시스템이라고 한다면 이디스 캐싱을 좀 더 높여주셔야 되고 인디스 코스트 언저스트는 낮춰주셔야 됩니다. 
이게 초부자를 위한 가셔서 할 얘기는 아닌데 질문이 나왔으니까

참석자 1 
참고해서 말씀드렸습니다. 네 감사합니다. 
재밌지 않나요. 이런 거 이런 거 재밌어요. 
사실은 저런 가 있구나 제가 하는 효과가 있구나 우리는 어떻게 돼 있을까 과연 당연히 안 돼 있겠죠. 
저 말 비밀이라고 알겠습니까 몰라요 모르고 쓰는 거예요. 
그냥
참석자 1 
배울 게 많습니다. sk 관리가 정말 아주 정교해요. 
오락들이 그래서 모든 걸 다 우리가 하고 싶은 건 모든 걸 다 할 수 있어요. 
사이트가 수없이 많거든요. 지금 하세요. 
아까 그냥 평균적으로 그 초일났던 게 1초에 입는다고 했는데 82년 어디까지나 예상치죠 어쨌든 그렇게 단가가 생각하면

참석자 1 
근데 싱가포르하고 신부가 다 다르니까
참석자 1 
근데 그 어디냐 이거는 그리고 아까 얘기한 것처럼 전략 무속에서 인간은 가정인 거잖아요. 
아까 사람도 보여준 것처럼 근데 실제로 그렇지 않잖아요. 
826개의 콜이 발생한다 100% 디스크를 잇는다 가정해서 그런 건데 실질적으로는 826개 콜이 발생하지 않겠죠. 
제보에서 쓸 것도 있겠죠. 이게 실제적인 코스 요보다 조금 더 낮을 겁니다. 
근데 그걸 어떻게 하겠습니까 실행력이 맞는 단계에서

참석자 1 
이 코리는 1시간 뒤에 수용될 수도 있고 내일 수행될 수도 있고 바로 직후에 수행될 수도 있는데 그때그때 상황에 따라 휴팁은 다를 거 아닙니까 그러니까 예상을 큰 이제 옵티마이즈가 한계를 보이는 또 다른 이유 중에 하나인 이 거리가 도대체 언제 시행될지도 모르고 그 시점에 실행률 무렵의 버포켓이 히트율이 얼마큼 될 것인지 어떻게 알아요. 
그러니까 모르겠다는 거야 모르겠다 하고 그냥 100% 가정하고 하는 거예요.

참석자 1 
블록 단위의 아이의 개념을 설명드렸고 그다음에 이 블록들을 읽을 때 크게 2가지 방식으로 있습니다. 
시퀀셜 에센스와 랜선 에센스가 있습니다. 
시퀀셜 에센스는 말 그대로 순차적으로 데이터를 읽는 거예요. 
우리가 테이블 데이터를 읽을 때 크게 두 가지 방식을 사용하잖아요. 
풀스캔을 하든지 인덱스를 이용하는 게
참석자 1 
풀 스캔은 기본적으로 시퀀셜 렉세스입니다. 
여기 태블에 속한 모든 블록들을 순차적으로 쭉 읽어나가기 때문에 시퀀셜 렉서스고 인덱스를 통해서 읽을 때는 크게 2가지가 있는데 인스를 스캔하는 단계가 있고 인덱스를 스캔한 결과로서 로와이드를 얻어서 그 와이드로 테이블을 찾아가는 단계가 있어요. 
그래서 인덱스를 스캔하는 단계는 시퀀셜 에센스예요. 
리프 블락을 숫자적으로 쭉
참석자 1 
논리는 순서를 따로 됐지 않습니까 그래서 시커션 에센스고 거기서 얻은 로이드를 가지고 테이블을 찾아가요 엑셀로 말하면 1번 시트 갔다가 3번 시트 갔다가 8번 시트 갔다가 다시 1번 갔다가 2번 갔다가 5번 갔다가 8번 갔다가 또 1번 갔다가 랜덤하게 하나의 레코드를 이렇게 해서 뻔뻔히 이렇게 다 저리 뛰었다. 
랜덤하게 튀어 들어가는 거죠. 그것이 랜덤 에센스입니다.

참석자 1 
솔치케는 솔치케는 항상 시퀀셜 리스
참석자 1 
그래서 이걸 실선으로 표현한 것이 시컷이 레세스고 점선으로 표현한 것이 랜덤 에세스 그 시퀀스 엑세스는 레코드 간의 논리적 또는 물리적 순도를 따라서 차례대로 읽어나가는 방식이다. 
랜덤 액세스는 그런 순서를 따르지 않고 한 건을 읽기 위해서 이게 중요한 겁니다 한 건을 읽기 위해서 블록을 접근하는 방식이다.

참석자 1 
한 건 하나의 레코드를 입기 위해서 블록을 통째로 입는 거예요. 
얼마나 비효율적입니까 네 그래서 여러분들 그 친절한 에스크팅에 보면 아주 초반부터 딱 선언을 해놨어요. 
제가 sk은 에스큐티은 랜덤 마이오 전쟁이다. 
거기서 말한 랜덤 마이오가 이걸 얘기하는 거예요. 
랜더 마이오 전쟁 제가 이 말을 오라 성문 보도에서 굉장히 여러 번에 강조를 했는데도 불구하고 에스카트 시험 보시는 분들 보면 그 랜덤와웨어의 중요성을 잘 모르고

참석자 1 
시험을 못 치더라고요 그 중요한 거를 베스트 팀을 통 틀어서 하나를 고르라고 하면 가장 핵심적인 성능 요소 하나 성능이 느린 성능 하나 아까 제가 디스크 아이라고 말씀드렸지 않습니까 그 디스크 아이오에서도 구체적으로 더 들어가는 이 랜드 마이어 랜덤 마이어 랜덤 마이어 는 성명이 드는 거예요. 
이거는 트링을 실제로 해보신 분들은 다 느끼는 거거든요. 
근데 그걸
참석자 1 
실전 없이 그냥 책만 보신 분들이 보라스 보다를 몇 번 봤다고 하는데도 불구하고 그 본질을 이해를 못하시더라고요 그래서 제가 후속 편으로 만든 치미 에스피 중에는 답답하다 왜 그걸 이해 못하시냐 가장 핵심은 랜드마이어다라는 것을 아예 그냥 일장부터 또 인덱스 시작하면서 그 부분을 계속 강조하면서 시작을 했거든요. 
그래서 에스결팀은 랜더마의 전쟁이다라는 표현까지 써가면서 그걸 강조하고 있는 거예요.

참석자 1 
여러분들 앞으로 보시겠지만 여러분들 마지막 날까지 계속 이거랑 그거 갖고 얘기하실 거예요. 
성능 랜덤 와이어 때문에 느린 거구나 그래서 그것을 해결하기 위해서 어떤 팀들이 존재하고 어떤 오브젝트들을 디비니스에 지원하는지 그거 배우시는 거예요. 
지금 4일 동안 계속 그만큼 랜덤마웨어의 존재를 이해하는 것이 굉장히 중요하다라는 것이죠. 
테이블 이라는 뜻이 예 물리적으로
참석자 1 
선 물리적으로 순서도 있습니다. 물리적 수가 있는데 결국 그 테이블 클릭해서 물리적으로 가서 있는 게 아니고 일단 tc를 찾아보고 없으면 집을 가져 그쪽에서 순서가 물리적으로 그렇죠 여기 보시면 제가 시간이 없어서 이제 생장고 넘어가려고 하면 꼭 질문이 나오더라고요 여기 보세요.

참석자 1 
인덱스는 인덱스는 이렇게 인덱스를 스캔을 하면서 거기서 어떤 와이드를 가지고 주소 값을 가지고 이렇게 찾아가잖아요. 
그러면 풀 스캔은 프스 캔도 결국은 메모리도 찾아보고 어떤 디스크까지 갈 텐데 그러면 어떤 방식으로 내가 이거를 블랙을 인식을 해서 찾아갈 것이냐라는 거죠. 
궁금증이 다 생길 수 있어요. 결론적으로 말씀드리면

참석자 1 
내가 emp 테이블 elp 테이블이라고 하는 세그먼트 있지 않습니까 세그먼트에 속한 불락 목록을 이 첫 번째 이스텐트의 첫 번째 블록에 익스텐트 맥이라는 거 할 수 있어요. 
익스텐트 맥 익스텐트 맥 내 세그먼트의 익스텐트 맵을 갖고 있어요. 
그 익스텐트 맵을 통해서 내가 읽어야 될 블락을 목록을 확인할 수가 있습니다.

참석자 1 
시간이 없으면 보여드릴게요 제가 보세요.

참석자 1 
기기에 익스텐트라는 뷰가 있어요.
참석자 1 
이 스텐트 내에 이 스텐트 테이블을 조회를 해보면 현재 중요한 것처럼 스몰 테이블에 속한 익스텐트 목록을 보여줍니다. 
그 목록에 뭐라고 나와 있냐면 첫 번째 익스텐트 연구원부터 시작하는데 첫 번째 이스텐은 2번 파일에 79023 블록부터 연속된 8개 이 스텐트 정의를 뭐라고 했습니까

참석자 1 
공간을 확장하는 단위라고 했죠. 또 다른 표현으로 연속된 군락이 연속된 집합이라고 얘기했어요. 
그죠 그래서 보시면 첫 번째 익스텐트는 2번 파일의 7 9 02 3 분락으로부터 8개라는 뜻이에요. 
두 번째 익스텐트는 11번 파일의 6 3 6 2 4 8 블락으로부터 연속된 8시에 8번부터 8번부터 이게 그다음에 쭉 내려가다가

참석자 1 
여기 익스텐트 아이디 16은 어때요 11번 빨래 몇 번 블록부터 연속된 118개 처음에는 8개씩 블록을 할당하다가 이것이 16개가 넘어가면 그때부터는 128개씩 블록을 할당을 해요. 
18개씩 얘는 좀 큰 태블인가 보다 하면서 이렇게 시가 거기다 쭉 넘어가면 그다음부터 또 1mg씩 10mg씩 점점 이제 늘려갑니다. 
보시는 것처럼
참석자 1 
이런 식으로 관리를 합니다. 그럼 뭘 할 수 있냐면 제일 첫 번째 익스텐트는 어떻게 읽어요. 
2번 말의 79024 블록을 찾아가죠. 
그러고 찾아가서 거기로부터 6개 8개를 딱 읽는 거예요. 
읽는 과정에 메모리에서 먼저 찾아보고 없으면 디스크에서 석고 그래서 그 인스탠트를 다 입었습니다. 
그럼 두 번째 익스텐트는
참석자 1 
11번 파일에 6 3 6 2 4 블록부터 연습된 8개 그럼 11번 파일에 6 3 6 2 4 파일을 블록을 찾아가서 거기서부터 연습된 8개를 쭉 읽어드리는 거예요. 
이해되십니까 그렇기도 한 테이블로 구성이 이 그렇죠 사실 요 그림이 여러분들 이때 제가 이제 시간이 없어서 생각하고 왔는데 앞에 있어요. 
이 그림이 저기 데이터 저장 뒤쪽에 가보세요. 
그이다. 저장분들에 보면
참석자 1 
1번 팔 2번 팔 보호 팩까지 있는데 밑에는 들 쭉 있지 않습니까 여러 이스텐트들이 있는데 그중에 분홍색 분홍색이 현재 내 내 나의 이스텐트예요. 
이스텐트들이 보시다시피 흩어져 있잖아요. 
흩어져 있지만 여기 보시면 4개가 연속돼 있지 않습니까 중간에는 다른 중간에는 다른 세그먼트가 쓰고 있고 또 여기서부터 연속된 4개

참석자 1 
또 그다음에 여기서부터 6부대 6대 8개 또 다른 세그먼트를 쓰고 있고 6대 6 대 4개 4개 이런 식으로 쓰고 있다는 얘기죠 이 비스텐트 그 이스템티에 속한 블라크를 찾아 읽는 거예요. 
솔직한 한다는 얘기는
참석자 1 
그래서 여러분 제가 조금 전에 보여드린 그 한 게 여기 있지 않습니까 집에 있어 그래서 첫 번째 이텐은 1번 파일로부터 전속된 4개 1번에 2번 칼로부터 연습 등 4개 세 번째는 2번 별로부터 2번 가 1번 플러터 연습 4개

참석자 1 
그리고 인덱스를 통한 엑세스는 인비스를 통해서 내가 이거 될 블러그 인식에 찾아 들어가는 거고 상수에는 이 인 스텐트 맨 인 스텐트 맨이 결국 인덱스 역할을 하는 거예요. 
내가 읽어야 될 블록 목록을 제공해 주는 거죠. 
블록 목록을 있을까요. 지금 인덱스 같은 경우는 순돌 블락이라고

참석자 1 
인디스는 다 싱글락입니다. 키퍼렌털 에세스를 해도 싱글 보다 그렇죠 그렇죠

참석자 1 
질문이 좋은 질문들이 많이 나오고 있고 그래서 저는 사실 되게 다른 제 수업들도 되게 재미도 있고 걱정은 됩니다. 
좋습니다. 나올 만한 질문들이 다 나오고 있어요. 
당연히 궁금하셔야 되거든요.
참석자 1 
보통 이제 운영 체제 같은 경우는 빨강으로 있기 때문에 이 디스크 대왕 이런 걸

참석자 1 
사실 이 블록도 8kg가 있잖아요. 그 8kg의 블록도 물리적으로 들어가면 지난주에도 어때 우리가 스트레핑 얘기했습니다만 스트라이팅에 의해서 이게 흩어질 수가 있어요. 
한 블락이라고 그래서 이게 물리적으로 진짜 가면 한 블락이 있는 게 아니고 오락들이 말하는 물리적이라는 것은 그냥 데이터 파일이거든요. 
근데 사실 그 안으로 들어가 보면 스트라이팅에 의해서

참석자 1 
한 블록 또 여러 개를 또 잊을 수가 있는 거예요. 
쪼개진 것을 동시에 쫙 읽어드리면 한 블록이 위라서 꼭 물리적으로 정말 물리적으로 바로 위험이 있다라는 보장은 없습니다.

참석자 1 
저까지 들어가면 너무 복잡해져요. 우리가 그러면 스트라이팅도 공부해야 되고 또 일이 없으니까 혹시 이제 sa 분들은 그런 구조까지 아시는 분들은 거기까지 연변에서 이렇게 써주시면 방동을 할 수 있는데 아직 우리가 그런 것까지 이해가 없으신 분들은 그런 개념을 같이 묶어서 생각하면 진짜 막 복잡해지고

참석자 1 
그래서 이 스텐트 매트 제가 이 생각하려다가 이번 설명을 드리고 왔는데

참석자 1 
저런 방식으로 이제 디스크에서 데이터를 지금까지 우리는 버버킷스 얘기는 안 했어요. 
디스크에서 읽는 걸 얘기한 거예요. 디스크에서 읽을 때 시퀀셜 레시스 랜덤 레시스를 한다 근데 매번 우리가 디스크에서 읽을 수는 없잖아요. 
그죠 이것이 다 디스크예요. 디스크 테이블 스페이스 안에 있는 테이블 블록 또 이비스 블록을 얘기하는 거고 그 블록들을 저런 방식으로 시카피얼 레지는 랜덤하게 읽어드린다

참석자 1 
근데 우리가 모든 데이터를 메모리를 읽을 수 없으니까 디스크를 들을 수는 없으니까 중간에 캐시를 둡니다. 
공유 캐시의 공유 메모리를 들고 공인 메모리 안에 있는 디비 버퍼 캐시를 통해서 제가 데이터를 읽어드리게 되는 것이죠. 
지난 주에 말씀드린 것처럼 데이터 캐시입니다. 
데이터 캐시 또 다른 캐시 뭐가 있다. 
그랬죠 코드 캐시 라이브리 캐시가 있다. 
그랬죠 지 설명드린 그 패싱과 관련된 정보들을 담아주는

참석자 1 
캐시 공간 라이브러리 캐시 코드 캐시가 되겠고요 지금 우리는 데이터를 캐싱하는 공간을 얘기하고 있습니다. 
비비 이 둘을 헷갈려 하시면 안 돼요 막 헷갈려서 계시는 분들이 많이 계실 거고요 이 디비 버버캐시 좋은 데이터를 이렇게 쓴다는 그렇기 때문에 자주 읽는 블록에 대한 반복적인 아이오 콜 제가 아까도

참석자 1 
모드에 말씀드린 것처럼 결국 성능은 아이오 콜 때문에 내리는 거예요. 
아이오 콜이 많이 발생하면 그렇기 때문에 자주 입는 블락들은 가급적 캐시에서 잘 살 수 있도록 그렇게 구현을 해줘야 되겠다.

참석자 1 
자주 있는 분량에 대한 반복적인 아이오프를 최소화해야 된다 그래서 캐시라는 존재가 있고 그래서 데이터를 우선은 캐시를 먼저 찾아보고 없으면 이제 디스크에 가서 이렇게 되는 것인데 캐시를 찾아보고 비슷하게 갈 때도 크게 2가지 방식이 있다. 
이미 설명드린 것처럼 싱글 블록 아이오가 있고 멀티 블록 아이오가 있어요.

참석자 1 
한 번에 한 블록씩 콜을 하는 방법이 있고 여러 개의 블록을 같이 콜 하는 방법이 있다는 얘기죠 싱글 블록 아이오는 인덱스를 통해서 읽을 때 발생합니다. 
인데스를 통해서 인데스 블락을 읽을 때 그다음에 인덱스에서 얻은 로하이드를 가지고 테이블 블러가 있었어 할 때 그때 바로 싱글 블러 아오 방식으로 바이오프를 합니다.

참석자 1 
그러니까 그런 싱글 블라아이어 디스크 아이어가 발생할 때 나타나는 대기 벨트가 디비 파일 시컨셜리드라는 대기 벤트 아이오프하고 프로세서 잠을 잔다고 그랬죠 잠을 잘 때 이렇게 로이팅을 해보면 디파이 시어서 리들한테 이벤트가 막 나오고 멀티 글라바이오는 풀 스캔할 때 테이블에 풀 스캔하거나

참석자 1 
또 인덱스도 풀스캔을 하는데 풀시하는 게 그냥 그냥 일반 인덱스 풀스캔이 있고 인덱스 테스트 풀스캔이 있어요. 
그중에서 테스트 풀스캔 할 때 왜 멀티 블라와요 합니다. 
보시는 것처럼 멀티 블라와요 단위가 있습니다. 
디백 시커셜 리드 카운트 하는 파라미터인데 이 파라미터에 의해서 멀티 블라와요 단위가 설정이 되는 실제 사인용은 없고요. 
과거 버전에서 도통 가 16이었고 지금은 보통 10가

참석자 1 
118개씩 읽어 드린다 이렇게 생각하시면 되겠다. 
그리고 그때 멀티 블록 아이오 할 때 나타난 이베트가 168 스킨터드 리드라는 데이에서 나타나는 스킨 터드 리드라는 말이 왜 나왔을까요. 
왜 스킨터드가 볼까요. 흩뿌린다는 얘기죠 흩뿌린다 보시면은 어 어떤 한 블록이 블록들 연속된 4개를 읽어드렸어요.

참석자 1 
얘들은 연속돼 있기 때문에 디스크 상에서는 연속돼 있지만 얘들이 매물이 올라갈 때는 자기 자리 찾아 들어가거든요. 
주석 값에 따라서 데이터 블록 주소 값에 따라서 자기가 캐시 돼야 되는 위치가 정해져 있어요. 
그니까 이제 보실 텐데 자기 잘 찾아들어가는 거예요. 
내부적으로 이제 캐시 체인이 여러 개가 있거든요. 
그 체인마다 자기가 들어가야 될 체인이 정해져 있다는 얘기예요. 
데이터 블록 주소에 대해서 그렇기 때문에

참석자 1 
디스크상에서는 연속돼 있는데 메모리에 올라갈 때는 흩뿌려지기 때문에 이제 스케터 데이라는 그런 이름이 붙게 되는 거죠.

참석자 1 
그래서 멀티 블록 아이온은 오라클 땅에서는 8k 바이 아이로 아이오를 하지만 os 단에서는 보통 1m가 아이를 하거든요. 
그러니까 훨씬 더 여유가 있다는 얘기예요. 
그러니까 한 번 아이오프 할 때 한 분 한번 읽어내지 말고 어차피 큰 두레박이 준비돼 있으니까 한 번 더 많이 퍼올리자라는 얘기죠 그는 이제 두레박을 제가 주고 표현한 이유가 이제 바로 그건데

참석자 1 
우리가 이제 관광버스에 40명이 보통 타지 않습니까 관광버스가 손님을 쫙 태우고 어떤 유명한 약수터를 갔어요. 
그래서 그 물을 이제 같이 40명이 먹어야 되는데 40명이 매번 그래박으로 물을 퍼 올리면 40번을 퍼올려야 되지 않습니까 그만큼 시간이 지연이 될 것이고 시간이 지연되면 우리가 관광지를 많이 못 돌아다니지 않습니까 그러니까 어떻게 돼요. 
한 번에 불감이 혈관되는 만큼 가득 채워서 걸리는 거예요.

참석자 1 
다른 집에서 올려서 나도 먹고 옆에 사람도 먹고 옆에 사람도 먹고 같이 먹고 또 그 물을 다 먹고 나면 또다시 퍼올리고 그러면 40건 두자락을 팔릴 것이 아니고 그리고 한 네 번 정도를 퍼 올리면 40명이 다 먹을 수 있다는 얘기죠 그 원리인 거예요. 
어차피 풀스캔은 풀스는 말 그대로 프리스킨이기 때문에 그 태그에 속한 모든 블록을 다 읽어야 되거든요.

참석자 1 
다 가지 했는데 이스텐트 메이어스에서 블록을 확인하고 블록을 뻔뻔히 메모리 찾아보면 어떤 디스크라고 없어 이걸 계속 콜이 많이 발생시키면 콜이 많이 발생하는 만큼 성이 늘어질 거 아닙니까 그러니까 어차피 어차피 시에는 모든 걸 다 읽어야 되니까 한 번 들어갈 때 예를 들면 내가 이 블록을 메모리 찾아보니 이 블록을 메모리를 찾아보니까 없었어요.

참석자 1 
없었으면 그 블랙만 입는 것이 아니고 이 스텐트 안에 있는 옆에 인접한 블러들을 같이 퍼리는 겁니다. 
어차피 이 뒤에 있는 그 나를 쭉 읽어 나갈 거잖아요. 
읽어 나갈 거니까 얘를 읽어드릴 때 한 번에 같이 버리는 거죠. 
그러면 한 번은 아이오p이 발생하지만 연이은 4번은 알코올이 발생하지 않을 거 아닙니까 그 원리입니다. 
그래서 여기 보면 이 스텐트 블록 인접한 블록이 여기 보면

참석자 1 
아이오프를 할 때 인접한 블락을 같이 읽어서 메모에 적재한다고 돼 있는데 여기서 말하는 인접한 블록이라는 것은 인스탠트 경계를 초과하지 못해요. 
이건 무슨 얘기냐면 여기 보시면 이 센트 안에 지금 16개 블락이 있잖아요. 
16개 그죠 근데 아이오 콜이 다리가 10이에요. 
그러면 10개를 읽어드리겠죠. 1개를 첫 번째 콜에서 그다음에 두 번째 콜에서는 하나 둘 셋 넷 다섯 여섯 개

참석자 1 
4개가 부족하네요. 그죠 4개가 부족하면 이쪽에 가서 4개를 가져오느냐 하면 배치 못하다는 얘기죠 왜냐하면 이 스탠트 기기를 넘지 못하기 때문에 아이오 단위가 멀티 블라 리드 카운트 아이오 단위가 10개라고 하더라도 6개를 읽었으면 6개만 읽고 끝내는 거예요. 
첫 번째는 10개 있고 두 번째는 6개 있고 끝 나머지는 그다음에 가서 또 10개 있고 또 6개 있고 10개 있고 6개 있고 이렇게 읽어 나가겠죠.

참석자 1 
익스테트 경기를 넘지 못한다라는 거 기억하시면

참석자 1 
여기까지 질문 있으실까요. 예 예예 예예 제가 이제 그림으로 표현하기가 어려워서 4로 했는데 기본은 보통 16이고 최근 버전에서는 118로 돼 있습니다.

참석자 1 
또 진정한 하락일 때 얘가 결정이 되는 거야

참석자 1 
dbms들 보면 w 하고 osp용 프로그램이 따로 나오기도 하는 것 같은데 그런 것들이 이제 아까 말씀해 주셨던 어떤 파라미터들이 조정에 있는 그런 일을 예 조정하는 방법이 크게 2가지가 있는데요. 
네 네 우선은 블록 사이즈를 조절하는 방법이 있어요. 
여기 그림에도 있다시피 네 otp는
참석자 1 
지난번에 설명드린 것처럼 주로 로다인 처리를 많이 하잖아요. 
특정 고객 특정 계좌 특정 상품을 많이 처리하기 때문에 하나의 레코드를 일으켜서 많은 블록 예를 들면 16kg짜리 블록을 쓰고 있다 라 그러면 한 레코드 이게 16kg 블록이 있는 거예요. 
이게 배우적이 되겠죠. 멀티에서는 작으면 좀 더 유리해요. 
그리고 dw에서는 주로 풀스트을 하기 때문에 큰 사이즈의 블락이 유리하다는 얘기죠 그 오라클은

참석자 1 
2k 4k 8k 16 케이 그다음에 os에 따라서 32k이도 지원을 해요. 
지원 안 하는 기도 있고 그래서 이것을 우리가 dv를 설치할 당시에 선택을 할 수가 있습니다. 
뒤에 이렇게 dw는 가적 크게 오 팀이 작게 이렇게 할 수가 있고 근데 굳이 그럴 하는 경우는 없어요. 
대부 다 팔트를 포트로 씁니다. 볼트로 그냥 쓰고 하고 1% 서버는 82로 단위 사이즈만 지원을 하고

참석자 1 
오라클은 2 4 8 16 302를 지원하지만 대게는 8%를 그냥 쓰고 또 대신 많은 데이터를 읽을 때는 멀티 블랙 이렇게 카운트를 늘리고 있다는 결국 같은 효과가 있는 거거든요. 
블락 사이서 애초에 크게 하는 방법도 있고 프러사이는 그냥 두볼트 두고 멀티 블록 아이요 리드 카운트를 늘려서 늘려서 한 번에 동시에 여러 개 블록을

참석자 1 
콜 횟수가 성분을 자는 거니까 콜레스를 줄여주는 방법이 되는 것이죠. 
불편하게 이 블록 사이즈를 크게 구해주게 되면 키트를 아무래도 안 좋아질 거예요. 
불필요한 블록들이 많이 메모리에 올라오는 바람에 올라오는 만큼 다르 밀어내야 되니까 세리프트로 시티를 나빠줄 그런 효과가 있을 수 있다는 얘기죠

참석자 1 
나는 이 16k 블록에 속한 특정 레코드 하나 읽으려고 했는데 그 속에 속한 몇 천 개 블록이 몇 천 개 레코드 같이 올라오는 거니까  그만큼 비율이 생기겠죠.

참석자 1 
또 다른 질문 있으시면 잠깐 쉬었다 가겠습니다. 
15분입니다. 아까 우리가 10분에 시작했는데 보통 50분 교육이 10분씩인데 저희가

참석자 1 
30분에 시작하겠습니다.
