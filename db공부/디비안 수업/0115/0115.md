# 2022.01.15 수업


- DISK I/O
    - Single Block I/O
        - 평균 10ms (초당 100블록)
        - 평균 4~8ms (초당 125~250) 시스템마다 다르긴 하지만 대략 이정도
        
    - Multi Block I/O


쿼리를 짜고 나선 i/o 확인을 꼭 해봐야함.
"배포 후에도 테스트 할 때 처럼 빠를 수 있는가" 를 생각하면서 쿼리를 짜야 함

I/O가 발생 할 때마다 DBA들이 로그를 남기는데 이걸 ```대기 이벤트``` 라고 합니다.
이 대기 이벤트를 남기는 이유는 프로세스가 왜 잠들었는지 확인하기 위해서고 이런걸 ResponseTime Analysis라고 합니다.

ResponseTime Analysis : sqlp 공부하려면 한번쯤은 알아야함

## 블록단위 I/O
- Row Chain : 하나의 레코드가 하나의 블록에 저장 되어야 하는데 그 레코드의 바이트가 8byte를 넘어서 2개의 블록에 걸쳐서 저장 되는 경우

- Row Migration : 한블락에 들어갈수 있는 사이즈였는데 이 데이터를 업데이트 했더니 그 블록에 다 안 들어가는거!! 그럴 경우에 RowId는 그 블록에 남겨두되 그 데이터는 다른 여유있는 블록으로 옮겨놓습니다.
    - 최대한 안 일어나는게 좋은 거.. 
    - pct used / pct free 



``` show parameter optimizer ```

optimizer_index_caching 은 낮아야 합니다. 
optimizer_index_caching의 value가 100이면 이건 disk에서 모든걸 읽는다 즉 캐싱된 데이터가 0이란 말도 안 되는 설정. 
optimizer_index_cost_adj 의 value는  20정도가 적당합니다.
왜냐면 single block i/o 와 multi block i/o의 i/o 부하는 다르기 때문입니다.

더 자세한 건 집에 가서 공부해보기로


# 디스크에서 읽을 경우 > Sequential & Random
테이블스페이스의 익스텐트의 블락을 읽음
- Sequential
    - INDEX FULL SCAN

- Random

# EXTENT MAP VIEW 조회

```
SELECT * FROM DBA_EXTENT
WHERE OWNER = USER
AND SEGMENT_NAME= 'SNALL_USER';
```

익스텐트 목록을 보여주니다.

첫번째 익스텐트는 2번 파일에 97024 블록으로부터 연속된 8개의 블록
두번째 익스텐트는 11번 파일의 6*** 블록으로부터 연속된 8개의 블록 
...

그러면 테이블 풀스캔의 경우 이 익스텐트 목록부터 찾아서 이 파일의 블록에서부터 SELECT  

##### ~~스트라이핑..?~~

# DB버퍼 캐시에서 읽을 경우 
공유 메모리의 DB버퍼 캐시, 데이터를 캐싱해서 읽는 경우


## write ahead logging 
서버 -> dbwriter -> dirty block log 기록 해달라 -> log writer -> log 기록
-> dbwriter가 dirty block 을 disk에 동기화 -> 캐쉬 비움 -> 다른 데이터 캐쉬에 적재

log는 10mb짜리 조그만 파일
## log force at commit


# 논리적 I/O , 물리적 I/O

# 버퍼캐시 매퍼니즘
오라클의 버퍼캐시는 해시 구조로 관리
정확히는 버퍼 헤더가 해시구조입니다.

ROWID = N파일 + N번째 블락 
이 ROWID로 블럭을 찾아간다.

버퍼 체인 래치를 통해서 테이블 블락에 엑세스 할 주소에 접근하는 걸 락을 겁니다

```
SELECT * FROM DUAL;

SELECT ROWID, DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID) BLOCK_NO 
FROM DUAL;

SELECT SYSDATE
FROM DUAL;
```
듀얼 테이블도 테이블이라서 래치 경합이 있을 수 있으니 웬만하면 듀얼테이블을 통해 함수를 쓰고 그런 일은 좀 줄이도록..

그것 외에도 프로그램상 아주 많이 사용하는 테이블은 래치 경합이 심함

익스텐트가 처음엔 작게 시작해서 점점 커지는데 테이블 풀스캔을 하는 경우엔 차라리 익스텐트를 크게 잡아주면 I/O 콜 횟수가 적어져서 성능이 좋아짐

해쉬조인을 통해서 블락에 접근하면 SGA가 아니라 PGA에 저장을 한다고? 

##### ~~저 궁금한거 있어요 꼭 /*+ */ 힌트를 적고 컬럼명 적어야해요?~~

``` SQL
SELECT /*+ ORDERED USE_NL(B) USE_NL(C) USE_NL(D) */ A.등록일시, A.번호, A.제목,
B.회원명, C.게시판유형, D.질문유형명, FUNC_ICON(D.질문유형코드)아이콘 , (SELECT COUNT(*) FROM 댓글 WHERE 번호 = A.번호) 댓글갯수
FROM (
    SELCT A,*, ROWNUM NO
    FROM (
        SEKECT 등록일시 ,번호 ,제목 ,작성자번호 ,게시판유형코드 ,질문유형코드
        FROM 게시판
        WHERE 게시판유형코드 =: TYPE
        AND 작성자번호 IS NOT NULL
        AND 질문유형코드 IS NOT NULL
        ORDER BY 등록일시 DESC, 질문유형코드, 번호
    )A
    WHERE ROWNUM <= 30 
)A, 회원 B , 게시판유형 C , 질문유형 D
WHERE  A.NO BETWEEN 21 AND 30
AND B.회원번호 = A. 작성자번호
AND C.게시판유형코드 = A.게시판유형코드
AND D.질문유형코드 = A.질문유형코드
ORDER BY A.등록일시 DESC , A.질문유형코드 , A.번호
```
##### ~~WHERE절에 거는 조건순서에 따라서도 좀 달라지는거 아닌가? 그래서 비트윈이 제일 위에 올라오게 된거지?~~

위 쿼리에선 FUNC_ICON을 스칼라서브쿼리로 내리는게 더 좋습니다.


## 쿼리 튜닝 최적화의 3가지 
- DB CALL 최소화 
    - 사용자 정의 함수는 가급적 쓰지 않는게 좋습니다.
    - DB 저장형 프로시저는 사용해도 나쁘진 않지만 어쩔 수 없이 쓴다면 어쩔 수 없지만...
- 라이브러리 캐쉬 최적화
- IO  CALL 최적화

``` SQL
-- 기깔나는 count
SELECT COUNT(*), COUNT(CASE WHEN OWNER = 'SYS' THEN 1 END)
FROM T;
```

```sql
--옵티마이저 모드 확인하는 sql
SELECT * FROM V$PARAMETER
WHERE NAME LIKE '%optimizer_mode%';
```


# INDEX 원리와 활용

다음주엔 BTWEEN으로
INDEX를 검색할 때 4-25  참고



# 쿼리튜닝

### 실행계획 설정하는법
<img src = '../../.././img/0115_1.png'>

### 바인딩 변수 설정하는법
<img src = '../../.././img/0115_2.png'>

```sql
-- 내가 짠 쿼리
SELECT 종목영문심볼, 거래일시, SUBSTR(거래일시,9,6) 거래시각, 현재환율가격
  FROM  edu.실시간환율
WHERE  종목영문심볼 = 'USDKRWCOMP'   AND  해외은행코드 = 'EUAM'  AND 거래일시 BETWEEN '20190601090000' AND '20190601150000';

-- 선생님이 짠 쿼리
SELECT 종목영문심볼, 거래일시, SUBSTR(거래일시,9,6) 거래시각, 현재환율가격
  FROM  edu.실시간환율
WHERE  종목영문심볼 = 'USDKRWCOMP'   AND  해외은행코드 = 'EUAM'  AND 거래일시 BETWEEN :trdDd || '090000' AND :trdDd || '150000';

```

###### 난 바인딩 변수를 사용하는 방법을 몰라서 쿼리 짜는게 늦었지만 <span style='COLOR:#A71FEB'>나 맞았음</span> 그리고 쿼리박스 이상하게 오류가 난다.. sqlplus에서는 잘 되는데 쿼리박스에서 실행만 하면 오류가 난다.. 앞으로 쿼리박스는 자동완성 용도로만 써야겠다


[PL/SQL 참고](https://lovefor-you.tistory.com/252)


```sql
index(e(ename)) : ename을 사용하는 index를 사용해라 라는 뜻

-- 1. 중간값 검색
select /*+ index(e (ename)) */ * 
from   emp e
where  ename like '%AM%';

-- 2. 인덱스 컬럼 변형
select /*+ index(e (ename)) */ * 
from   emp e
where  substr(ename, 1, 2) = 'CL';


select /*+ index(e (sal)) */ * 
from   emp e
where  nvl(sal, 0) < 100;


-- 3. 부정형 비교
select /*+ index(e (job)) */ * 
from   emp e
where  job <> 'SALESMAN';


-- 4. OR 조건절
select /*+ 2index(e) */ *
from   emp e
where (job = :job
       or
       ename = :ename);

select /*+ use_concat */ *
from   emp e
where (job = :job
       or
       ename = :ename);

-- 5. use_concat 하지 않겠다는 인덱스
select /*+ no_expand */ *
from   emp e
where (job = :job
       or
       ename = :ename);
```

or조건은 원래 인덱스를 타지 않는데 저런 식으로 use_concat을 하면 오라클이 알아서 union all로 쪼개서 인덱스를 타게 해줍니다


































